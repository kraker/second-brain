/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DefinitionListPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var CODE_BLOCK_DELIMITER = "```";
var DEFINITION_REGEX = /^(\s*)([:~])\s/;
var HEADING_REGEX = /^#+\s/;
var LIST_ITEM_REGEX = /^\s*(\*|\+|-|\d+\.)\s/;
var HORIZONTAL_RULE_REGEX = /^(-{3,}|\*{3,}|_{3,})/;
function isLivePreview(view) {
  var _a;
  const editorEl = view.dom.closest(".markdown-source-view");
  return (_a = editorEl == null ? void 0 : editorEl.classList.contains("is-live-preview")) != null ? _a : false;
}
var definitionListPlugin = import_view.ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.buildDecorations(view);
  }
  update(update) {
    if (update.docChanged || update.viewportChanged || update.selectionSet) {
      this.decorations = this.buildDecorations(update.view);
    }
  }
  buildDecorations(view) {
    if (!isLivePreview(view)) {
      return import_view.Decoration.none;
    }
    const builder = new import_state.RangeSetBuilder();
    const doc = view.state.doc;
    const selection = view.state.selection;
    let inCodeBlock = false;
    let lastLineWasTerm = false;
    let lastLineWasDefinition = false;
    function isNotTerm(content) {
      return HEADING_REGEX.test(content) || LIST_ITEM_REGEX.test(content) || content.startsWith("![") || HORIZONTAL_RULE_REGEX.test(content) || content.startsWith("[^") || content.startsWith("|") || content.startsWith("$$") || content.startsWith("^");
    }
    for (let i = 1; i <= doc.lines; i++) {
      const line = doc.line(i);
      const lineText = line.text;
      const trimmedLineText = lineText.trim();
      if (trimmedLineText.startsWith(CODE_BLOCK_DELIMITER)) {
        inCodeBlock = !inCodeBlock;
        lastLineWasTerm = false;
        lastLineWasDefinition = false;
        continue;
      }
      if (inCodeBlock) {
        lastLineWasTerm = false;
        lastLineWasDefinition = false;
        continue;
      }
      const definitionMatch = DEFINITION_REGEX.exec(lineText);
      const nextLine = i < doc.lines ? doc.line(i + 1).text : "";
      const isNextLineDefinition = DEFINITION_REGEX.test(nextLine.trim());
      if (trimmedLineText === "") {
        lastLineWasTerm = false;
        lastLineWasDefinition = false;
      } else if (definitionMatch && (lastLineWasTerm || lastLineWasDefinition)) {
        const [, indent, marker] = definitionMatch;
        const isIndented = indent.length > 0;
        builder.add(
          line.from,
          line.from,
          import_view.Decoration.line({
            attributes: { class: isIndented ? "dl-dd-indent" : "dl-dd-reg" }
          })
        );
        const indentStartPos = line.from;
        const markerEndPos = indentStartPos + indent.length + marker.length + 1;
        const isCursorTouchingIndentOrMarker = selection.ranges.some(
          (range) => range.from <= markerEndPos && range.to >= indentStartPos
        );
        builder.add(
          indentStartPos,
          markerEndPos,
          import_view.Decoration.mark({
            attributes: { class: isCursorTouchingIndentOrMarker ? "dl-marker" : "dl-hidden-marker" }
          })
        );
        lastLineWasDefinition = true;
        lastLineWasTerm = false;
      } else if (isNextLineDefinition && !isNotTerm(trimmedLineText)) {
        builder.add(
          line.from,
          line.from,
          import_view.Decoration.line({
            attributes: { class: "dl-dt" }
          })
        );
        lastLineWasTerm = true;
        lastLineWasDefinition = false;
      } else {
        lastLineWasTerm = false;
        lastLineWasDefinition = false;
      }
    }
    return builder.finish();
  }
}, {
  decorations: (v) => v.decorations
});
var DefinitionListPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    // Post-processor for handling definition lists in reading mode
    this.definitionListPostProcessor = (element) => {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!activeView || activeView.getMode() === "source")
        return;
      function isNotTerm(content) {
        return content.match(/^#+\s/) !== null || // Heading
        content.match(/^\s*(-|\d+\.)\s/) !== null || // List item
        content.startsWith(">") || // Blockquote
        content.startsWith("<img") || // Image
        content.match(/^(-{3,}|\*{3,}|_{3,})/) !== null || // Horizontal rule
        content.startsWith("[^") || // Footnote
        content.includes('class="footnote-backref footnote-link"') || // Footnote backref
        content.startsWith("|") || // Table
        content.startsWith("$$") || // Math block
        content.startsWith("^");
      }
      console.log("Post processor running");
      const paragraphs = element.querySelectorAll("p");
      paragraphs.forEach((paragraph) => {
        const lines = paragraph.innerHTML.split("<br>");
        let dl = null;
        let currentTerm = null;
        let newContent = [];
        let invalidateCurrentPair = false;
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          const nextLine = i < lines.length - 1 ? lines[i + 1].trim() : "";
          const definitionMatch = line.match(/^(\s*)([:~])\s(.+)/);
          const isNextLineDefinition = nextLine.match(/^(\s*)([:~])\s(.+)/);
          if (definitionMatch && !invalidateCurrentPair) {
            if (definitionMatch[3].includes('class="footnote-backref footnote-link"')) {
              invalidateCurrentPair = true;
            }
            if (currentTerm && !invalidateCurrentPair) {
              if (!dl) {
                dl = document.createElement("dl");
                newContent.push(dl);
                const dt = document.createElement("dt");
                dt.innerHTML = currentTerm;
                dl.appendChild(dt);
              }
              const dd = document.createElement("dd");
              dd.innerHTML = definitionMatch[3];
              dl.appendChild(dd);
            } else {
              if (currentTerm) {
                newContent.push(currentTerm + "<br>");
              }
              newContent.push(line + "<br>");
              currentTerm = null;
              invalidateCurrentPair = false;
            }
          } else if (isNextLineDefinition && !isNotTerm(line) && !invalidateCurrentPair) {
            currentTerm = line;
            dl = null;
          } else {
            if (currentTerm) {
              newContent.push(currentTerm + "<br>");
              currentTerm = null;
            }
            newContent.push(line + "<br>");
            dl = null;
            invalidateCurrentPair = false;
          }
        }
        paragraph.innerHTML = "";
        newContent.forEach((content) => {
          if (typeof content === "string") {
            paragraph.innerHTML += content;
          } else {
            paragraph.appendChild(content);
          }
        });
      });
    };
  }
  async onload() {
    console.log("Definition List Plugin loaded");
    this.registerMarkdownPostProcessor(this.definitionListPostProcessor);
    this.registerEditorExtension(definitionListPlugin);
  }
  onunload() {
  }
};

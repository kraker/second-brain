var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// node_modules/.pnpm/moment@2.30.1/node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/.pnpm/moment@2.30.1/node_modules/moment/moment.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback2) {
        hookCallback = callback2;
      }
      function isArray2(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject2(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a2, b2) {
        return Object.prototype.hasOwnProperty.call(a2, b2);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber2(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map3(arr, fn2) {
        var res = [], i2, arrLen = arr.length;
        for (i2 = 0; i2 < arrLen; ++i2) {
          res.push(fn2(arr[i2], i2));
        }
        return res;
      }
      function extend(a2, b2) {
        for (var i2 in b2) {
          if (hasOwnProp(b2, i2)) {
            a2[i2] = b2[i2];
          }
        }
        if (hasOwnProp(b2, "toString")) {
          a2.toString = b2.toString;
        }
        if (hasOwnProp(b2, "valueOf")) {
          a2.valueOf = b2.valueOf;
        }
        return a2;
      }
      function createUTC(input, format2, locale3, strict) {
        return createLocalOrUTC(input, format2, locale3, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m2) {
        if (m2._pf == null) {
          m2._pf = defaultParsingFlags();
        }
        return m2._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t3 = Object(this), len = t3.length >>> 0, i2;
          for (i2 = 0; i2 < len; i2++) {
            if (i2 in t3 && fun.call(this, t3[i2], i2, t3)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m2) {
        var flags = null, parsedParts = false, isNowValid = m2._d && !isNaN(m2._d.getTime());
        if (isNowValid) {
          flags = getParsingFlags(m2);
          parsedParts = some.call(flags.parsedDateParts, function(i2) {
            return i2 != null;
          });
          isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m2._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
        }
        if (Object.isFrozen == null || !Object.isFrozen(m2)) {
          m2._isValid = isNowValid;
        } else {
          return isNowValid;
        }
        return m2._isValid;
      }
      function createInvalid(flags) {
        var m2 = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m2), flags);
        } else {
          getParsingFlags(m2).userInvalidated = true;
        }
        return m2;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to3, from3) {
        var i2, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from3._isAMomentObject)) {
          to3._isAMomentObject = from3._isAMomentObject;
        }
        if (!isUndefined(from3._i)) {
          to3._i = from3._i;
        }
        if (!isUndefined(from3._f)) {
          to3._f = from3._f;
        }
        if (!isUndefined(from3._l)) {
          to3._l = from3._l;
        }
        if (!isUndefined(from3._strict)) {
          to3._strict = from3._strict;
        }
        if (!isUndefined(from3._tzm)) {
          to3._tzm = from3._tzm;
        }
        if (!isUndefined(from3._isUTC)) {
          to3._isUTC = from3._isUTC;
        }
        if (!isUndefined(from3._offset)) {
          to3._offset = from3._offset;
        }
        if (!isUndefined(from3._pf)) {
          to3._pf = getParsingFlags(from3);
        }
        if (!isUndefined(from3._locale)) {
          to3._locale = from3._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i2 = 0; i2 < momentPropertiesLen; i2++) {
            prop = momentProperties[i2];
            val = from3[prop];
            if (!isUndefined(val)) {
              to3[prop] = val;
            }
          }
        }
        return to3;
      }
      function Moment3(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = /* @__PURE__ */ new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment3 || obj != null && obj._isAMomentObject != null;
      }
      function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn2) {
        var firstTime = true;
        return extend(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i2, key, argLen = arguments.length;
            for (i2 = 0; i2 < argLen; i2++) {
              arg = "";
              if (typeof arguments[i2] === "object") {
                arg += "\n[" + i2 + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i2];
              }
              args.push(arg);
            }
            warn(
              msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn2.apply(this, arguments);
        }, fn2);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction2(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set2(config) {
        var prop, i2;
        for (i2 in config) {
          if (hasOwnProp(config, i2)) {
            prop = config[i2];
            if (isFunction2(prop)) {
              this[i2] = prop;
            } else {
              this["_" + i2] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject2(parentConfig[prop]) && isObject2(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject2(parentConfig[prop])) {
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function(obj) {
          var i2, res = [];
          for (i2 in obj) {
            if (hasOwnProp(obj, i2)) {
              res.push(i2);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now3) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction2(output) ? output.call(mom, now3) : output;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign3 = number >= 0;
        return (sign3 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback2) {
        var func = callback2;
        if (typeof callback2 === "string") {
          func = function() {
            return this[callback2]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func.apply(this, arguments),
              token2
            );
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format2) {
        var array = format2.match(formattingTokens), i2, length;
        for (i2 = 0, length = array.length; i2 < length; i2++) {
          if (formatTokenFunctions[array[i2]]) {
            array[i2] = formatTokenFunctions[array[i2]];
          } else {
            array[i2] = removeFormattingTokens(array[i2]);
          }
        }
        return function(mom) {
          var output = "", i3;
          for (i3 = 0; i3 < length; i3++) {
            output += isFunction2(array[i3]) ? array[i3].call(mom, format2) : array[i3];
          }
          return output;
        };
      }
      function formatMoment(m2, format2) {
        if (!m2.isValid()) {
          return m2.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m2.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m2);
      }
      function expandFormat(format2, locale3) {
        var i2 = 5;
        function replaceLongDateFormatTokens(input) {
          return locale3.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i2 >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i2 -= 1;
        }
        return format2;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction2(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff2, output) {
        var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction2(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      var aliases = {
        D: "date",
        dates: "date",
        date: "date",
        d: "day",
        days: "day",
        day: "day",
        e: "weekday",
        weekdays: "weekday",
        weekday: "weekday",
        E: "isoWeekday",
        isoweekdays: "isoWeekday",
        isoweekday: "isoWeekday",
        DDD: "dayOfYear",
        dayofyears: "dayOfYear",
        dayofyear: "dayOfYear",
        h: "hour",
        hours: "hour",
        hour: "hour",
        ms: "millisecond",
        milliseconds: "millisecond",
        millisecond: "millisecond",
        m: "minute",
        minutes: "minute",
        minute: "minute",
        M: "month",
        months: "month",
        month: "month",
        Q: "quarter",
        quarters: "quarter",
        quarter: "quarter",
        s: "second",
        seconds: "second",
        second: "second",
        gg: "weekYear",
        weekyears: "weekYear",
        weekyear: "weekYear",
        GG: "isoWeekYear",
        isoweekyears: "isoWeekYear",
        isoweekyear: "isoWeekYear",
        w: "week",
        weeks: "week",
        week: "week",
        W: "isoWeek",
        isoweeks: "isoWeek",
        isoweek: "isoWeek",
        y: "year",
        years: "year",
        year: "year"
      };
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {
        date: 9,
        day: 11,
        weekday: 11,
        isoWeekday: 11,
        dayOfYear: 4,
        hour: 13,
        millisecond: 16,
        minute: 14,
        month: 8,
        quarter: 7,
        second: 15,
        weekYear: 1,
        isoWeekYear: 1,
        week: 5,
        isoWeek: 5,
        year: 1
      };
      function getPrioritizedUnits(unitsObj) {
        var units = [], u2;
        for (u2 in unitsObj) {
          if (hasOwnProp(unitsObj, u2)) {
            units.push({ unit: u2, priority: priorities[u2] });
          }
        }
        units.sort(function(a2, b2) {
          return a2.priority - b2.priority;
        });
        return units;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, match1to2NoLeadingZero = /^[1-9]\d?/, match1to2HasZero = /^([1-9]\d|\d)/, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction2(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s2) {
        return regexEscape(
          s2.replace("\\", "").replace(
            /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
            function(matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
            }
          )
        );
      }
      function regexEscape(s2) {
        return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      var tokens = {};
      function addParseToken(token2, callback2) {
        var i2, func = callback2, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber2(callback2)) {
          func = function(input, array) {
            array[callback2] = toInt(input);
          };
        }
        tokenLen = token2.length;
        for (i2 = 0; i2 < tokenLen; i2++) {
          tokens[token2[i2]] = func;
        }
      }
      function addWeekParseToken(token2, callback2) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback2(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      addFormatToken("Y", 0, 0, function() {
        var y2 = this.year();
        return y2 <= 9999 ? zeroFill(y2, 4) : "+" + y2;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }
      function get(mom, unit) {
        if (!mom.isValid()) {
          return NaN;
        }
        var d2 = mom._d, isUTC = mom._isUTC;
        switch (unit) {
          case "Milliseconds":
            return isUTC ? d2.getUTCMilliseconds() : d2.getMilliseconds();
          case "Seconds":
            return isUTC ? d2.getUTCSeconds() : d2.getSeconds();
          case "Minutes":
            return isUTC ? d2.getUTCMinutes() : d2.getMinutes();
          case "Hours":
            return isUTC ? d2.getUTCHours() : d2.getHours();
          case "Date":
            return isUTC ? d2.getUTCDate() : d2.getDate();
          case "Day":
            return isUTC ? d2.getUTCDay() : d2.getDay();
          case "Month":
            return isUTC ? d2.getUTCMonth() : d2.getMonth();
          case "FullYear":
            return isUTC ? d2.getUTCFullYear() : d2.getFullYear();
          default:
            return NaN;
        }
      }
      function set$1(mom, unit, value) {
        var d2, isUTC, year, month, date;
        if (!mom.isValid() || isNaN(value)) {
          return;
        }
        d2 = mom._d;
        isUTC = mom._isUTC;
        switch (unit) {
          case "Milliseconds":
            return void (isUTC ? d2.setUTCMilliseconds(value) : d2.setMilliseconds(value));
          case "Seconds":
            return void (isUTC ? d2.setUTCSeconds(value) : d2.setSeconds(value));
          case "Minutes":
            return void (isUTC ? d2.setUTCMinutes(value) : d2.setMinutes(value));
          case "Hours":
            return void (isUTC ? d2.setUTCHours(value) : d2.setHours(value));
          case "Date":
            return void (isUTC ? d2.setUTCDate(value) : d2.setDate(value));
          // case 'Day': // Not real
          //    return void (isUTC ? d.setUTCDay(value) : d.setDay(value));
          // case 'Month': // Not used because we need to pass two variables
          //     return void (isUTC ? d.setUTCMonth(value) : d.setMonth(value));
          case "FullYear":
            break;
          // See below ...
          default:
            return;
        }
        year = value;
        month = mom.month();
        date = mom.date();
        date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
        void (isUTC ? d2.setUTCFullYear(year, month, date) : d2.setFullYear(year, month, date));
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction2(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i2, prioritizedLen = prioritized.length;
          for (i2 = 0; i2 < prioritizedLen; i2++) {
            this[prioritized[i2].unit](units[prioritized[i2].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction2(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      function mod(n2, x2) {
        return (n2 % x2 + x2) % x2;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o2) {
          var i2;
          for (i2 = 0; i2 < this.length; ++i2) {
            if (this[i2] === o2) {
              return i2;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addRegexToken("M", match1to2, match1to2NoLeadingZero);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale3) {
        return locale3.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale3) {
        return locale3.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m2, format2) {
        if (!m2) {
          return isArray2(this._months) ? this._months : this._months["standalone"];
        }
        return isArray2(this._months) ? this._months[m2.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m2.month()];
      }
      function localeMonthsShort(m2, format2) {
        if (!m2) {
          return isArray2(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray2(this._monthsShort) ? this._monthsShort[m2.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m2.month()];
      }
      function handleStrictParse(monthName, format2, strict) {
        var i2, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i2 = 0; i2 < 12; ++i2) {
            mom = createUTC([2e3, i2]);
            this._shortMonthsParse[i2] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i2] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format2, strict) {
        var i2, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i2 = 0; i2 < 12; i2++) {
          mom = createUTC([2e3, i2]);
          if (strict && !this._longMonthsParse[i2]) {
            this._longMonthsParse[i2] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i2] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i2]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i2] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i2].test(monthName)) {
            return i2;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i2].test(monthName)) {
            return i2;
          } else if (!strict && this._monthsParse[i2].test(monthName)) {
            return i2;
          }
        }
      }
      function setMonth(mom, value) {
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber2(value)) {
              return mom;
            }
          }
        }
        var month = value, date = mom.date();
        date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
        void (mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date));
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a2, b2) {
          return b2.length - a2.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, shortP, longP;
        for (i2 = 0; i2 < 12; i2++) {
          mom = createUTC([2e3, i2]);
          shortP = regexEscape(this.monthsShort(mom, ""));
          longP = regexEscape(this.months(mom, ""));
          shortPieces.push(shortP);
          longPieces.push(longP);
          mixedPieces.push(longP);
          mixedPieces.push(shortP);
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      function createDate(y2, m2, d2, h6, M2, s2, ms) {
        var date;
        if (y2 < 100 && y2 >= 0) {
          date = new Date(y2 + 400, m2, d2, h6, M2, s2, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y2);
          }
        } else {
          date = new Date(y2, m2, d2, h6, M2, s2, ms);
        }
        return date;
      }
      function createUTCDate(y2) {
        var date, args;
        if (y2 < 100 && y2 >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y2 + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y2);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addRegexToken("w", match1to2, match1to2NoLeadingZero);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2, match1to2NoLeadingZero);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(
        ["w", "ww", "W", "WW"],
        function(input, week, config, token2) {
          week[token2.substr(0, 1)] = toInt(input);
        }
      );
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale3) {
        return locale3.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale3) {
        return locale3.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale3) {
        return locale3.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale3) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale3.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale3) {
        if (typeof input === "string") {
          return locale3.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n2) {
        return ws.slice(n2, 7).concat(ws.slice(0, n2));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m2, format2) {
        var weekdays = isArray2(this._weekdays) ? this._weekdays : this._weekdays[m2 && m2 !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m2 === true ? shiftWeekdays(weekdays, this._week.dow) : m2 ? weekdays[m2.day()] : weekdays;
      }
      function localeWeekdaysShort(m2) {
        return m2 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m2 ? this._weekdaysShort[m2.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m2) {
        return m2 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m2 ? this._weekdaysMin[m2.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i2, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i2 = 0; i2 < 7; ++i2) {
            mom = createUTC([2e3, 1]).day(i2);
            this._minWeekdaysParse[i2] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i2] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i2] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i2, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i2 = 0; i2 < 7; i2++) {
          mom = createUTC([2e3, 1]).day(i2);
          if (strict && !this._fullWeekdaysParse[i2]) {
            this._fullWeekdaysParse[i2] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i2] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i2] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i2]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i2] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i2].test(weekdayName)) {
            return i2;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i2].test(weekdayName)) {
            return i2;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i2].test(weekdayName)) {
            return i2;
          } else if (!strict && this._weekdaysParse[i2].test(weekdayName)) {
            return i2;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = get(this, "Day");
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a2, b2) {
          return b2.length - a2.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, minp, shortp, longp;
        for (i2 = 0; i2 < 7; i2++) {
          mom = createUTC([2e3, 1]).day(i2);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      function matchMeridiem(isStrict, locale3) {
        return locale3._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2, match1to2HasZero);
      addRegexToken("h", match1to2, match1to2NoLeadingZero);
      addRegexToken("k", match1to2, match1to2NoLeadingZero);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i2, minl = Math.min(arr1.length, arr2.length);
        for (i2 = 0; i2 < minl; i2 += 1) {
          if (arr1[i2] !== arr2[i2]) {
            return i2;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names2) {
        var i2 = 0, j2, next, locale3, split;
        while (i2 < names2.length) {
          split = normalizeLocale(names2[i2]).split("-");
          j2 = split.length;
          next = normalizeLocale(names2[i2 + 1]);
          next = next ? next.split("-") : null;
          while (j2 > 0) {
            locale3 = loadLocale(split.slice(0, j2).join("-"));
            if (locale3) {
              return locale3;
            }
            if (next && next.length >= j2 && commonPrefix(split, next) >= j2 - 1) {
              break;
            }
            j2--;
          }
          i2++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name) {
        return !!(name && name.match("^[^/\\\\]*$"));
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e2) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale3, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale3 = loadLocale(config.parentLocale);
              if (locale3 != null) {
                parentConfig = locale3._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x2) {
              defineLocale(x2.name, x2.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale3, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale3 = new Locale(config);
            locale3.parentLocale = locales[name];
            locales[name] = locale3;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key) {
        var locale3;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray2(key)) {
          locale3 = loadLocale(key);
          if (locale3) {
            return locale3;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys(locales);
      }
      function checkOverflow(m2) {
        var overflow, a2 = m2._a;
        if (a2 && getParsingFlags(m2).overflow === -2) {
          overflow = a2[MONTH] < 0 || a2[MONTH] > 11 ? MONTH : a2[DATE] < 1 || a2[DATE] > daysInMonth(a2[YEAR], a2[MONTH]) ? DATE : a2[HOUR] < 0 || a2[HOUR] > 24 || a2[HOUR] === 24 && (a2[MINUTE] !== 0 || a2[SECOND] !== 0 || a2[MILLISECOND] !== 0) ? HOUR : a2[MINUTE] < 0 || a2[MINUTE] > 59 ? MINUTE : a2[SECOND] < 0 || a2[SECOND] > 59 ? SECOND : a2[MILLISECOND] < 0 || a2[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m2)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m2)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m2)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m2).overflow = overflow;
        }
        return m2;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i2, l2, string = config._i, match5 = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match5) {
          getParsingFlags(config).iso = true;
          for (i2 = 0, l2 = isoDatesLen; i2 < l2; i2++) {
            if (isoDates[i2][1].exec(match5[1])) {
              dateFormat = isoDates[i2][0];
              allowTime = isoDates[i2][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match5[3]) {
            for (i2 = 0, l2 = isoTimesLen; i2 < l2; i2++) {
              if (isoTimes[i2][1].exec(match5[3])) {
                timeFormat = (match5[2] || " ") + isoTimes[i2][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match5[4]) {
            if (tzRegex.exec(match5[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s2) {
        return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m2 = hm % 100, h6 = (hm - m2) / 100;
          return h6 * 60 + m2;
        }
      }
      function configFromRFC2822(config) {
        var match5 = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match5) {
          parsedArray = extractFromRFC2822Strings(
            match5[4],
            match5[3],
            match5[2],
            match5[5],
            match5[6],
            match5[7]
          );
          if (!checkWeekday(match5[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match5[8], match5[9], match5[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = /* @__PURE__ */ new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config) {
          config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
        }
      );
      function defaults3(a2, b2, c2) {
        if (a2 != null) {
          return a2;
        }
        if (b2 != null) {
          return b2;
        }
        return c2;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i2, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults3(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i2 = 0; i2 < 3 && config._a[i2] == null; ++i2) {
          config._a[i2] = input[i2] = currentDate[i2];
        }
        for (; i2 < 7; i2++) {
          config._a[i2] = input[i2] = config._a[i2] == null ? i2 === 2 ? 1 : 0 : config._a[i2];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w2, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w2 = config._w;
        if (w2.GG != null || w2.W != null || w2.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults3(
            w2.GG,
            config._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week = defaults3(w2.W, 1);
          weekday = defaults3(w2.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults3(w2.gg, config._a[YEAR], curWeek.year);
          week = defaults3(w2.w, curWeek.week);
          if (w2.d != null) {
            weekday = w2.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w2.e != null) {
            weekday = w2.e + dow;
            if (w2.e < 0 || w2.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i2, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i2 = 0; i2 < tokenLen; i2++) {
          token2 = tokens2[i2];
          parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(
              string.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale3, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale3.meridiemHour != null) {
          return locale3.meridiemHour(hour, meridiem2);
        } else if (locale3.isPM != null) {
          isPm = locale3.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i2, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = /* @__PURE__ */ new Date(NaN);
          return;
        }
        for (i2 = 0; i2 < configfLen; i2++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i2];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i2 = normalizeObjectUnits(config._i), dayOrDate = i2.day === void 0 ? i2.date : i2.day;
        config._a = map3(
          [i2.year, i2.month, dayOrDate, i2.hour, i2.minute, i2.second, i2.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment3(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format2 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment3(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray2(format2)) {
          configFromStringAndArray(config);
        } else if (format2) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray2(input)) {
          config._a = map3(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject2(input)) {
          configFromObject(config);
        } else if (isNumber2(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format2, locale3, strict, isUTC) {
        var c2 = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale3 === true || locale3 === false) {
          strict = locale3;
          locale3 = void 0;
        }
        if (isObject2(input) && isObjectEmpty(input) || isArray2(input) && input.length === 0) {
          input = void 0;
        }
        c2._isAMomentObject = true;
        c2._useUTC = c2._isUTC = isUTC;
        c2._l = locale3;
        c2._i = input;
        c2._f = format2;
        c2._strict = strict;
        return createFromConfig(c2);
      }
      function createLocal(input, format2, locale3, strict) {
        return createLocalOrUTC(input, format2, locale3, strict, false);
      }
      var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn2, moments) {
        var res, i2;
        if (moments.length === 1 && isArray2(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i2 = 1; i2 < moments.length; ++i2) {
          if (!moments[i2].isValid() || moments[i2][fn2](res)) {
            res = moments[i2];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now2 = function() {
        return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m2) {
        var key, unitHasDecimal = false, i2, orderLen = ordering.length;
        for (key in m2) {
          if (hasOwnProp(m2, key) && !(indexOf.call(ordering, key) !== -1 && (m2[key] == null || !isNaN(m2[key])))) {
            return false;
          }
        }
        for (i2 = 0; i2 < orderLen; ++i2) {
          if (m2[ordering[i2]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m2[ordering[i2]]) !== toInt(m2[ordering[i2]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
        minutes2 * 6e4 + // 1000 * 60
        hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i2;
        for (i2 = 0; i2 < len; i2++) {
          if (dontConvert && array1[i2] !== array2[i2] || !dontConvert && toInt(array1[i2]) !== toInt(array2[i2])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign3 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign3 = "-";
          }
          return sign3 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m2) {
        return -Math.round(m2._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset2, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c2 = {}, other;
        copyConfig(c2, this);
        c2 = prepareConfig(c2);
        if (c2._a) {
          other = c2._isUTC ? createUTC(c2._a) : createLocal(c2._a);
          this._isDSTShifted = this.isValid() && compareArrays(c2._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match5 = null, sign3, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber2(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match5 = aspNetRegex.exec(input)) {
          sign3 = match5[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match5[DATE]) * sign3,
            h: toInt(match5[HOUR]) * sign3,
            m: toInt(match5[MINUTE]) * sign3,
            s: toInt(match5[SECOND]) * sign3,
            ms: toInt(absRound(match5[MILLISECOND] * 1e3)) * sign3
            // the millisecond decimal point is included in the match
          };
        } else if (match5 = isoRegex.exec(input)) {
          sign3 = match5[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match5[2], sign3),
            M: parseIso(match5[3], sign3),
            w: parseIso(match5[4], sign3),
            d: parseIso(match5[5], sign3),
            h: parseIso(match5[6], sign3),
            m: parseIso(match5[7], sign3),
            s: parseIso(match5[8], sign3)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign3) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign3;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name,
              "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber2(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i2, property, propertyLen = properties.length;
        for (i2 = 0; i2 < propertyLen; i2 += 1) {
          property = properties[i2];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray2(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber2(item) && isString(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i2, property;
        for (i2 = 0; i2 < properties.length; i2 += 1) {
          property = properties[i2];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now3) {
        var diff2 = myMoment.diff(now3, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now3 = time || createLocal(), sod = cloneWithOffset(now3, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction2(formats[format2]) ? formats[format2].call(this, now3) : formats[format2]);
        return this.format(
          output || this.localeData().calendar(format2, this, createLocal(now3))
        );
      }
      function clone3() {
        return new Moment3(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from3, to3, units, inclusivity) {
        var localFrom = isMoment(from3) ? from3 : createLocal(from3), localTo = isMoment(to3) ? to3 : createLocal(to3);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          // 1000
          case "minute":
            output = (this - that) / 6e4;
            break;
          // 1000 * 60
          case "hour":
            output = (this - that) / 36e5;
            break;
          // 1000 * 60 * 60
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          // 1000 * 60 * 60 * 24, negate dst
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          // 1000 * 60 * 60 * 24 * 7, negate dst
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a2, b2) {
        if (a2.date() < b2.date()) {
          return -monthDiff(b2, a2);
        }
        var wholeMonthDiff = (b2.year() - a2.year()) * 12 + (b2.month() - a2.month()), anchor = a2.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b2 - anchor < 0) {
          anchor2 = a2.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b2 - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a2.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b2 - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m2 = utc ? this.clone().utc() : this;
        if (m2.year() < 0 || m2.year() > 9999) {
          return formatMoment(
            m2,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction2(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m2, "Z"));
          }
        }
        return formatMoment(
          m2,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from2(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to2(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale2(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y2, m2, d2) {
        if (y2 < 100 && y2 >= 0) {
          return new Date(y2 + 400, m2, d2) - MS_PER_400_YEARS;
        } else {
          return new Date(y2, m2, d2).valueOf();
        }
      }
      function utcStartOfDate(y2, m2, d2) {
        if (y2 < 100 && y2 >= 0) {
          return Date.UTC(y2 + 400, m2, d2) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y2, m2, d2);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray() {
        var m2 = this;
        return [
          m2.year(),
          m2.month(),
          m2.date(),
          m2.hour(),
          m2.minute(),
          m2.second(),
          m2.millisecond()
        ];
      }
      function toObject() {
        var m2 = this;
        return {
          years: m2.year(),
          months: m2.month(),
          date: m2.date(),
          hours: m2.hours(),
          minutes: m2.minutes(),
          seconds: m2.seconds(),
          milliseconds: m2.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(
        ["N", "NN", "NNN", "NNNN", "NNNNN"],
        function(input, array, config, token2) {
          var era = config._locale.erasParse(input, token2, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        }
      );
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match5;
        if (config._locale._eraYearOrdinalRegex) {
          match5 = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match5);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m2, format2) {
        var i2, l2, date, eras = this._eras || getLocale("en")._eras;
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          switch (typeof eras[i2].since) {
            case "string":
              date = hooks(eras[i2].since).startOf("day");
              eras[i2].since = date.valueOf();
              break;
          }
          switch (typeof eras[i2].until) {
            case "undefined":
              eras[i2].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i2].until).startOf("day").valueOf();
              eras[i2].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format2, strict) {
        var i2, l2, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          name = eras[i2].name.toUpperCase();
          abbr = eras[i2].abbr.toUpperCase();
          narrow = eras[i2].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i2];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i2];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i2];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i2];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i2, l2, val, eras = this.localeData().eras();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until) {
            return eras[i2].name;
          }
          if (eras[i2].until <= val && val <= eras[i2].since) {
            return eras[i2].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i2, l2, val, eras = this.localeData().eras();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until) {
            return eras[i2].narrow;
          }
          if (eras[i2].until <= val && val <= eras[i2].since) {
            return eras[i2].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i2, l2, val, eras = this.localeData().eras();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until) {
            return eras[i2].abbr;
          }
          if (eras[i2].until <= val && val <= eras[i2].since) {
            return eras[i2].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i2, l2, dir, val, eras = this.localeData().eras();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          dir = eras[i2].since <= eras[i2].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until || eras[i2].until <= val && val <= eras[i2].since) {
            return (this.year() - hooks(eras[i2].since).year()) * dir + eras[i2].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale3) {
        return locale3.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale3) {
        return locale3.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale3) {
        return locale3.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale3) {
        return locale3._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i2, l2, erasName, erasAbbr, erasNarrow, eras = this.eras();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          erasName = regexEscape(eras[i2].name);
          erasAbbr = regexEscape(eras[i2].abbr);
          erasNarrow = regexEscape(eras[i2].narrow);
          namePieces.push(erasName);
          abbrPieces.push(erasAbbr);
          narrowPieces.push(erasNarrow);
          mixedPieces.push(erasName);
          mixedPieces.push(erasAbbr);
          mixedPieces.push(erasNarrow);
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(
        ["gggg", "ggggg", "GGGG", "GGGGG"],
        function(input, week, config, token2) {
          week[token2.substr(0, 2)] = toInt(input);
        }
      );
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday() + this.localeData()._week.dow,
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addRegexToken("D", match1to2, match1to2NoLeadingZero);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale3) {
        return isStrict ? locale3._dayOfMonthOrdinalParse || locale3._ordinalParse : locale3._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addRegexToken("m", match1to2, match1to2HasZero);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addRegexToken("s", match1to2, match1to2HasZero);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment3.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone3;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from2;
      proto.fromNow = fromNow;
      proto.to = to2;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale2;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string) {
        return string;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set2;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index, field, setter) {
        var locale3 = getLocale(), utc = createUTC().set(setter, index);
        return locale3[field](utc, format2);
      }
      function listMonthsImpl(format2, index, field) {
        if (isNumber2(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index != null) {
          return get$1(format2, index, field, "month");
        }
        var i2, out = [];
        for (i2 = 0; i2 < 12; i2++) {
          out[i2] = get$1(format2, i2, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format2, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber2(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index = format2;
          localeSorted = false;
          if (isNumber2(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale3 = getLocale(), shift = localeSorted ? locale3._week.dow : 0, i2, out = [];
        if (index != null) {
          return get$1(format2, (index + shift) % 7, field, "day");
        }
        for (i2 = 0; i2 < 7; i2++) {
          out[i2] = get$1(format2, (i2 + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format2, index) {
        return listMonthsImpl(format2, index, "months");
      }
      function listMonthsShort(format2, index) {
        return listMonthsImpl(format2, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b2 = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b2 === 1 ? "st" : b2 === 2 ? "nd" : b2 === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale
      );
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            // Math.floor prevents floating point math errors here
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y"), valueOf$1 = asMilliseconds;
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round2 = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale3) {
        return locale3.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale3) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round2(duration.as("s")), minutes2 = round2(duration.as("m")), hours2 = round2(duration.as("h")), days2 = round2(duration.as("d")), months2 = round2(duration.as("M")), weeks2 = round2(duration.as("w")), years2 = round2(duration.as("y")), a2 = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a2 = a2 || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a2 = a2 || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a2[2] = withoutSuffix;
        a2[3] = +posNegDuration > 0;
        a2[4] = locale3;
        return substituteTimeAgo.apply(null, a2);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round2;
        }
        if (typeof roundingFunction === "function") {
          round2 = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale3, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale3 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale3);
        if (withSuffix) {
          output = locale3.pastFuture(+this, output);
        }
        return locale3.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign2(x2) {
        return (x2 > 0) - (x2 < 0) || +x2;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign2(this._months) !== sign2(total) ? "-" : "";
        daysSign = sign2(this._days) !== sign2(total) ? "-" : "";
        hmsSign = sign2(this._milliseconds) !== sign2(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale2;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.30.1";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now2;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      return hooks;
    });
  }
});

// node_modules/.pnpm/pagerank.js@1.0.2/node_modules/pagerank.js/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/pagerank.js@1.0.2/node_modules/pagerank.js/lib/index.js"(exports, module2) {
    "use strict";
    function forOwn(object, callback2) {
      if (typeof object === "object" && typeof callback2 === "function") {
        for (var key in object) {
          if (object.hasOwnProperty(key) === true) {
            if (callback2(key, object[key]) === false) {
              break;
            }
          }
        }
      }
    }
    module2.exports = function() {
      var self = {
        count: 0,
        edges: {},
        nodes: {}
      };
      self.link = function(source, target, weight) {
        if (isFinite(weight) !== true || weight === null) {
          weight = 1;
        }
        weight = parseFloat(weight);
        if (self.nodes.hasOwnProperty(source) !== true) {
          self.count++;
          self.nodes[source] = {
            weight: 0,
            outbound: 0
          };
        }
        self.nodes[source].outbound += weight;
        if (self.nodes.hasOwnProperty(target) !== true) {
          self.count++;
          self.nodes[target] = {
            weight: 0,
            outbound: 0
          };
        }
        if (self.edges.hasOwnProperty(source) !== true) {
          self.edges[source] = {};
        }
        if (self.edges[source].hasOwnProperty(target) !== true) {
          self.edges[source][target] = 0;
        }
        self.edges[source][target] += weight;
      };
      self.rank = function(alpha2, epsilon, callback2) {
        var delta = 1, inverse = 1 / self.count;
        forOwn(self.edges, function(source) {
          if (self.nodes[source].outbound > 0) {
            forOwn(self.edges[source], function(target) {
              self.edges[source][target] /= self.nodes[source].outbound;
            });
          }
        });
        forOwn(self.nodes, function(key) {
          self.nodes[key].weight = inverse;
        });
        while (delta > epsilon) {
          var leak = 0, nodes = {};
          forOwn(self.nodes, function(key, value) {
            nodes[key] = value.weight;
            if (value.outbound === 0) {
              leak += value.weight;
            }
            self.nodes[key].weight = 0;
          });
          leak *= alpha2;
          forOwn(self.nodes, function(source) {
            forOwn(self.edges[source], function(target, weight) {
              self.nodes[target].weight += alpha2 * nodes[source] * weight;
            });
            self.nodes[source].weight += (1 - alpha2) * inverse + leak * inverse;
          });
          delta = 0;
          forOwn(self.nodes, function(key, value) {
            delta += Math.abs(value.weight - nodes[key]);
          });
        }
        forOwn(self.nodes, function(key) {
          return callback2(key, self.nodes[key].weight);
        });
      };
      self.reset = function() {
        self.count = 0;
        self.edges = {};
        self.nodes = {};
      };
      return self;
    }();
  }
});

// node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a2, b2, str) {
      if (a2 instanceof RegExp) a2 = maybeMatch(a2, str);
      if (b2 instanceof RegExp) b2 = maybeMatch(b2, str);
      var r2 = range(a2, b2, str);
      return r2 && {
        start: r2[0],
        end: r2[1],
        pre: str.slice(0, r2[0]),
        body: str.slice(r2[0] + a2.length, r2[1]),
        post: str.slice(r2[1] + b2.length)
      };
    }
    function maybeMatch(reg, str) {
      var m2 = str.match(reg);
      return m2 ? m2[0] : null;
    }
    balanced.range = range;
    function range(a2, b2, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a2);
      var bi = str.indexOf(b2, ai + 1);
      var i2 = ai;
      if (ai >= 0 && bi > 0) {
        if (a2 === b2) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i2 >= 0 && !result) {
          if (i2 == ai) {
            begs.push(i2);
            ai = str.indexOf(a2, i2 + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b2, i2 + 1);
          }
          i2 = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js"(exports, module2) {
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m2 = balanced("{", "}", str);
      if (!m2)
        return str.split(",");
      var pre = m2.pre;
      var body = m2.body;
      var post = m2.post;
      var p2 = pre.split(",");
      p2[p2.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p2[p2.length - 1] += postParts.shift();
        p2.push.apply(p2, postParts);
      }
      parts.push.apply(parts, p2);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand2(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i2, y2) {
      return i2 <= y2;
    }
    function gte(i2, y2) {
      return i2 >= y2;
    }
    function expand2(str, isTop) {
      var expansions = [];
      var m2 = balanced("{", "}", str);
      if (!m2) return [str];
      var pre = m2.pre;
      var post = m2.post.length ? expand2(m2.post, false) : [""];
      if (/\$$/.test(m2.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m2.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m2.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m2.post.match(/,.*\}/)) {
            str = m2.pre + "{" + m2.body + escClose + m2.post;
            return expand2(str);
          }
          return [str];
        }
        var n2;
        if (isSequence) {
          n2 = m2.body.split(/\.\./);
        } else {
          n2 = parseCommaParts(m2.body);
          if (n2.length === 1) {
            n2 = expand2(n2[0], false).map(embrace);
            if (n2.length === 1) {
              return post.map(function(p2) {
                return m2.pre + n2[0] + p2;
              });
            }
          }
        }
        var N2;
        if (isSequence) {
          var x2 = numeric(n2[0]);
          var y2 = numeric(n2[1]);
          var width = Math.max(n2[0].length, n2[1].length);
          var incr = n2.length == 3 ? Math.abs(numeric(n2[2])) : 1;
          var test = lte;
          var reverse = y2 < x2;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n2.some(isPadded);
          N2 = [];
          for (var i2 = x2; test(i2, y2); i2 += incr) {
            var c2;
            if (isAlphaSequence) {
              c2 = String.fromCharCode(i2);
              if (c2 === "\\")
                c2 = "";
            } else {
              c2 = String(i2);
              if (pad) {
                var need = width - c2.length;
                if (need > 0) {
                  var z2 = new Array(need + 1).join("0");
                  if (i2 < 0)
                    c2 = "-" + z2 + c2.slice(1);
                  else
                    c2 = z2 + c2;
                }
              }
            }
            N2.push(c2);
          }
        } else {
          N2 = [];
          for (var j2 = 0; j2 < n2.length; j2++) {
            N2.push.apply(N2, expand2(n2[j2], false));
          }
        }
        for (var j2 = 0; j2 < N2.length; j2++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N2[j2] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/implementation/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/implementation/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.simpleFormatter = exports.htmlFormatter = exports.escapeRegexString = void 0;
    function escapeRegexString(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    exports.escapeRegexString = escapeRegexString;
    var htmlFormatter = class {
      asking(answer, hint) {
        return `<span style='color:#2196f3'>${!hint ? "[...]" : `[${hint}]`}</span>`;
      }
      showingAnswer(answer, hint) {
        return `<span style='color:#2196f3'>${answer}</span>`;
      }
      hiding(answer, hint) {
        return `${!hint ? "..." : `[${hint}]`} `;
      }
    };
    exports.htmlFormatter = htmlFormatter;
    var simpleFormatter = class {
      asking(answer, hint) {
        return `${!hint ? "[...]" : `[${hint}]`}`;
      }
      showingAnswer(answer, hint) {
        return answer;
      }
      hiding(answer, hint) {
        return `...`;
      }
    };
    exports.simpleFormatter = simpleFormatter;
  }
});

// node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/implementation/ClozeFieldEnum.js
var require_ClozeFieldEnum = __commonJS({
  "node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/implementation/ClozeFieldEnum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClozeFieldEnum = void 0;
    var ClozeFieldEnum;
    (function(ClozeFieldEnum2) {
      ClozeFieldEnum2["seq"] = "seq";
      ClozeFieldEnum2["answer"] = "answer";
      ClozeFieldEnum2["hint"] = "hint";
    })(ClozeFieldEnum || (exports.ClozeFieldEnum = ClozeFieldEnum = {}));
  }
});

// node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/implementation/ClozeRegExp.js
var require_ClozeRegExp = __commonJS({
  "node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/implementation/ClozeRegExp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClozeRegExp = void 0;
    var ClozeFieldEnum_1 = require_ClozeFieldEnum();
    var ClozeRegExp = class {
      constructor(pattern, clozeFieldsOrder, flags) {
        this.regex = new RegExp(pattern, flags);
        this.clozeFieldsOrder = clozeFieldsOrder;
      }
      exec(str) {
        let match2 = this.regex.exec(str);
        if (!match2) {
          return null;
        }
        if (this.clozeFieldsOrder.indexOf(ClozeFieldEnum_1.ClozeFieldEnum.answer) == -1) {
          throw new Error("Cloze text not found in clozeFieldsOrder");
        }
        if (this.clozeFieldsOrder.indexOf(ClozeFieldEnum_1.ClozeFieldEnum.hint) == -1) {
          throw new Error("Cloze hint not found in clozeFieldsOrder");
        }
        if (this.clozeFieldsOrder.indexOf(ClozeFieldEnum_1.ClozeFieldEnum.seq) == -1) {
          match2.seq = null;
        } else {
          match2.seq = match2[this.clozeFieldsOrder.indexOf(ClozeFieldEnum_1.ClozeFieldEnum.seq) + 1];
        }
        match2.raw = match2[0];
        match2.answer = match2[this.clozeFieldsOrder.indexOf(ClozeFieldEnum_1.ClozeFieldEnum.answer) + 1];
        match2.hint = match2[this.clozeFieldsOrder.indexOf(ClozeFieldEnum_1.ClozeFieldEnum.hint) + 1];
        return match2;
      }
      test(str) {
        return this.regex.test(str);
      }
    };
    exports.ClozeRegExp = ClozeRegExp;
  }
});

// node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/implementation/ClozeNote.js
var require_ClozeNote = __commonJS({
  "node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/implementation/ClozeNote.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClozeNote = void 0;
    var ClozeNote = class {
      /**
       * Creates a new ClozeNote instance.
       *
       * @param raw The raw text of the cloze note before processing.
       */
      constructor(raw, patterns) {
        this._raw = raw;
        const { clozeDeletions, numCards } = this.initParsing(raw, patterns);
        this._clozeDeletions = clozeDeletions;
        this._numCards = numCards;
      }
      get raw() {
        return this._raw;
      }
      get numCards() {
        return this._numCards;
      }
    };
    exports.ClozeNote = ClozeNote;
  }
});

// node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/implementation/ClozeNoteClassic.js
var require_ClozeNoteClassic = __commonJS({
  "node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/implementation/ClozeNoteClassic.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClozeNoteClassic = void 0;
    var ClozeNote_1 = require_ClozeNote();
    var utils_1 = require_utils();
    var ClozeTypeEnum_1 = require_ClozeTypeEnum();
    var ClozeNoteClassic = class extends ClozeNote_1.ClozeNote {
      constructor(raw, patterns) {
        super(raw, patterns);
      }
      get clozeType() {
        return ClozeTypeEnum_1.ClozeTypeEnum.CLASSIC;
      }
      initParsing(rawNote, patterns) {
        let clozeDeletions = [];
        let numCards = 0;
        patterns.forEach((pattern) => {
          const regex = pattern.getClozeRegex(ClozeTypeEnum_1.ClozeTypeEnum.CLASSIC);
          let match2;
          while (match2 = regex.exec(rawNote)) {
            if (!match2.seq) {
              break;
            }
            let newCloze = {
              raw: match2.raw,
              answer: match2.answer,
              seq: parseInt(match2.seq),
              hint: match2.hint
            };
            clozeDeletions.push(newCloze);
            if (numCards < newCloze.seq) {
              numCards = newCloze.seq;
            }
          }
        });
        return { clozeDeletions, numCards };
      }
      getCardFront(cardIndex, formatter) {
        if (cardIndex >= this._numCards || cardIndex < 0) {
          throw new Error(`Card ${cardIndex} does not exist`);
        }
        if (!formatter) {
          formatter = new utils_1.simpleFormatter();
        }
        let frontText = this.raw;
        for (const deletion of this._clozeDeletions) {
          if (deletion.seq !== cardIndex + 1) {
            frontText = frontText.replace(deletion.raw, deletion.answer);
            continue;
          }
          frontText = frontText.replace(deletion.raw, formatter.asking(deletion.answer, deletion.hint));
        }
        return frontText;
      }
      getCardBack(cardIndex, formatter) {
        if (cardIndex >= this._numCards || cardIndex < 0) {
          throw new Error(`Card ${cardIndex} does not exist`);
        }
        if (!formatter) {
          formatter = new utils_1.simpleFormatter();
        }
        let backText = this.raw;
        for (const deletion of this._clozeDeletions) {
          if (deletion.seq === cardIndex + 1) {
            backText = backText.replace(deletion.raw, formatter.showingAnswer(deletion.answer, deletion.hint));
          } else {
            backText = backText.replace(deletion.raw, deletion.answer);
          }
        }
        return backText;
      }
    };
    exports.ClozeNoteClassic = ClozeNoteClassic;
  }
});

// node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/implementation/ClozeNoteOL.js
var require_ClozeNoteOL = __commonJS({
  "node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/implementation/ClozeNoteOL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClozeNoteOL = void 0;
    var ClozeNote_1 = require_ClozeNote();
    var utils_1 = require_utils();
    var ClozeTypeEnum_1 = require_ClozeTypeEnum();
    var ClozeNoteOL = class extends ClozeNote_1.ClozeNote {
      constructor(raw, patterns) {
        super(raw, patterns);
      }
      get clozeType() {
        return ClozeTypeEnum_1.ClozeTypeEnum.OVERLAPPING;
      }
      initParsing(rawNote, patterns) {
        let clozeDeletions = [];
        let numCards = 0;
        patterns.forEach((pattern) => {
          const regex = pattern.getClozeRegex(ClozeTypeEnum_1.ClozeTypeEnum.OVERLAPPING);
          let match2;
          while (match2 = regex.exec(rawNote)) {
            if (!match2.seq) {
              break;
            }
            let newCloze = {
              raw: match2.raw,
              answer: match2.answer,
              seq: match2.seq,
              hint: match2.hint
            };
            clozeDeletions.push(newCloze);
            if (numCards < newCloze.seq.length) {
              numCards = newCloze.seq.length;
            }
          }
        });
        return { clozeDeletions, numCards };
      }
      getCardFront(cardIndex, formatter) {
        if (cardIndex >= this._numCards || cardIndex < 0) {
          throw new Error(`Card ${cardIndex} does not exist`);
        }
        if (!formatter) {
          formatter = new utils_1.simpleFormatter();
        }
        let frontText = this.raw;
        for (const deletion of this._clozeDeletions) {
          let clozeAction = "s";
          if (cardIndex < deletion.seq.length) {
            clozeAction = deletion.seq[cardIndex];
          }
          switch (clozeAction) {
            case "a":
              frontText = frontText.replace(deletion.raw, formatter.asking(deletion.answer, deletion.hint));
              break;
            case "h":
              frontText = frontText.replace(deletion.raw, formatter.hiding(deletion.answer, deletion.hint));
              break;
            case "s":
              frontText = frontText.replace(deletion.raw, deletion.answer);
              break;
          }
        }
        return frontText;
      }
      getCardBack(cardIndex, formatter) {
        if (cardIndex >= this._numCards || cardIndex < 0) {
          throw new Error(`Card ${cardIndex} does not exist`);
        }
        if (!formatter) {
          formatter = new utils_1.simpleFormatter();
        }
        let backText = this.raw;
        for (const deletion of this._clozeDeletions) {
          let clozeAction = "s";
          if (cardIndex < deletion.seq.length) {
            clozeAction = deletion.seq[cardIndex];
          }
          switch (clozeAction) {
            case "a":
              backText = backText.replace(deletion.raw, formatter.showingAnswer(deletion.answer, deletion.hint));
              break;
            case "h":
              backText = backText.replace(deletion.raw, formatter.hiding(deletion.answer, deletion.hint));
              break;
            case "s":
              backText = backText.replace(deletion.raw, deletion.answer);
              break;
          }
        }
        return backText;
      }
    };
    exports.ClozeNoteOL = ClozeNoteOL;
  }
});

// node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/implementation/ClozeNoteSimple.js
var require_ClozeNoteSimple = __commonJS({
  "node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/implementation/ClozeNoteSimple.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClozeNoteSimple = void 0;
    var ClozeNote_1 = require_ClozeNote();
    var ClozeTypeEnum_1 = require_ClozeTypeEnum();
    var utils_1 = require_utils();
    var ClozeNoteSimple = class extends ClozeNote_1.ClozeNote {
      constructor(raw, patterns) {
        super(raw, patterns);
      }
      get clozeType() {
        return ClozeTypeEnum_1.ClozeTypeEnum.SIMPLE;
      }
      initParsing(rawNote, patterns) {
        let clozeDeletions = [];
        let numCards = 0;
        patterns.forEach((pattern) => {
          const regex = pattern.getClozeRegex(ClozeTypeEnum_1.ClozeTypeEnum.SIMPLE);
          let match2;
          while (match2 = regex.exec(rawNote)) {
            numCards++;
            let newCloze = {
              raw: match2.raw,
              answer: match2.answer,
              seq: numCards,
              hint: match2.hint
            };
            clozeDeletions.push(newCloze);
          }
        });
        return { clozeDeletions, numCards };
      }
      getCardFront(cardIndex, formatter) {
        if (cardIndex >= this._numCards || cardIndex < 0) {
          throw new Error(`Card ${cardIndex} does not exist`);
        }
        if (!formatter) {
          formatter = new utils_1.simpleFormatter();
        }
        let frontText = this.raw;
        for (const deletion of this._clozeDeletions) {
          if (deletion.seq !== cardIndex + 1) {
            frontText = frontText.replace(deletion.raw, deletion.answer);
            continue;
          }
          frontText = frontText.replace(deletion.raw, formatter.asking(deletion.answer, deletion.hint));
        }
        return frontText;
      }
      getCardBack(cardIndex, formatter) {
        if (cardIndex >= this._numCards || cardIndex < 0) {
          throw new Error(`Card ${cardIndex} does not exist`);
        }
        if (!formatter) {
          formatter = new utils_1.simpleFormatter();
        }
        let backText = this.raw;
        for (const deletion of this._clozeDeletions) {
          if (deletion.seq === cardIndex + 1) {
            backText = backText.replace(deletion.raw, formatter.showingAnswer(deletion.answer, deletion.hint));
          } else {
            backText = backText.replace(deletion.raw, deletion.answer);
          }
        }
        return backText;
      }
    };
    exports.ClozeNoteSimple = ClozeNoteSimple;
  }
});

// node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/implementation/ClozeTypeEnum.js
var require_ClozeTypeEnum = __commonJS({
  "node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/implementation/ClozeTypeEnum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoteClassByClozeType = exports.ClozeTypesPriority = exports.ClozeTypeEnum = void 0;
    var ClozeNoteClassic_1 = require_ClozeNoteClassic();
    var ClozeNoteOL_1 = require_ClozeNoteOL();
    var ClozeNoteSimple_1 = require_ClozeNoteSimple();
    var ClozeTypeEnum;
    (function(ClozeTypeEnum2) {
      ClozeTypeEnum2["CLASSIC"] = "classic";
      ClozeTypeEnum2["OVERLAPPING"] = "overlapping";
      ClozeTypeEnum2["SIMPLE"] = "simple";
    })(ClozeTypeEnum || (exports.ClozeTypeEnum = ClozeTypeEnum = {}));
    exports.ClozeTypesPriority = [
      ClozeTypeEnum.CLASSIC,
      ClozeTypeEnum.OVERLAPPING,
      ClozeTypeEnum.SIMPLE
      // Cloze Simple must be the last one because it is a subset of Cloze Classic and Cloze Overlapping
    ];
    exports.NoteClassByClozeType = {
      [ClozeTypeEnum.CLASSIC]: ClozeNoteClassic_1.ClozeNoteClassic,
      [ClozeTypeEnum.OVERLAPPING]: ClozeNoteOL_1.ClozeNoteOL,
      [ClozeTypeEnum.SIMPLE]: ClozeNoteSimple_1.ClozeNoteSimple
    };
  }
});

// node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/implementation/ClozePattern.js
var require_ClozePattern = __commonJS({
  "node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/implementation/ClozePattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClozePattern = void 0;
    var utils_1 = require_utils();
    var ClozeRegExp_1 = require_ClozeRegExp();
    var ClozeFieldEnum_1 = require_ClozeFieldEnum();
    var ClozeTypeEnum_1 = require_ClozeTypeEnum();
    var numPatternRegex = new RegExp(`\\[(?:(?:\\\\\\])?[^\\]]?)+?\\d+(?:(?:\\\\\\])?[^\\]]?)+?\\]`);
    var hintPatternRegex = new RegExp(`\\[(?:(?:\\\\\\])?[^\\]]?)+?hint(?:(?:\\\\\\])?[^\\]]?)+?\\]`);
    var answerKeyword = `answer`;
    var ClozePattern = class _ClozePattern {
      constructor(raw) {
        this.clozeRegexByType = {
          [ClozeTypeEnum_1.ClozeTypeEnum.CLASSIC]: void 0,
          [ClozeTypeEnum_1.ClozeTypeEnum.OVERLAPPING]: void 0,
          [ClozeTypeEnum_1.ClozeTypeEnum.SIMPLE]: void 0
        };
        this.generateClozeRegexByType = {
          [ClozeTypeEnum_1.ClozeTypeEnum.CLASSIC]: this.generateClozeClassicRegex,
          [ClozeTypeEnum_1.ClozeTypeEnum.OVERLAPPING]: this.generateClozeOLRegex,
          [ClozeTypeEnum_1.ClozeTypeEnum.SIMPLE]: this.generateClozeSimpleRegex
        };
        this._raw = raw;
        let _numMatch = numPatternRegex.exec(raw);
        let _hintMatch = hintPatternRegex.exec(raw);
        if (!_numMatch) {
          throw new Error("No cloze number pattern found");
        }
        if (!_hintMatch) {
          throw new Error("No cloze hint pattern found");
        }
        if (raw.indexOf(answerKeyword) == -1) {
          throw new Error(`No answer keyword (${answerKeyword}) found in the pattern.`);
        }
        this.numPattern = _numMatch;
        this.hintPattern = _hintMatch;
        this.numRegex = _ClozePattern.processPattern(_numMatch[0], (text) => text.replace(/\d+/g, "(\\d+)"));
        this.seqRegex = _ClozePattern.processPattern(_numMatch[0], (text) => text.replace(/\d+/g, "([ash]+)"));
        this.hintRegex = _ClozePattern.processPattern(_hintMatch[0], (text) => text.replace(/hint/g, "(.+?)"));
        this.hintRegex = "(?:" + this.hintRegex + ")?";
        this._clozeFieldOrder = [ClozeFieldEnum_1.ClozeFieldEnum.answer, ClozeFieldEnum_1.ClozeFieldEnum.hint, ClozeFieldEnum_1.ClozeFieldEnum.seq];
        let positions2 = {
          [ClozeFieldEnum_1.ClozeFieldEnum.answer]: raw.indexOf(answerKeyword),
          [ClozeFieldEnum_1.ClozeFieldEnum.hint]: this.hintPattern.index,
          [ClozeFieldEnum_1.ClozeFieldEnum.seq]: this.numPattern.index
        };
        this._clozeFieldOrder.sort((a2, b2) => positions2[a2] - positions2[b2]);
      }
      static processPattern(text, rplc) {
        let ans = text.substring(1, text.length - 1);
        ans = ans.replace(/\\\[/g, "[").replace(/\\]/g, "]");
        ans = (0, utils_1.escapeRegexString)(ans);
        ans = rplc(ans);
        return ans;
      }
      generateClozeRegexStr(first, firstReplace, second, secondReplace) {
        let begin = this._raw.slice(0, first.index);
        let middle = this._raw.slice(first.index + first[0].length, second.index);
        let ending = this._raw.slice(second.index + second[0].length, this._raw.length);
        let regexStr = (0, utils_1.escapeRegexString)(begin) + firstReplace + (0, utils_1.escapeRegexString)(middle) + secondReplace + (0, utils_1.escapeRegexString)(ending);
        regexStr = regexStr.replace(answerKeyword, "(.+?)");
        return regexStr;
      }
      generateClozeSimpleRegex(pattern) {
        let regexStr;
        if (pattern.numPattern.index < pattern.hintPattern.index) {
          regexStr = pattern.generateClozeRegexStr(pattern.numPattern, "", pattern.hintPattern, pattern.hintRegex);
        } else {
          regexStr = pattern.generateClozeRegexStr(pattern.hintPattern, pattern.hintRegex, pattern.numPattern, "");
        }
        let clozeFieldsOrderWithoutSeq = pattern._clozeFieldOrder.filter((x2) => x2 != ClozeFieldEnum_1.ClozeFieldEnum.seq);
        return new ClozeRegExp_1.ClozeRegExp(regexStr, clozeFieldsOrderWithoutSeq, "g");
      }
      generateClozeClassicRegex(pattern) {
        let regexStr;
        if (pattern.numPattern.index < pattern.hintPattern.index) {
          regexStr = pattern.generateClozeRegexStr(pattern.numPattern, pattern.numRegex, pattern.hintPattern, pattern.hintRegex);
        } else {
          regexStr = pattern.generateClozeRegexStr(pattern.hintPattern, pattern.hintRegex, pattern.numPattern, pattern.numRegex);
        }
        return new ClozeRegExp_1.ClozeRegExp(regexStr, pattern._clozeFieldOrder, "g");
      }
      generateClozeOLRegex(pattern) {
        let regexStr;
        if (pattern.numPattern.index < pattern.hintPattern.index) {
          regexStr = pattern.generateClozeRegexStr(pattern.numPattern, pattern.seqRegex, pattern.hintPattern, pattern.hintRegex);
        } else {
          regexStr = pattern.generateClozeRegexStr(pattern.hintPattern, pattern.hintRegex, pattern.numPattern, pattern.seqRegex);
        }
        return new ClozeRegExp_1.ClozeRegExp(regexStr, pattern._clozeFieldOrder, "g");
      }
      get clozeFieldsOrder() {
        return this._clozeFieldOrder;
      }
      getClozeRegex(clozeType) {
        let clozeRegex = this.clozeRegexByType[clozeType];
        if (clozeRegex != void 0) {
          clozeRegex.regex.lastIndex = 0;
          return clozeRegex;
        }
        clozeRegex = this.generateClozeRegexByType[clozeType](this);
        this.clozeRegexByType[clozeType] = clozeRegex;
        return clozeRegex;
      }
      hasClozeType(text, clozeType) {
        for (const priorityType of ClozeTypeEnum_1.ClozeTypesPriority) {
          if (this.getClozeRegex(priorityType).test(text)) {
            return clozeType == priorityType;
          }
        }
        return false;
      }
      getClozeTypes(text) {
        const clozeTypes = [];
        for (const priorityType of ClozeTypeEnum_1.ClozeTypesPriority) {
          if (this.getClozeRegex(priorityType).test(text)) {
            clozeTypes.push(priorityType);
          }
        }
        return clozeTypes;
      }
      getMainClozeType(text) {
        for (const priorityType of ClozeTypeEnum_1.ClozeTypesPriority) {
          if (this.getClozeRegex(priorityType).test(text)) {
            return priorityType;
          }
        }
        return null;
      }
    };
    exports.ClozePattern = ClozePattern;
  }
});

// node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/implementation/ClozeCrafter.js
var require_ClozeCrafter = __commonJS({
  "node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/implementation/ClozeCrafter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClozeCrafter = void 0;
    var ClozePattern_1 = require_ClozePattern();
    var ClozeTypeEnum_1 = require_ClozeTypeEnum();
    var ClozeCrafter3 = class {
      constructor(patterns) {
        this.patterns = patterns.map((patternStr) => new ClozePattern_1.ClozePattern(patternStr));
      }
      createClozeNote(text) {
        const noteType = this.getNoteType(text);
        if (noteType === null) {
          return null;
        }
        const selectedClass = ClozeTypeEnum_1.NoteClassByClozeType[noteType];
        const clozeNote = new selectedClass(text, this.patterns);
        return clozeNote;
      }
      getNoteType(text) {
        let noteType = null;
        for (const pattern of this.patterns) {
          const currentType = pattern.getMainClozeType(text);
          if (currentType !== null && (noteType === null || ClozeTypeEnum_1.ClozeTypesPriority.indexOf(currentType) < ClozeTypeEnum_1.ClozeTypesPriority.indexOf(noteType))) {
            noteType = currentType;
          }
        }
        return noteType;
      }
      isClozeNote(text) {
        return this.getNoteType(text) !== null;
      }
    };
    exports.ClozeCrafter = ClozeCrafter3;
  }
});

// node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/clozecraft@0.4.0/node_modules/clozecraft/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClozeTypesPriority = exports.ClozeTypeEnum = exports.ClozeCrafter = void 0;
    var ClozeCrafter_1 = require_ClozeCrafter();
    Object.defineProperty(exports, "ClozeCrafter", { enumerable: true, get: function() {
      return ClozeCrafter_1.ClozeCrafter;
    } });
    var ClozeTypeEnum_1 = require_ClozeTypeEnum();
    Object.defineProperty(exports, "ClozeTypeEnum", { enumerable: true, get: function() {
      return ClozeTypeEnum_1.ClozeTypeEnum;
    } });
    Object.defineProperty(exports, "ClozeTypesPriority", { enumerable: true, get: function() {
      return ClozeTypeEnum_1.ClozeTypesPriority;
    } });
  }
});

// node_modules/.pnpm/vhtml@2.2.0/node_modules/vhtml/dist/vhtml.js
var require_vhtml = __commonJS({
  "node_modules/.pnpm/vhtml@2.2.0/node_modules/vhtml/dist/vhtml.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.vhtml = factory();
    })(exports, function() {
      "use strict";
      var emptyTags = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
      var esc = function esc2(str) {
        return String(str).replace(/[&<>"']/g, function(s2) {
          return "&" + map3[s2] + ";";
        });
      };
      var map3 = { "&": "amp", "<": "lt", ">": "gt", '"': "quot", "'": "apos" };
      var setInnerHTMLAttr = "dangerouslySetInnerHTML";
      var DOMAttributeNames = {
        className: "class",
        htmlFor: "for"
      };
      var sanitized = {};
      function h6(name, attrs) {
        var stack = [], s2 = "";
        attrs = attrs || {};
        for (var i2 = arguments.length; i2-- > 2; ) {
          stack.push(arguments[i2]);
        }
        if (typeof name === "function") {
          attrs.children = stack.reverse();
          return name(attrs);
        }
        if (name) {
          s2 += "<" + name;
          if (attrs) for (var _i in attrs) {
            if (attrs[_i] !== false && attrs[_i] != null && _i !== setInnerHTMLAttr) {
              s2 += " " + (DOMAttributeNames[_i] ? DOMAttributeNames[_i] : esc(_i)) + '="' + esc(attrs[_i]) + '"';
            }
          }
          s2 += ">";
        }
        if (emptyTags.indexOf(name) === -1) {
          if (attrs[setInnerHTMLAttr]) {
            s2 += attrs[setInnerHTMLAttr].__html;
          } else while (stack.length) {
            var child = stack.pop();
            if (child) {
              if (child.pop) {
                for (var _i2 = child.length; _i2--; ) {
                  stack.push(child[_i2]);
                }
              } else {
                s2 += sanitized[child] === true ? child : esc(child);
              }
            }
          }
          s2 += name ? "</" + name + ">" : "";
        }
        sanitized[s2] = true;
        return s2;
      }
      return h6;
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SRPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian15 = require("obsidian");

// src/algorithms/base/repetition-item.ts
var RepetitionItem = class {
  // scheduling
  get hasSchedule() {
    return this.scheduleInfo != null;
  }
  get isNew() {
    return !this.hasSchedule;
  }
  get isDue() {
    return this.hasSchedule && this.scheduleInfo.isDue();
  }
};

// src/algorithms/base/srs-algorithm.ts
var SrsAlgorithm = class _SrsAlgorithm {
  static getInstance() {
    if (!_SrsAlgorithm.instance) {
      throw new Error("there is no SrsAlgorithm instance.");
    }
    return _SrsAlgorithm.instance;
  }
};

// src/algorithms/osr/obsidian-vault-notelink-info-finder.ts
var ObsidianVaultNoteLinkInfoFinder = class {
  constructor(metadataCache) {
    this.metadataCache = metadataCache;
  }
  getResolvedTargetLinksForNotePath(path3) {
    return this.metadataCache.resolvedLinks[path3];
  }
};

// src/algorithms/osr/srs-algorithm-osr.ts
var import_moment2 = __toESM(require_moment());

// src/constants.ts
var SCHEDULING_INFO_REGEX = /^---\r?\n((?:.*\r?\n)*)sr-due: (.+)\r?\nsr-interval: (\d+)\r?\nsr-ease: (\d+)\r?\n((?:.*\r?\n)?)---/;
var YAML_FRONT_MATTER_REGEX = /^---\r?\n((?:.*\r?\n)*?)---/;
var MULTI_SCHEDULING_EXTRACTOR = /!([\d-]+),(\d+),(\d+)/gm;
var LEGACY_SCHEDULING_EXTRACTOR = /<!--SR:([\d-]+),(\d+),(\d+)-->/gm;
var OBSIDIAN_TAG_AT_STARTOFLINE_REGEX = /^#[^\s#]+/gi;
var OBSIDIAN_BLOCK_ID_ENDOFLINE_REGEX = / (\^[a-zA-Z0-9-]+)$/;
var PREFERRED_DATE_FORMAT = "YYYY-MM-DD";
var ALLOWED_DATE_FORMATS = [PREFERRED_DATE_FORMAT, "DD-MM-YYYY", "ddd MMM DD YYYY"];
var IMAGE_FORMATS = [
  "jpg",
  "jpeg",
  "gif",
  "png",
  "svg",
  "webp",
  "apng",
  "avif",
  "jfif",
  "pjpeg",
  "pjp",
  "bmp"
];
var AUDIO_FORMATS = ["mp3", "webm", "m4a", "wav", "ogg"];
var VIDEO_FORMATS = ["mp4", "mkv", "avi", "mov"];
var COLLAPSE_ICON = '<svg viewBox="0 0 100 100" width="8" height="8" class="svg-icon right-triangle"><path fill="currentColor" stroke="currentColor" d="M94.9,20.8c-1.4-2.5-4.1-4.1-7.1-4.1H12.2c-3,0-5.7,1.6-7.1,4.1c-1.3,2.4-1.2,5.2,0.2,7.6L43.1,88c1.5,2.3,4,3.7,6.9,3.7 s5.4-1.4,6.9-3.7l37.8-59.6C96.1,26,96.2,23.2,94.9,20.8L94.9,20.8z"></path></svg>';
var TICKS_PER_DAY = 24 * 3600 * 1e3;
var SR_HTML_COMMENT_BEGIN = "<!--SR:";
var SR_HTML_COMMENT_END = "-->";
var SR_TAB_VIEW = "spaced-repetition-tab-view";

// src/lang/helpers.ts
var import_obsidian = require("obsidian");

// src/lang/locale/af.ts
var af_default = {};

// src/lang/locale/ar.ts
var ar_default = {
  // flashcard-modal.tsx
  DECKS: "\u0627\u0644\u0631\u064F\u0632\u0645\u064E\u0627\u062A",
  DUE_CARDS: "\u0628\u0637\u0627\u0642\u0627\u062A \u0645\u064F\u0633\u062A\u062D\u0642\u0629",
  NEW_CARDS: "\u0628\u0637\u0627\u0642\u0627\u062A \u062C\u062F\u064A\u062F\u0629",
  TOTAL_CARDS: "\u0625\u062C\u0645\u0627\u0644\u064A \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A",
  BACK: "\u0631\u062C\u0648\u0639",
  SKIP: "Skip",
  EDIT_CARD: "\u062A\u0639\u062F\u064A\u0644 \u0627\u0644\u0628\u0637\u0627\u0642\u0629",
  RESET_CARD_PROGRESS: "\u0625\u0639\u0627\u062F\u0629 \u062A\u0639\u064A\u064A\u0646 \u062A\u0642\u062F\u0651\u064F\u0645\u0652 \u0627\u0644\u0628\u0637\u0627\u0642\u0629",
  HARD: "\u0635\u0639\u0628",
  GOOD: "\u062C\u064A\u062F",
  EASY: "\u0633\u0647\u0644",
  SHOW_ANSWER: "\u0623\u0638\u0647\u0650\u0631 \u0627\u0644\u0625\u062C\u0627\u0628\u0629",
  CARD_PROGRESS_RESET: ".\u062A\u0645\u0651\u064E\u062A \u0625\u0639\u0627\u062F\u0629 \u062A\u0639\u064A\u064A\u0646 \u062A\u0642\u062F\u0651\u064F\u0645 \u0627\u0644\u0628\u0637\u0627\u0642\u0629",
  SAVE: "\u062D\u0641\u0638",
  CANCEL: "\u0625\u0644\u063A\u0627\u0621",
  NO_INPUT: ".\u0644\u0645 \u064A\u062A\u0650\u0645 \u062A\u0642\u062F\u064A\u0645 \u0623\u064A \u0645\u064F\u062F\u062E\u0644\u0627\u062A",
  CURRENT_EASE_HELP_TEXT: ":\u0627\u0644\u0633\u0647\u0648\u0644\u0629 \u0627\u0644\u062D\u0627\u0644\u064A\u0629",
  CURRENT_INTERVAL_HELP_TEXT: ":\u0627\u0644\u0641\u0627\u0635\u0644 \u0627\u0644\u0632\u0645\u0646\u064A \u0627\u0644\u062D\u0627\u0644\u064A",
  CARD_GENERATED_FROM: "${notePath} :\u062A\u0645 \u0625\u0646\u0634\u0627\u0624\u0647\u0627 \u0645\u0646",
  // main.ts
  OPEN_NOTE_FOR_REVIEW: "\u0627\u0641\u062A\u062D \u0627\u0644\u0645\u0644\u0627\u062D\u0638\u0629 \u0644\u0644\u0645\u0631\u0627\u062C\u0639\u0629",
  REVIEW_CARDS: "\u0645\u0631\u0627\u062C\u0639\u0629 \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A",
  REVIEW_DIFFICULTY_FILE_MENU: "${difficulty} :\u0645\u0631\u0627\u062C\u0639\u0629",
  REVIEW_NOTE_DIFFICULTY_CMD: "${difficulty} \u0645\u0631\u0627\u062C\u0639\u0629 \u0627\u0644\u0645\u0644\u0627\u062D\u0638\u0629 \u0643\u0640",
  CRAM_ALL_CARDS: "\u062D\u062F\u062F \u0631\u064F\u0632\u0645\u064E\u0629 \u0644\u0644\u062D\u0634\u0631",
  REVIEW_ALL_CARDS: "\u0645\u0631\u0627\u062C\u0639\u0629 \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A \u0645\u0646 \u062C\u0645\u064A\u0639 \u0627\u0644\u0645\u0644\u0627\u062D\u0638\u0627\u062A",
  REVIEW_CARDS_IN_NOTE: "\u0645\u0631\u0627\u062C\u0639\u0629 \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A  \u0645\u0646 \u0647\u0630\u0647 \u0627\u0644\u0645\u0644\u0627\u062D\u0638\u0629",
  CRAM_CARDS_IN_NOTE: "\u0623\u062D\u0634\u0631 \u062C\u0645\u064A\u0639 \u0628\u0637\u0627\u0642\u0627\u062A \u0647\u0630\u0647 \u0627\u0644\u0645\u0644\u0627\u062D\u0638\u0629",
  VIEW_STATS: "\u0639\u0631\u0636 \u0627\u0644\u0625\u062D\u0635\u0627\u0626\u064A\u0627\u062A",
  OPEN_REVIEW_QUEUE_VIEW: "Open Notes Review Queue in sidebar",
  STATUS_BAR: "\u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A \u0627\u0644\u0645\u0633\u062A\u062D\u0642\u0629 ${dueFlashcardsCount},\u0645\u0644\u0627\u062D\u0638\u0627\u062A ${dueNotesCount}:\u0645\u0631\u0627\u062C\u0639\u0629",
  SYNC_TIME_TAKEN: "${t}ms \u0627\u0633\u062A\u063A\u0631\u0627\u0642 \u0627\u0644\u0645\u0632\u0627\u0645\u0646\u0629",
  NOTE_IN_IGNORED_FOLDER: ".\u0627\u0644\u0645\u0644\u0627\u062D\u0638\u0629 \u064A\u062A\u0645 \u062D\u0641\u0638\u0647\u0627 \u0636\u0645\u0646 \u0627\u0644\u0645\u062C\u0644\u062F \u0627\u0644\u0630\u064A \u062A\u0645 \u062A\u062C\u0627\u0647\u0644\u0647 (\u062A\u062D\u0642\u0642 \u0645\u0646 \u0627\u0644\u0625\u0639\u062F\u0627\u062F\u0627\u062A)",
  PLEASE_TAG_NOTE: ".\u064A\u0631\u062C\u0649 \u0648\u0636\u0639 \u0648\u0633\u0645 \u0639\u0644\u0649 \u0627\u0644\u0645\u0644\u0627\u062D\u0638\u0629 \u0628\u0634\u0643\u0644 \u0645\u0646\u0627\u0633\u0628 \u0644\u0644\u0645\u0631\u0627\u062C\u0639\u0629 (\u0641\u064A \u0627\u0644\u0625\u0639\u062F\u0627\u062F\u0627\u062A)",
  RESPONSE_RECEIVED: ".\u0627\u0633\u062A\u064F\u0644\u0645\u062A \u0627\u0644\u0627\u0633\u062A\u062C\u0627\u0628\u0629",
  NO_DECK_EXISTS: "${deckName} \u0644\u0627 \u064A\u0648\u062C\u062F \u0631\u064F\u0632\u0645\u064E\u0629",
  ALL_CAUGHT_UP: "\u{1F606} \u0644\u0642\u062F \u062A\u0645 \u0627\u0644\u0642\u0628\u0636 \u0639\u0644\u064A\u0643\u0645 \u062C\u0645\u064A\u0639\u0627 \u0627\u0644\u0622\u0646",
  // scheduling.ts
  DAYS_STR_IVL: "\u064A\u0648\u0645/\u0623\u064A\u0627\u0645 ${interval}",
  MONTHS_STR_IVL: "\u0634\u0647\u0631/\u0623\u0634\u0647\u0631 ${interval}",
  YEARS_STR_IVL: "\u0633\u0646\u0629/\u0633\u0646\u0648\u0627\u062A ${interval}",
  DAYS_STR_IVL_MOBILE: "\u064A${interval}",
  MONTHS_STR_IVL_MOBILE: "\u0634${interval}",
  YEARS_STR_IVL_MOBILE: "\u0633${interval}",
  // settings.ts
  SETTINGS_HEADER: "Spaced Repetition",
  GROUP_TAGS_FOLDERS: "Tags & Folders",
  GROUP_FLASHCARD_REVIEW: "Flashcard Review",
  GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
  GROUP_DATA_STORAGE: "Storage of Scheduling Data",
  GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
  GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
  GROUP_CONTRIBUTING: "Contributing",
  CHECK_WIKI: '.<a href="${wikiUrl}">wiki</a> \u0644\u0645\u0632\u064A\u062F \u0645\u0646 \u0627\u0644\u0645\u0639\u0644\u0648\u0645\u0627\u062A \u060C \u062A\u062D\u0642\u0642 \u0645\u0646',
  GITHUB_DISCUSSIONS: 'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
  GITHUB_ISSUES: 'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
  GITHUB_SOURCE_CODE: 'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
  CODE_CONTRIBUTION_INFO: '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
  TRANSLATION_CONTRIBUTION_INFO: '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
  FOLDERS_TO_IGNORE: "\u0645\u062C\u0644\u062F\u0627\u062A \u0644\u062A\u062C\u0627\u0647\u0644\u0647\u0627",
  FOLDERS_TO_IGNORE_DESC: "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
  OBSIDIAN_INTEGRATION: "Integration into Obsidian",
  FLASHCARDS: "\u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A",
  FLASHCARD_EASY_LABEL: "\u0646\u0635 \u0627\u0644\u0632\u0631 \u0633\u0647\u0644",
  FLASHCARD_GOOD_LABEL: "\u0646\u0635 \u0627\u0644\u0632\u0631 \u062C\u064A\u062F",
  FLASHCARD_HARD_LABEL: "\u0646\u0635 \u0627\u0644\u0632\u0631 \u0635\u0639\u0628",
  FLASHCARD_EASY_DESC: '"\u062A\u062E\u0635\u064A\u0635 \u0627\u0644\u062A\u0633\u0645\u064A\u0629 \u0644\u0644\u0632\u0631 "\u0633\u0647\u0644',
  FLASHCARD_GOOD_DESC: '"\u062A\u062E\u0635\u064A\u0635 \u0627\u0644\u062A\u0633\u0645\u064A\u0629 \u0644\u0644\u0632\u0631 "\u062C\u064A\u062F',
  FLASHCARD_HARD_DESC: '"\u062A\u062E\u0635\u064A\u0635 \u0627\u0644\u062A\u0633\u0645\u064A\u0629 \u0644\u0644\u0632\u0631 "\u0635\u0639\u0628',
  REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
  REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
  FLASHCARD_TAGS: "\u0648\u064F\u0633\u0648\u0645 \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A",
  FLASHCARD_TAGS_DESC: "#2\u0623\u062F\u062E\u0644 \u0627\u0644\u0648\u064F\u0633\u0648\u0645 \u0645\u0641\u0635\u0648\u0644\u0629 \u0628\u0645\u0633\u0627\u0641\u0627\u062A \u0623\u0648 \u0623\u0633\u0637\u0631 \u062C\u062F\u064A\u062F\u0629 \u060C \u0623\u064A \u0628\u0637\u0627\u0642\u0627\u062A# \u0631\u0632\u0645\u06293# \u0631\u0632\u0645\u0629",
  CONVERT_FOLDERS_TO_DECKS: "\u062A\u062D\u0648\u064A\u0644 \u0627\u0644\u0645\u062C\u0644\u062F\u0627\u062A \u0625\u0644\u0649 \u0645\u0644\u0641\u0627\u062A \u0623\u0635\u0644\u064A\u0629 \u0648 \u0645\u0644\u0641\u0627\u062A \u0627\u0644\u0641\u0631\u0639\u064A\u0629\u061F",
  CONVERT_FOLDERS_TO_DECKS_DESC: ".\u0647\u0630\u0627 \u0647\u0648 \u0628\u062F\u064A\u0644 \u0644\u062E\u064A\u0627\u0631 \u0648\u0633\u0648\u0645 \u0627\u0644\u0628\u0637\u0627\u0642\u0629 \u0623\u0639\u0644\u0627\u0647",
  INLINE_SCHEDULING_COMMENTS: "\u062D\u0641\u0638 \u062A\u0639\u0644\u064A\u0642 \u0627\u0644\u062C\u062F\u0648\u0644\u0629 \u0639\u0644\u0649 \u0646\u0641\u0633 \u0627\u0644\u0633\u0637\u0631 \u0645\u062B\u0644 \u0627\u0644\u0633\u0637\u0631 \u0627\u0644\u0623\u062E\u064A\u0631 \u0644\u0644\u0628\u0637\u0627\u0642\u0629 \u061F",
  INLINE_SCHEDULING_COMMENTS_DESC: "\u0644\u0627 \u062A\u0643\u0633\u0631 \u062A\u0646\u0633\u064A\u0642 \u0627\u0644\u0642\u0627\u0626\u0645\u0629 HTML \u0633\u064A\u0624\u062F\u064A \u062A\u0634\u063A\u064A\u0644 \u0647\u0630\u0627 \u0625\u0644\u0649 \u062C\u0639\u0644 \u062A\u0639\u0644\u064A\u0642\u0627\u062A",
  BURY_SIBLINGS_TILL_NEXT_DAY: "\u0623\u062E\u0641\u064A \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A \u0627\u0644\u0634\u0642\u064A\u0642\u0629 \u062D\u062A\u0649 \u0627\u0644\u064A\u0648\u0645 \u0627\u0644\u062A\u0627\u0644\u064A",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "cloze deletions : \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A \u0627\u0644\u0634\u0642\u064A\u0642\u0629 \u0647\u064A \u0628\u0637\u0627\u0642\u0627\u062A \u062A\u0645 \u0625\u0646\u0634\u0627\u0624\u0647\u0627 \u0645\u0646 \u0646\u0641\u0633 \u0646\u0635 \u0627\u0644\u0628\u0637\u0627\u0642\u0629 \u0643\u0640",
  SHOW_CARD_CONTEXT: "\u0625\u0638\u0647\u0627\u0631 \u0627\u0644\u0633\u064A\u0627\u0642 \u0641\u064A \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A\u061F",
  SHOW_CARD_CONTEXT_DESC: "i.e. Title > Heading 1 > Subheading > ... > Subheading",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC: "Useful to know how far in the future your cards are being pushed.",
  CARD_MODAL_HEIGHT_PERCENT: "\u0646\u0633\u0628\u0629 \u0627\u0631\u062A\u0641\u0627\u0639 \u0627\u0644\u0628\u0637\u0627\u0642\u0629",
  CARD_MODAL_SIZE_PERCENT_DESC: "\u064A\u062C\u0628 \u0636\u0628\u0637\u0647\u0627 \u0639\u0644\u0649 100 \u066A \u0639\u0644\u0649 \u0627\u0644\u0647\u0627\u062A\u0641 \u0627\u0644\u0645\u062D\u0645\u0648\u0644 \u0623\u0648 \u0625\u0630\u0627 \u0643\u0627\u0646 \u0644\u062F\u064A\u0643 \u0635\u0648\u0631 \u0643\u0628\u064A\u0631\u0629 \u062C\u062F\u064B\u0627",
  RESET_DEFAULT: "\u0625\u0639\u0627\u062F\u0629 \u062A\u0639\u064A\u064A\u0646 \u0625\u0644\u0649 \u0627\u0644\u0627\u0641\u062A\u0631\u0627\u0636\u064A",
  CARD_MODAL_WIDTH_PERCENT: "\u0646\u0633\u0628\u0629 \u0639\u0631\u0636 \u0627\u0644\u0628\u0637\u0627\u0642\u0629",
  RANDOMIZE_CARD_ORDER: "\u062A\u0631\u062A\u064A\u0628 \u0628\u0637\u0627\u0642\u0629 \u0639\u0634\u0648\u0627\u0626\u064A \u0623\u062B\u0646\u0627\u0621 \u0627\u0644\u0645\u0631\u0627\u062C\u0639\u0629\u061F",
  REVIEW_CARD_ORDER_WITHIN_DECK: "Order cards in a deck are displayed during review",
  REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "Sequentially within a deck (All new cards first)",
  REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "Sequentially within a deck (All due cards first)",
  REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Randomly within a deck (All new cards first)",
  REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "Randomly within a deck (All due cards first)",
  REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
  REVIEW_DECK_ORDER: "Order decks are displayed during review",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL: "Sequentially (once all cards in previous deck reviewed)",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM: "Randomly (once all cards in previous deck reviewed)",
  REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
  DISABLE_CLOZE_CARDS: "\u061Fcloze \u062A\u0639\u0637\u064A\u0644 \u0628\u0637\u0627\u0642\u0627\u062A",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "Convert ==highlights== to clozes",
  CONVERT_HIGHLIGHTS_TO_CLOZES_DESC: 'Add/remove the <code>${defaultPattern}</code> from your "Cloze Patterns"',
  CONVERT_BOLD_TEXT_TO_CLOZES: "Convert **bolded text** to clozes",
  CONVERT_BOLD_TEXT_TO_CLOZES_DESC: 'Add/remove the <code>${defaultPattern}</code> from your "Cloze Patterns"',
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "Convert {{curly brackets}} to clozes",
  CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC: 'Add/remove the <code>${defaultPattern}</code> from your "Cloze Patterns"',
  CLOZE_PATTERNS: "Cloze Patterns",
  CLOZE_PATTERNS_DESC: 'Enter cloze patterns separated by newlines. Check the <a href="${docsUrl}">wiki</a> for guidance.',
  INLINE_CARDS_SEPARATOR: "\u0641\u0627\u0635\u0644 \u0645\u0646 \u0623\u062C\u0644 \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A \u0627\u0644\u0645\u0636\u0645\u0646\u0629",
  FIX_SEPARATORS_MANUALLY_WARNING: "\u0636\u0639 \u0641\u064A \u062D\u0633\u0627\u0628\u0643 \u0623\u0646\u0647 \u0628\u0639\u062F \u062A\u063A\u064A\u064A\u0631 \u0647\u0630\u0627 \u060C \u064A\u062C\u0628 \u0639\u0644\u064A\u0643 \u062A\u0639\u062F\u064A\u0644 \u0623\u064A \u0628\u0637\u0627\u0642\u0627\u062A \u0644\u062F\u064A\u0643 \u0628\u0627\u0644\u0641\u0639\u0644 \u064A\u062F\u0648\u064A\u064B\u0627",
  INLINE_REVERSED_CARDS_SEPARATOR: "\u0641\u0627\u0635\u0644 \u0645\u0646 \u0623\u062C\u0644 \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A \u0627\u0644\u0639\u0643\u0633\u064A\u0629 \u0627\u0644\u0645\u0636\u0645\u0646\u0629",
  MULTILINE_CARDS_SEPARATOR: "\u0641\u0627\u0635\u0644 \u0645\u0646 \u0623\u062C\u0644 \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A \u0627\u0644\u0645\u062A\u0639\u062F\u062F\u0629",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "\u0641\u0627\u0635\u0644 \u0645\u0646 \u0623\u062C\u0644 \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A \u0627\u0644\u0639\u0643\u0633\u064A\u0629 \u0627\u0644\u0645\u062A\u0639\u062F\u062F\u0629",
  MULTILINE_CARDS_END_MARKER: "\u0627\u0644\u0623\u062D\u0631\u0641 \u0627\u0644\u062A\u064A \u062A\u062F\u0644 \u0639\u0644\u0649 \u0646\u0647\u0627\u064A\u0629 \u0627\u0644\u0643\u0644\u0648\u0632\u0627\u062A \u0648\u0628\u0637\u0627\u0642\u0627\u062A \u0627\u0644\u062A\u0639\u0644\u0645 \u0627\u0644\u0645\u062A\u0639\u062F\u062F\u0629 \u0627\u0644\u0623\u0633\u0637\u0631",
  NOTES: "\u0645\u0644\u0627\u062D\u0638\u0627\u062A",
  NOTE: "Note",
  REVIEW_PANE_ON_STARTUP: "\u062A\u0645\u0643\u064A\u0646 \u062C\u0632\u0621 \u0645\u0631\u0627\u062C\u0639\u0629 \u0627\u0644\u0645\u0644\u0627\u062D\u0638\u0627\u062A \u0639\u0646\u062F \u0628\u062F\u0621 \u0627\u0644\u062A\u0634\u063A\u064A\u0644",
  TAGS_TO_REVIEW: "\u0648\u0633\u0648\u0645 \u0644\u0644\u0645\u0631\u0627\u062C\u0639\u0629",
  TAGS_TO_REVIEW_DESC: "#\u0623\u062F\u062E\u0644 \u0627\u0644\u0648\u0633\u0648\u0645 \u0645\u0641\u0635\u0648\u0644\u0629 \u0628\u0645\u0633\u0627\u0641\u0627\u062A \u0623\u0648 \u062E\u0637\u0648\u0637 \u062C\u062F\u064A\u062F\u0629 \u060C \u0623\u064A : \u0645\u0631\u0627\u062C\u0639\u0629# \u0648\u0633\u06452# \u0648\u0633\u06453",
  OPEN_RANDOM_NOTE: "\u0627\u0641\u062A\u062D \u0645\u0644\u0627\u062D\u0638\u0629 \u0639\u0634\u0648\u0627\u0626\u064A\u0629 \u0644\u0644\u0645\u0631\u0627\u062C\u0639\u0629",
  OPEN_RANDOM_NOTE_DESC: "(Pagerank) \u0639\u0646\u062F \u062A\u0639\u0637\u064A\u0644 \u0647\u0630\u0627 \u0627\u0644\u062E\u064A\u0627\u0631 \u060C\u0627\u0644\u0645\u0644\u0627\u062D\u0638\u0627\u062A \u0633\u064A\u062A\u0645 \u062A\u0631\u062A\u064A\u0628\u064F\u0647\u0627 \u062D\u0633\u0628 \u0627\u0644\u0623\u0647\u0645\u064A\u0629",
  AUTO_NEXT_NOTE: "\u0627\u0641\u062A\u062D \u0627\u0644\u0645\u0644\u0627\u062D\u0638\u0629 \u0627\u0644\u062A\u0627\u0644\u064A\u0629 \u062A\u0644\u0642\u0627\u0626\u064A\u064B\u0627 \u0628\u0639\u062F \u0627\u0644\u0645\u0631\u0627\u062C\u0639\u0629",
  ENABLE_FILE_MENU_REVIEW_OPTIONS: "\u0641\u0639\u0651\u0644 \u062E\u064A\u0627\u0631\u0627\u062A \u0627\u0644\u0645\u0631\u0627\u062C\u0639\u0629 \u0641\u064A \u0642\u0627\u0626\u0645\u0629 \u0627\u0644\u0645\u0644\u0641 (\u0645\u062B\u0627\u0644: \u0645\u0631\u0627\u062C\u0639\u0629: \u0633\u0647\u0644\u060C \u062C\u064A\u062F\u060C \u0635\u0639\u0628)",
  ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "\u0625\u0630\u0627 \u0642\u0645\u062A \u0628\u062A\u0639\u0637\u064A\u0644 \u062E\u064A\u0627\u0631\u0627\u062A \u0627\u0644\u0645\u0631\u0627\u062C\u0639\u0629 \u0641\u064A \u0642\u0627\u0626\u0645\u0629 \u0627\u0644\u0645\u0644\u0641\u060C \u064A\u0645\u0643\u0646\u0643 \u0645\u0631\u0627\u062C\u0639\u0629 \u0645\u0644\u0627\u062D\u0638\u0627\u062A\u0643 \u0628\u0627\u0633\u062A\u062E\u062F\u0627\u0645 \u0623\u0648\u0627\u0645\u0631 \u0627\u0644\u0625\u0636\u0627\u0641\u0629 \u0648\u0625\u0630\u0627 \u0643\u0646\u062A \u0642\u062F \u062D\u062F\u062F\u062A\u0647\u0627\u060C \u0628\u0627\u0633\u062A\u062E\u062F\u0627\u0645 \u0645\u0641\u0627\u062A\u064A\u062D \u0627\u0644\u0627\u062E\u062A\u0635\u0627\u0631 \u0627\u0644\u0645\u0631\u062A\u0628\u0637\u0629.",
  MAX_N_DAYS_REVIEW_QUEUE: "\u0627\u0644\u062D\u062F \u0627\u0644\u0623\u0642\u0635\u0649 \u0644\u0639\u062F\u062F \u0627\u0644\u0623\u064A\u0627\u0645 \u0627\u0644\u062A\u064A \u064A\u062C\u0628 \u0639\u0631\u0636\u0647\u0627 \u0639\u0644\u0649 \u0627\u0644\u0644\u0648\u062D\u0629 \u0627\u0644\u064A\u0645\u0646\u0649",
  MIN_ONE_DAY: "\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0639\u062F\u062F \u0627\u0644\u0623\u064A\u0627\u0645 1 \u0639\u0644\u0649 \u0627\u0644\u0623\u0642\u0644",
  VALID_NUMBER_WARNING: "\u064A\u0631\u062C\u0649 \u062A\u0642\u062F\u064A\u0645 \u0631\u0642\u0645 \u0635\u0627\u0644\u062D",
  UI: "User Interface",
  OPEN_IN_TAB: "Open in new tab",
  OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
  SHOW_STATUS_BAR: "Show status bar",
  SHOW_STATUS_BAR_DESC: "Turn this off to hide the flashcard's review status in Obsidian's status bar",
  SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
  SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0627\u0644\u0639\u0631\u0636 \u0627\u0644\u0634\u062C\u0631\u064A \u0644\u0644\u0631\u064F\u0632\u0645 \u0645\u0648\u0633\u0639 \u0628\u062D\u064A\u062B \u062A\u0637\u0647\u0631 \u0627\u0644\u0645\u0644\u0641\u0627\u062A \u0627\u0644\u0641\u0631\u0639\u064A\u0629 \u0643\u0644\u0647\u0627",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: " \u0639\u0637\u0644 \u0647\u0630\u0627 \u0627\u0644\u062E\u064A\u0627\u0631 \u0644\u0637\u064A \u0627\u0644\u0631\u064F\u0632\u0645 \u0627\u0644\u0645\u062A\u062F\u0627\u062E\u0644\u0629 \u0641\u064A \u0646\u0641\u0633 \u0627\u0644\u0628\u0637\u0627\u0642\u0629 , \u0645\u0641\u064A\u062F \u0625\u0630\u0627 \u0643\u0627\u0646 \u0644\u062F\u064A\u0643 \u0628\u0637\u0627\u0642\u0627\u062A \u062A\u0646\u062A\u0645\u064A \u0625\u0644\u0649 \u0627\u0644\u0639\u062F\u064A\u062F \u0645\u0646 \u0627\u0644\u0631\u064F\u0632\u0645 \u0641\u064A \u0646\u0641\u0633 \u0627\u0644\u0645\u0644\u0641",
  ALGORITHM: "\u062E\u0648\u0627\u0631\u0632\u0645\u064A\u0629",
  CHECK_ALGORITHM_WIKI: '<a href="${algoUrl}">algorithm details</a> :\u0644\u0645\u0632\u064A\u062F \u0645\u0646 \u0627\u0644\u0645\u0639\u0644\u0648\u0645\u0627\u062A \u062A\u062D\u0642\u0642 \u0645\u0646',
  SM2_OSR_VARIANT: "OSR's variant of SM-2",
  BASE_EASE: "\u0633\u0647\u0648\u0644\u0629 \u0627\u0644\u0642\u0627\u0639\u062F\u0629",
  BASE_EASE_DESC: "\u0627\u0644\u062D\u062F \u0627\u0644\u0623\u062F\u0646\u0649 = 130 \u060C \u0648\u064A\u0641\u0636\u0644 \u062D\u0648\u0627\u0644\u064A 250.",
  BASE_EASE_MIN_WARNING: "\u064A\u062C\u0628 \u0623\u0646 \u062A\u0643\u0648\u0646 \u0633\u0647\u0648\u0644\u0629 \u0627\u0644\u0642\u0627\u0639\u062F\u0629 130 \u0639\u0644\u0649 \u0627\u0644\u0623\u0642\u0644.",
  LAPSE_INTERVAL_CHANGE: "\u0627\u0644\u0641\u0627\u0635\u0644 \u0627\u0644\u0632\u0645\u0646\u064A \u064A\u062A\u063A\u064A\u0631 \u0639\u0646\u062F \u0645\u0631\u0627\u062C\u0639\u0629 \u0628\u0637\u0627\u0642\u0629/\u0645\u0644\u0627\u062D\u0638\u0629 \u0635\u0639\u0628\u0629",
  LAPSE_INTERVAL_CHANGE_DESC: "newInterval = oldInterval * intervalChange / 100.",
  EASY_BONUS: "\u0645\u0643\u0627\u0641\u0623\u0629 \u0633\u0647\u0644\u0629",
  EASY_BONUS_DESC: "\u062A\u062A\u064A\u062D \u0644\u0643 \u0627\u0644\u0645\u0643\u0627\u0641\u0623\u0629 \u0627\u0644\u0633\u0647\u0644\u0629 \u0636\u0628\u0637 \u0627\u0644\u0641\u0631\u0642 \u0641\u064A \u0627\u0644\u0641\u0648\u0627\u0635\u0644 \u0627\u0644\u0632\u0645\u0646\u064A\u0629 \u0628\u064A\u0646 \u0627\u0644\u0631\u062F \u0627\u0644\u062C\u064A\u062F \u0648\u0627\u0644\u0633\u0647\u0644 \u0639\u0644\u0649 \u0628\u0637\u0627\u0642\u0629/\u0645\u0644\u0627\u062D\u0638\u0629 (\u0627\u0644\u062D\u062F \u0627\u0644\u0623\u062F\u0646\u0649 = 100 \u066A).",
  EASY_BONUS_MIN_WARNING: "\u064A\u062C\u0628 \u0623\u0646 \u062A\u0643\u0648\u0646 \u0627\u0644\u0645\u0643\u0627\u0641\u0623\u0629 \u0627\u0644\u0633\u0647\u0644\u0629 100 \u0639\u0644\u0649 \u0627\u0644\u0623\u0642\u0644.",
  LOAD_BALANCE: "Enable load balancer",
  LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
  MAX_INTERVAL: "Maximum interval in days",
  MAX_INTERVAL_DESC: "\u064A\u062A\u064A\u062D \u0644\u0643 \u0648\u0636\u0639 \u062D\u062F \u0623\u0639\u0644\u0649  \u0644\u0644\u0641\u0627\u0635\u0644 \u0627\u0644\u0632\u0645\u0646\u064A (\u0627\u0641\u062A\u0631\u0627\u0636\u064A = 100 \u0639\u0627\u0645).",
  MAX_INTERVAL_MIN_WARNING: "\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0627\u0644\u062D\u062F \u0627\u0644\u0623\u0642\u0635\u0649 \u0644\u0644\u0641\u0627\u0635\u0644 \u0627\u0644\u0632\u0645\u0646\u064A \u0644\u0645\u062F\u0629 \u064A\u0648\u0645 \u0648\u0627\u062D\u062F \u0639\u0644\u0649 \u0627\u0644\u0623\u0642\u0644.",
  MAX_LINK_CONTRIB: "\u0623\u0642\u0635\u0649 \u0645\u0633\u0627\u0647\u0645\u0629 \u0627\u0631\u062A\u0628\u0627\u0637",
  MAX_LINK_CONTRIB_DESC: "\u0623\u0642\u0635\u0649 \u0645\u0633\u0627\u0647\u0645\u0629 \u0644\u0644\u0633\u0647\u0648\u0644\u0629 \u0627\u0644\u0645\u0631\u062C\u062D\u0629 \u0644\u0644\u0645\u0644\u0627\u062D\u0638\u0627\u062A \u0627\u0644\u0645\u0631\u062A\u0628\u0637\u0629 \u0628\u0627\u0644\u0633\u0647\u0648\u0644\u0629 \u0627\u0644\u0623\u0648\u0644\u064A\u0629.",
  LOGGING: "\u062A\u0633\u062C\u064A\u0644",
  DISPLAY_SCHEDULING_DEBUG_INFO: "\u0639\u0631\u0636 \u0645\u0639\u0644\u0648\u0645\u0627\u062A \u0627\u0644\u062A\u0635\u062D\u064A\u062D \u0639\u0644\u0649 \u0648\u062D\u062F\u0629 \u062A\u062D\u0643\u0645 \u0627\u0644\u0645\u0637\u0648\u0631",
  DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
  SCHEDULING: "Scheduling",
  EXPERIMENTAL: "Experimental",
  HELP: "Help",
  STORE_IN_NOTES: "In the notes",
  // sidebar.ts
  NOTES_REVIEW_QUEUE: "\u0645\u0644\u0627\u062D\u0638\u0627\u062A \u0642\u0627\u0626\u0645\u0629 \u0627\u0644\u0645\u0631\u0627\u062C\u0639\u0629",
  CLOSE: "\u0623\u063A\u0644\u0642",
  NEW: "\u062C\u062F\u064A\u062F",
  YESTERDAY: "\u0627\u0644\u0628\u0627\u0631\u062D\u0629",
  TODAY: "\u0627\u0644\u064A\u0648\u0645",
  TOMORROW: "\u0627\u0644\u063A\u062F",
  // stats-modal.tsx
  STATS_TITLE: "\u0625\u062D\u0635\u0627\u0626\u064A\u0627\u062A",
  MONTH: "\u0634\u0647\u0631",
  QUARTER: "\u0631\u0628\u0639 \u0627\u0644\u0633\u0646\u0629",
  YEAR: "\u0633\u0646\u0629",
  LIFETIME: "",
  FORECAST: "",
  FORECAST_DESC: "\u0639\u062F\u062F \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A \u0627\u0644\u0645\u0633\u062A\u062D\u0642\u0629 \u0641\u064A \u0627\u0644\u0645\u0633\u062A\u0642\u0628\u0644",
  SCHEDULED: "\u0627\u0644\u0645\u0642\u0631\u0631",
  DAYS: "\u0623\u064A\u0627\u0645",
  NUMBER_OF_CARDS: "\u0639\u062F\u062F \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A",
  REVIEWS_PER_DAY: "\u0627\u0644\u0645\u0631\u0627\u062C\u0639\u0627\u062A/\u0627\u0644\u064A\u0648\u0645 ${avg} :\u0645\u062A\u0648\u0633\u0637",
  INTERVALS: "\u0641\u0648\u0627\u0635\u0644 \u0632\u0645\u0646\u064A\u0629",
  INTERVALS_DESC: "\u0627\u0644\u062A\u0623\u062E\u064A\u0631 \u062D\u062A\u0649 \u064A\u062A\u0645 \u0639\u0631\u0636 \u0627\u0644\u0645\u0631\u0627\u062C\u0639\u0627\u062A \u0645\u0631\u0629 \u0623\u062E\u0631\u0649",
  COUNT: "\u0639\u062F\u062F",
  INTERVALS_SUMMARY: "${longest} : \u0623\u0637\u0648\u0644 \u0641\u0627\u0635\u0644 \u0632\u0645\u0646\u064A ,${avg} :\u0645\u062A\u0648\u0633\u0637 \u0627\u0644\u0641\u0627\u0635\u0644 \u0627\u0644\u0632\u0645\u0646\u064A",
  EASES: "\u0627\u0644\u0633\u0647\u0648\u0644\u0629",
  EASES_SUMMARY: "${avgEase} :\u0645\u062A\u0648\u0633\u0637 \u0627\u0644\u0633\u0647\u0648\u0644\u0629",
  EASE: "Ease",
  CARD_TYPES: "\u0623\u0646\u0648\u0627\u0639 \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A",
  CARD_TYPES_DESC: "\u0648\u0647\u0630\u0627 \u064A\u0634\u0645\u0644 \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A \u0627\u0644\u0645\u062E\u0641\u064A\u0629 \u0643\u0630\u0644\u0643 \u060C \u0625\u0646 \u0648\u062C\u062F\u062A",
  CARD_TYPE_NEW: "\u062C\u062F\u064A\u062F\u0629",
  CARD_TYPE_YOUNG: "\u0635\u063A\u064A\u0631\u0629",
  CARD_TYPE_MATURE: "\u0646\u0627\u0636\u062C\u0629",
  CARD_TYPES_SUMMARY: " ${totalCardsCount} :\u0625\u062C\u0645\u0627\u0644\u064A \u0639\u062F\u062F \u0627\u0644\u0628\u0637\u0627\u0642\u0627\u062A",
  SEARCH: "Search",
  PREVIOUS: "Previous",
  NEXT: "Next"
};

// src/lang/locale/bn.ts
var bn_default = {};

// src/lang/locale/cz.ts
var cz_default = {
  // flashcard-modal.tsx
  DECKS: "Bal\xED\u010Dky",
  DUE_CARDS: "Karti\u010Dky po term\xEDnu",
  NEW_CARDS: "Nov\xE9 karti\u010Dky",
  TOTAL_CARDS: "Karti\u010Dek celkem",
  BACK: "Back",
  SKIP: "Skip",
  EDIT_CARD: "Edit Card",
  RESET_CARD_PROGRESS: "Vynulovat pokrok karti\u010Dky",
  HARD: "T\u011B\u017Ek\xE9",
  GOOD: "Dobr\xE9",
  EASY: "Jednoduch\xE9",
  SHOW_ANSWER: "Uk\xE1zat odpov\u011B\u010F",
  CARD_PROGRESS_RESET: "Pokrok karti\u010Dky byl vynulov\xE1n.",
  SAVE: "Save",
  CANCEL: "Cancel",
  NO_INPUT: "No input provided.",
  CURRENT_EASE_HELP_TEXT: "Current Ease: ",
  CURRENT_INTERVAL_HELP_TEXT: "Current Interval: ",
  CARD_GENERATED_FROM: "Generated from: ${notePath}",
  // main.ts
  OPEN_NOTE_FOR_REVIEW: "Otev\u0159\xEDt pozn\xE1mku k revizi",
  REVIEW_CARDS: "Pozn\xE1mek k revizi",
  REVIEW_DIFFICULTY_FILE_MENU: "Revize: ${difficulty}",
  REVIEW_NOTE_DIFFICULTY_CMD: "Ozna\u010Dit pozn\xE1mku jako ${difficulty}",
  REVIEW_ALL_CARDS: "Revidovat karti\u010Dky ve v\u0161ech pozn\xE1mk\xE1ch",
  CRAM_ALL_CARDS: "Select a deck to cram",
  REVIEW_CARDS_IN_NOTE: "Revidovat karti\u010Dky v t\xE9to pozn\xE1mce.",
  CRAM_CARDS_IN_NOTE: "Cram karti\u010Dky v t\xE9to pozn\xE1mce.",
  VIEW_STATS: "Uk\xE1zat statistiky",
  OPEN_REVIEW_QUEUE_VIEW: "Open Notes Review Queue in sidebar",
  STATUS_BAR: "Revize: ${dueNotesCount} pozn\xE1mek, ${dueFlashcardsCount} karti\u010Dek po term\xEDnu",
  SYNC_TIME_TAKEN: "Synchronizace trvala ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "Pozn\xE1mka je ulo\u017Eena v ignorovan\xE9 slo\u017Ece (zkontrolujte nastaven\xED).",
  PLEASE_TAG_NOTE: "Pros\xEDm ozna\u010Dne pozn\xE1mku odpov\xEDdaj\xEDc\xEDm tagem pro revizi (v nastaven\xED).",
  RESPONSE_RECEIVED: "Odpov\u011B\u010F p\u0159ijata.",
  NO_DECK_EXISTS: "Neexistuje \u017E\xE1dn\xFD bal\xED\u010Dek pro ${deckName}",
  ALL_CAUGHT_UP: "V\u0161e zrevidov\xE1no",
  // scheduling.ts
  DAYS_STR_IVL: "${interval} den/dn\xED",
  MONTHS_STR_IVL: "${interval} m\u011Bs\xEDc(\u016F)",
  YEARS_STR_IVL: "${interval} rok(\u016F)",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}r",
  // settings.ts
  SETTINGS_HEADER: "Spaced Repetition",
  GROUP_TAGS_FOLDERS: "Tags & Folders",
  GROUP_FLASHCARD_REVIEW: "Flashcard Review",
  GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
  GROUP_DATA_STORAGE: "Storage of Scheduling Data",
  GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
  GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
  GROUP_CONTRIBUTING: "Contributing",
  CHECK_WIKI: 'Pro v\xEDce informac\xED jd\u011Bte na <a href="${wikiUrl}">wiki</a>.',
  GITHUB_DISCUSSIONS: 'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
  GITHUB_ISSUES: 'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
  GITHUB_SOURCE_CODE: 'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
  CODE_CONTRIBUTION_INFO: '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
  TRANSLATION_CONTRIBUTION_INFO: '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
  FOLDERS_TO_IGNORE: "Ignorovan\xE9 slo\u017Eky",
  FOLDERS_TO_IGNORE_DESC: "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
  OBSIDIAN_INTEGRATION: "Integration into Obsidian",
  FLASHCARDS: "Karti\u010Dky",
  FLASHCARD_EASY_LABEL: "Easy Button Text",
  FLASHCARD_GOOD_LABEL: "Good Button Text",
  FLASHCARD_HARD_LABEL: "Hard Button Text",
  FLASHCARD_EASY_DESC: 'Customize the label for the "Easy" Button',
  FLASHCARD_GOOD_DESC: 'Customize the label for the "Good" Button',
  FLASHCARD_HARD_DESC: 'Customize the label for the "Hard" Button',
  REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
  REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
  FLASHCARD_TAGS: "Tag pro karti\u010Dky",
  FLASHCARD_TAGS_DESC: "Zadete tagy ood\u011Blen\xE9 mezerou nebo od\u0159\xE1dkov\xE1n\xEDm nap\u0159\xEDklad. #karti\u010Dky #bal\xED\u010Dke2 #bal\xED\u010Dek3.",
  CONVERT_FOLDERS_TO_DECKS: "P\u0159ev\xE9st slo\u017Eky na bal\xED\u010Dky a podbal\xED\u010Dky?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "Toto je alternativa k tag\u016Fm karti\u010Dek viz nastaven\xED v\xFD\u0161e.",
  INLINE_SCHEDULING_COMMENTS: "Ulo\u017Eit pl\xE1novac\xED koment\xE1\u0159 na stejn\xFD \u0159\xE1dek jako posledn\xED polo\u017Eka karti\u010Dky?",
  INLINE_SCHEDULING_COMMENTS_DESC: "Zapnut\xED t\xE9to volby zp\u016Fsob\xED, \u017Ee HTML koment\xE1\u0159e nebudou rozb\xEDjet form\xE1tov\xE1n\xED list\u016F.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Odlo\u017Eit p\u0159\xEDbuzn\xE9 karti\u010Dky na dal\u0161\xED den?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "P\u0159\xEDbuzn\xE9 karti\u010Dky jsou karti\u010Dky generovan\xE9 z textu stejn\xE9 pozn\xE1mky nap\u0159\xEDklad cloze smaz\xE1n\xED",
  SHOW_CARD_CONTEXT: "Uk\xE1zat kontext v karti\u010Dce?",
  SHOW_CARD_CONTEXT_DESC: "nap\u0159\xEDklad Titulek > Nadpis1 > Podnadpis > ... > Podnadpis",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC: "Useful to know how far in the future your cards are being pushed.",
  CARD_MODAL_HEIGHT_PERCENT: "V\xFD\u0161ka karti\u010Dek v procentech",
  CARD_MODAL_SIZE_PERCENT_DESC: "M\u011Blo by b\xFDt nastaveno na 100% na mobilu nebo kdy\u017E pou\u017E\xEDv\xE1te velk\xE9 obr\xE1zky",
  RESET_DEFAULT: "Resetovat v\xFDchoz\xED nastaven\xED",
  CARD_MODAL_WIDTH_PERCENT: "\u0160\xED\u0159ka karti\u010Dek v procentech",
  RANDOMIZE_CARD_ORDER: "N\xE1hodn\u011B zm\u011Bnit po\u0159ad\xED karti\u010Dek b\u011Bhem revize?",
  REVIEW_CARD_ORDER_WITHIN_DECK: "Order cards in a deck are displayed during review",
  REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "Sequentially within a deck (All new cards first)",
  REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "Sequentially within a deck (All due cards first)",
  REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Randomly within a deck (All new cards first)",
  REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "Randomly within a deck (All due cards first)",
  REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
  REVIEW_DECK_ORDER: "Order decks are displayed during review",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL: "Sequentially (once all cards in previous deck reviewed)",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM: "Randomly (once all cards in previous deck reviewed)",
  REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
  DISABLE_CLOZE_CARDS: "Vypnout cloze karti\u010Dky?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "P\u0159ev\xE9st ==zv\xFDrazn\u011Bn\xED== na clozes?",
  CONVERT_HIGHLIGHTS_TO_CLOZES_DESC: 'P\u0159idat/odstranit <code>${defaultPattern}</code> z va\u0161ich "Cloze vzor\u016F"',
  CONVERT_BOLD_TEXT_TO_CLOZES: "P\u0159ev\xE9st **tu\u010Dn\xFD text** na clozes?",
  CONVERT_BOLD_TEXT_TO_CLOZES_DESC: 'P\u0159idat/odstranit <code>${defaultPattern}</code> z va\u0161ich "Cloze vzor\u016F"',
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "P\u0159ev\xE9st {{slo\u017Een\xE9 z\xE1vorky}} na clozes?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC: 'P\u0159idat/odstranit <code>${defaultPattern}</code> z va\u0161ich "Cloze vzor\u016F"',
  CLOZE_PATTERNS: "Cloze vzory",
  CLOZE_PATTERNS_DESC: 'Zadejte cloze vzory odd\u011Blen\xE9 od\u0159\xE1dkov\xE1n\xEDm. Check the <a href="${docsUrl}">wiki</a> for guidance.',
  INLINE_CARDS_SEPARATOR: "Odd\u011Blova\u010D pro inline karti\u010Dky",
  FIX_SEPARATORS_MANUALLY_WARNING: "Pozor. Jakmile toto zm\u011Bn\xEDte, budete muset ru\u010Dn\u011B upravit v\u0161echny existuj\xEDc\xED karti\u010Dky.",
  INLINE_REVERSED_CARDS_SEPARATOR: "Odd\u011Blova\u010D pro oto\u010Den\xE9 inline karti\u010Dky",
  MULTILINE_CARDS_SEPARATOR: "Odd\u011Blova\u010D pro v\xEDce\u0159\xE1dkov\xE9 karti\u010Dky",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "Odd\u011Blova\u010D pro v\xEDce\u0159\xE1dkove oto\u010Den\xE9 karti\u010Dky",
  MULTILINE_CARDS_END_MARKER: "Znaky ozna\u010Duj\xEDc\xED konec clozes a v\xEDce\u0159\xE1dkov\xFDch flash karet",
  NOTES: "Pozn\xE1mky",
  NOTE: "Note",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "Tag pro revizi",
  TAGS_TO_REVIEW_DESC: "Zadejte tagy odd\u011Blen\xE9 mezerami nebo od\u0159\xE1dkov\xE1n\xEDm nap\u0159\xEDklad #review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "Otev\u0159\xEDt n\xE1hodnou pozn\xE1mku pro revizi",
  OPEN_RANDOM_NOTE_DESC: "Pokud toto vypnete, pozn\xE1mky budou \u0159azeny dle d\u016Fle\u017Eitosti (PageRank).",
  AUTO_NEXT_NOTE: "Otev\u0159\xEDt automaticky dal\u0161\xED pozn\xE1mku po dokon\u010Den\xED revize",
  ENABLE_FILE_MENU_REVIEW_OPTIONS: "Povolte mo\u017Enosti revize v nab\xEDdce souboru (nap\u0159. Revize: Jednoduch\xE9, Dobr\xE9, T\u011B\u017Ek\xE9)",
  ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "Pokud v nab\xEDdce souboru zak\xE1\u017Eete mo\u017Enosti revize, m\u016F\u017Eete sv\xE9 pozn\xE1mky revidovat pomoc\xED p\u0159\xEDkaz\u016F pluginu a, pokud jste je definovali, pomoc\xED p\u0159i\u0159azen\xFDch kl\xE1vesov\xFDch zkratek.",
  MAX_N_DAYS_REVIEW_QUEUE: "Maxim\xE1ln\xED po\u010Det dn\xED zobrazen\xFDch v prav\xE9m panelu",
  MIN_ONE_DAY: "Po\u010Det dn\xED mus\xED b\xFDt minim\xE1ln\u011B 1.",
  VALID_NUMBER_WARNING: "Pros\xEDm zadejte validn\xED \u010D\xEDslo.",
  UI: "P\u0159edvolby u\u017Eivatelsk\xE9ho rozhran\xED",
  OPEN_IN_TAB: "Open in new tab",
  OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
  SHOW_STATUS_BAR: "Show status bar",
  SHOW_STATUS_BAR_DESC: "Turn this off to hide the flashcard's review status in Obsidian's status bar",
  SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
  SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "Stromy bal\xED\u010Dky by m\u011Bly b\xFDt zpo\u010D\xE1tku zobrazeny jako rozbalen\xE9",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "Vypn\u011Bte toto, chcete-li sbalit vno\u0159en\xE9 bal\xED\u010Dky na stejn\xE9 kart\u011B. To je u\u017Eite\u010Dn\xE9, pokud m\xE1te karti\u010Dky, kter\xE9 pat\u0159\xED k mnoha bal\xED\u010Dk\u016Fm ve stejn\xE9m souboru.",
  ALGORITHM: "Algoritmus",
  CHECK_ALGORITHM_WIKI: 'Pro v\xEDce informac\xED jd\u011Bte na <a href="${algoUrl}">popis algoritmu</a>.',
  SM2_OSR_VARIANT: "OSR's variant of SM-2",
  BASE_EASE: "Z\xE1kladn\xED slo\u017Eitost",
  BASE_EASE_DESC: "minimum = 130, nejl\xE9pe p\u0159ibli\u017En\u011B 250.",
  BASE_EASE_MIN_WARNING: "Z\xE1kladn\xED slo\u017Eitost mus\xED b\xFDt minim\xE1ln\u011B 130.",
  LAPSE_INTERVAL_CHANGE: "Zm\u011Bna intervalu pokud karti\u010Dku/pozn\xE1mku ozna\u010D\xEDte jako slo\u017Eitou",
  LAPSE_INTERVAL_CHANGE_DESC: "nov\xFD_inteval = star\xFD_interval * zm\u011Bna_intevalu / 100.",
  EASY_BONUS: "Bonus pro jednoduch\xE9",
  EASY_BONUS_DESC: "Tento bonus umo\u017E\u0148uje nastavit rozd\xEDl intervalu mezi jednoduch\xFDmi a dobr\xFDmi karti\u010Dkami/pozn\xE1mkami (minimum = 100%).",
  EASY_BONUS_MIN_WARNING: "Bonus pro jednoduchost mus\xED b\xFDt minim\xE1ln\u011B 100.",
  LOAD_BALANCE: "Enable load balancer",
  LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
  MAX_INTERVAL: "Maximum interval in days",
  MAX_INTERVAL_DESC: "Umo\u017E\u0148uje nastavit horn\xED limit pro interval (defaultn\u011B = 100 let).",
  MAX_INTERVAL_MIN_WARNING: "Maxim\xE1ln\xED interval mus\xED b\xFDt alespo\u0148 1 den.",
  MAX_LINK_CONTRIB: "Maxim\xE1ln\xED p\u0159\xEDsp\u011Bv\u011Bk prolinkov\xE1n\xED",
  MAX_LINK_CONTRIB_DESC: "Maxim\xE1ln\xED p\u0159\xEDsp\u011Bvek v\xE1\u017Een\xE9 slo\u017Eitosti prolinkovan\xFDch pozn\xE1mek pou\u017Eit\xFD pro ur\u010Den\xED po\u010D\xE1te\u010Dn\xED slo\u017Eitosti.",
  LOGGING: "Zaznamen\xE1v\xE1m",
  DISPLAY_SCHEDULING_DEBUG_INFO: "Zobrazit informace pro lad\u011Bn\xED na v\xFDvoj\xE1\u0159sk\xE9 konzoli",
  DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
  SCHEDULING: "Scheduling",
  EXPERIMENTAL: "Experimental",
  HELP: "Help",
  STORE_IN_NOTES: "In the notes",
  // sidebar.ts
  NOTES_REVIEW_QUEUE: "Fronta pozn\xE1mek k revizi",
  CLOSE: "Uzav\u0159en\xE9",
  NEW: "Nov\xE9",
  YESTERDAY: "V\u010Dera",
  TODAY: "Dnes",
  TOMORROW: "Z\xEDtra",
  // stats-modal.tsx
  STATS_TITLE: "Statistiky",
  MONTH: "M\u011Bs\xEDc",
  QUARTER: "\u010Ctvrtlet\xED",
  YEAR: "Rok",
  LIFETIME: "Celkov\u011B",
  FORECAST: "P\u0159edpov\u011B\u010F",
  FORECAST_DESC: "Celkov\xFD po\u010Det karti\u010Dek, kter\xFDm vypr\u0161\xED term\xEDn",
  SCHEDULED: "Napl\xE1nov\xE1no",
  DAYS: "Dn\xED",
  NUMBER_OF_CARDS: "Po\u010Det karti\u010Dek",
  REVIEWS_PER_DAY: "Pr\u016Fm\u011Br: ${avg} revize/den",
  INTERVALS: "Intervaly",
  INTERVALS_DESC: "Doba, za kterou bude znovu zobrazeno k revize",
  COUNT: "Po\u010Det",
  INTERVALS_SUMMARY: "Pr\u016Fm\u011Brn\xFD interval: ${avg}, Nejdel\u0161\xED interval: ${longest}",
  EASES: "Slo\u017Eitost",
  EASES_SUMMARY: "Pr\u016Fm\u011Brn\xE1 slo\u017Eitost: ${avgEase}",
  EASE: "Ease",
  CARD_TYPES: "Typy karti\u010Dek",
  CARD_TYPES_DESC: "Obsahuje i odlo\u017Een\xE9 karti\u010Dky (pokud existuj\xED)",
  CARD_TYPE_NEW: "Nov\xE1",
  CARD_TYPE_YOUNG: "Mlad\xE1",
  CARD_TYPE_MATURE: "Dosp\u011Bl\xE1",
  CARD_TYPES_SUMMARY: "Karti\u010Dek celkem: ${totalCardsCount}",
  SEARCH: "Search",
  PREVIOUS: "Previous",
  NEXT: "Next"
};

// src/lang/locale/da.ts
var da_default = {};

// src/lang/locale/de.ts
var de_default = {
  // flashcard-modal.tsx
  DECKS: "Stapel",
  DUE_CARDS: "Anstehende Karten",
  NEW_CARDS: "Neue Karten",
  TOTAL_CARDS: "Alle Karten",
  BACK: "Zur\xFCck",
  SKIP: "\xDCberspringen",
  EDIT_CARD: "Karte bearbeiten",
  RESET_CARD_PROGRESS: "Kartenfortschritt zur\xFCcksetzten",
  HARD: "Schwer",
  GOOD: "Gut",
  EASY: "Einfach",
  SHOW_ANSWER: "Zeige Antwort",
  CARD_PROGRESS_RESET: "Kartenfortschritt wurde zur\xFCckgesetzt.",
  SAVE: "Speichern",
  CANCEL: "Abbrechen",
  NO_INPUT: "Keine Eingabe erhalten.",
  CURRENT_EASE_HELP_TEXT: "Aktuelle Schwierigkeit: ",
  CURRENT_INTERVAL_HELP_TEXT: "Aktueller Intervall: ",
  CARD_GENERATED_FROM: "Erstellt von: ${notePath}",
  // main.ts
  OPEN_NOTE_FOR_REVIEW: "Notiz zur Wiederholung \xF6ffnen",
  REVIEW_CARDS: "Lernkarten wiederholen",
  REVIEW_DIFFICULTY_FILE_MENU: "Notizen wiederholen als: ${difficulty}",
  REVIEW_NOTE_DIFFICULTY_CMD: "Notizen wiederholen als: ${difficulty}",
  REVIEW_ALL_CARDS: "Alle Lernkarten wiederholen",
  CRAM_ALL_CARDS: "W\xE4hle ein Stapel zum pauken",
  REVIEW_CARDS_IN_NOTE: "Lernkarten in dieser Notiz wiederholen",
  CRAM_CARDS_IN_NOTE: "Lernkarten in dieser Notiz pauken.",
  VIEW_STATS: "Statistiken anzeigen",
  OPEN_REVIEW_QUEUE_VIEW: "\xD6ffne \xDCberpr\xFCfungswarteschlage in der Seitenleiste",
  STATUS_BAR: "Wiederholung: ${dueNotesCount} Notiz(en), ${dueFlashcardsCount} Karte(n) anstehend",
  SYNC_TIME_TAKEN: "Synchronisierung dauerte ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "Notiz befindet sich in einem ausgeschlossenen Ordner (siehe Einstellungen).",
  PLEASE_TAG_NOTE: "Bitte die Notiz f\xFCr Wiederholungen entsprechend taggen (siehe Einstellungen).",
  RESPONSE_RECEIVED: "Antwort erhalten.",
  NO_DECK_EXISTS: "Kein Stapel f\xFCr ${deckName} gefunden.",
  ALL_CAUGHT_UP: "Yuhu! Alles geschafft! :D.",
  // scheduling.ts
  DAYS_STR_IVL: "${interval} Tag(e)",
  MONTHS_STR_IVL: "${interval} Monat(e)",
  YEARS_STR_IVL: "${interval} Jahr(e)",
  DAYS_STR_IVL_MOBILE: "${interval}t",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}j",
  // settings.ts
  SETTINGS_HEADER: "Spaced Repetition",
  GROUP_TAGS_FOLDERS: "Tags & Folders",
  GROUP_FLASHCARD_REVIEW: "Flashcard Review",
  GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
  GROUP_DATA_STORAGE: "Storage of Scheduling Data",
  GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
  GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
  GROUP_CONTRIBUTING: "Contributing",
  CHECK_WIKI: 'Weitere Informationen gibt es im <a href="${wikiUrl}">Wiki</a> (english).',
  GITHUB_DISCUSSIONS: 'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
  GITHUB_ISSUES: 'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
  GITHUB_SOURCE_CODE: 'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
  CODE_CONTRIBUTION_INFO: '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
  TRANSLATION_CONTRIBUTION_INFO: '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
  FOLDERS_TO_IGNORE: "Ausgeschlossene Ordner",
  FOLDERS_TO_IGNORE_DESC: "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
  OBSIDIAN_INTEGRATION: "Integration into Obsidian",
  FLASHCARDS: "Lernkarten",
  FLASHCARD_EASY_LABEL: "Einfach Knopf Text",
  FLASHCARD_GOOD_LABEL: "Gut Knopf Text",
  FLASHCARD_HARD_LABEL: "Schwer Knopf Text",
  FLASHCARD_GOOD_DESC: 'Passe die Beschriftung f\xFCr "Gut" Knopf an',
  FLASHCARD_EASY_DESC: 'Passe die Beschriftung f\xFCr "Einfach" Knopf an',
  FLASHCARD_HARD_DESC: 'Passe die Beschriftung f\xFCr "Schwer" Knopf an',
  REVIEW_BUTTON_DELAY: "Druckknopfverz\xF6gerung (ms)",
  REVIEW_BUTTON_DELAY_DESC: "F\xFCgt den \xDCberpr\xFCfungsschaltfl\xE4chen (\u201EEinfach\u201C, \u201EGut\u201C, \u201ESchwer\u201C, \u201EAntwort anzeigen\u201C) eine Verz\xF6gerung hinzu, bevor sie erneut gedr\xFCckt werden k\xF6nnen.",
  FLASHCARD_TAGS: "Lernkarten Tags",
  FLASHCARD_TAGS_DESC: "Mehrere Tags mit Leerzeichen oder Zeilenumbr\xFCchen getrennt angeben. Bsp. #karte #stapel2 #stapel3.",
  CONVERT_FOLDERS_TO_DECKS: "Ordner in Stapel und Substapel umwandeln?",
  CONVERT_FOLDERS_TO_DECKS_DESC: 'Eine Alternative zur oberen "Lernkarten Tags" Option.',
  INLINE_SCHEDULING_COMMENTS: "Den Fortschritt in der gleichen Zeile wie die letzte Zeile einer Lernkartei speichern?",
  INLINE_SCHEDULING_COMMENTS_DESC: "Wenn aktiviert, wird der HTML Kommentar die umgebende Liste nicht aufbrechen.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Verwandte Karten auf den n\xE4chsten Tag verlegen?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "Verwandte Karten sind aus der gleichen Karte generiert worden (z.B. L\xFCckentextkarten oder beidseitige Karten).",
  SHOW_CARD_CONTEXT: "Kontext in den Karten anzeigen?",
  SHOW_CARD_CONTEXT_DESC: "Bsp. Titel > \xDCberschrift 1 > Sektion > ... > Untersektion",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC: "Useful to know how far in the future your cards are being pushed.",
  CARD_MODAL_HEIGHT_PERCENT: "H\xF6he der Lernkartei in Prozent",
  CARD_MODAL_SIZE_PERCENT_DESC: "Auf kleinen Bildschirmen (z.B. Smartphones) oder bei sehr grossen Bildern sollte dieser Wert auf 100% gesetzt werden.",
  RESET_DEFAULT: "Standardeinstellung wiederherstellen",
  CARD_MODAL_WIDTH_PERCENT: "Breite einer Lernkarte in Prozent",
  RANDOMIZE_CARD_ORDER: "W\xE4hrend der Wiederhoung die Reihenfolge zuf\xE4llig mischen?",
  REVIEW_CARD_ORDER_WITHIN_DECK: "Reihenfolge der Karten innerhalb eines Stapels w\xE4hrend der Wiederholung",
  REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "Sequentielle Reihenfolge innerhalb eines Stapels (Alle neuen Karten zuerst)",
  REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "Sequentielle Reihenfolge innerhalb eines Stapels (Alle f\xE4lligen Karten zuerst)",
  REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Zuf\xE4llige Reihenfolge innerhalb eines Stapels (Alle neuen Karten zuerst)",
  REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "Zuf\xE4llige Reihenfolge innerhalb eines Stapels (Alle f\xE4lligen Karten zuerst)",
  REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Zuf\xE4llige Karte von zuf\xE4lligem Stapel",
  REVIEW_DECK_ORDER: "Reihenfolge der Stapel w\xE4hrend der Wiederholung",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL: "Sequentielle Reihenfolge (sobald alle Karten im vorherigen Stapel wiederholt wurden)",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM: "Zuf\xE4llige Reihenfolge (sobald alle Karten im vorherigen Stapel wiederholt wurden)",
  REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Zuf\xE4llige Karte von zuf\xE4lligem Stapel",
  DISABLE_CLOZE_CARDS: "L\xFCckentextkarten deaktivieren?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "==Hervorgehobenen== Text in L\xFCckentextkarten umwandeln?",
  CONVERT_HIGHLIGHTS_TO_CLOZES_DESC: 'F\xFCge/entferne das <code>${defaultPattern}</code> zu deinen "L\xFCckentextmuster" hinzu',
  CONVERT_BOLD_TEXT_TO_CLOZES: "**Fettgedruckten** Text in L\xFCckentextkarten umwandeln?",
  CONVERT_BOLD_TEXT_TO_CLOZES_DESC: 'F\xFCge/entferne das <code>${defaultPattern}</code> zu deinen "L\xFCckentextmuster" hinzu',
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "{{Geschweifte Klammern}} Text in L\xFCckentextkarten umwandeln?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC: 'F\xFCge/entferne das <code>${defaultPattern}</code> zu deinen "L\xFCckentextmuster" hinzu',
  CLOZE_PATTERNS: "L\xFCckentextmuster",
  CLOZE_PATTERNS_DESC: 'Geben Sie L\xFCckentextmuster durch Zeilenumbr\xFCche getrennt ein. Check the <a href="${docsUrl}">wiki</a> for guidance.',
  INLINE_CARDS_SEPARATOR: "Trennzeichen f\xFCr einzeilige Lernkarten",
  FIX_SEPARATORS_MANUALLY_WARNING: "Wenn diese Einstellung ge\xE4ndert wird, dann m\xFCssen die entsprechenden Lernkarten manuell angepasst werden.",
  INLINE_REVERSED_CARDS_SEPARATOR: "Trennzeichen f\xFCr einzeilige beidseitige Lernkarten",
  MULTILINE_CARDS_SEPARATOR: "Trennzeichen f\xFCr mehrzeilige Lernkarten",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "Trennzeichen f\xFCr mehrzeilige beidseitige Lernkarten",
  MULTILINE_CARDS_END_MARKER: "Zeichen, die das Ende von L\xFCckentexten und mehrzeiligen Flashcards kennzeichnen",
  NOTES: "Notizen",
  NOTE: "Note",
  REVIEW_PANE_ON_STARTUP: "\xD6ffne \xDCberpr\xFCfungswarteschlage beim start",
  TAGS_TO_REVIEW: "Zu wiederholende Tags",
  TAGS_TO_REVIEW_DESC: "Mehrere Tags k\xF6nnen mit Leerzeichen oder Zeilenumbr\xFCchen getrennt angegeben werden. Bsp. #karte #tag1 #tag2.",
  OPEN_RANDOM_NOTE: "Zuf\xE4llige Karten wiederholen",
  OPEN_RANDOM_NOTE_DESC: "Wenn dies deaktiviert wird, dann werden die Notizen nach Wichtigkeit wiederholt (PageRank).",
  AUTO_NEXT_NOTE: "Nach einer Wiederholung automatisch die n\xE4chste Karte \xF6ffnen",
  ENABLE_FILE_MENU_REVIEW_OPTIONS: "Aktiviere die \xDCberpr\xFCfungsoptionen im Dateimen\xFC (z. B. Notizen wiederholen als: Einfach, Gut, Schwer)",
  ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "Wenn du die \xDCberpr\xFCfungsoptionen im Dateimen\xFC deaktivierst, kannst du deine Notizen mit den Plugin-Befehlen und, falls definiert, den zugeh\xF6rigen Tastenkombinationen \xFCberpr\xFCfen.",
  MAX_N_DAYS_REVIEW_QUEUE: "Maximale Anzahl anstehender Notizen, die im rechten Fensterbereich angezeigt werden",
  MIN_ONE_DAY: "Anzahl der Tage muss mindestens 1 sein.",
  VALID_NUMBER_WARNING: "Bitte eine g\xFCltige Zahl eingeben.",
  UI: "User Interface",
  OPEN_IN_TAB: "\xD6ffne im neuen Tab",
  OPEN_IN_TAB_DESC: "Schalte dies aus, um die Notizen in einem Modalfenster zu \xF6ffnen",
  SHOW_STATUS_BAR: "Show status bar",
  SHOW_STATUS_BAR_DESC: "Turn this off to hide the flashcard's review status in Obsidian's status bar",
  SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
  SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "Stapelverzeichnis soll beim \xF6ffnen erweitert angezeigt werden",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "Deaktivieren Sie dies, um verschachtelte Stapel in derselben Karte zu reduzieren. N\xFCtzlich, wenn Sie Karten haben, die zu vielen Stapeln in derselben Datei geh\xF6ren.",
  ALGORITHM: "Algorithmus",
  CHECK_ALGORITHM_WIKI: 'Weiterf\xFChrende Informationen: <a href="${algoUrl}">Implementierung des Algorithmus</a> (english).',
  SM2_OSR_VARIANT: "OSR's variant of SM-2",
  BASE_EASE: "Basis der Schwierigkeit",
  BASE_EASE_DESC: "Minimum ist 130. Empfohlen wird ca. 250.",
  BASE_EASE_MIN_WARNING: "Basis der Schwierigkeit muss mindestens 130 sein.",
  LAPSE_INTERVAL_CHANGE: "Anpassungsfaktor des Intervalls wenn eine Notiz / Karte 'Schwer' abgeschlossen wird",
  LAPSE_INTERVAL_CHANGE_DESC: "neuesIntervall = altesIntervall * anpassungsfaktor / 100.",
  EASY_BONUS: "Einfachheit-Bonus",
  EASY_BONUS_DESC: "Der Einfachheit-Bonus gibt an um welchen Faktor (in Prozent) das Intervall l\xE4nger sein soll, wenn eine Notiz / Karte 'Einfach' statt 'Gut' abgeschlossen wird. Minimum ist 100%.",
  EASY_BONUS_MIN_WARNING: "Der Einfachheit-Bonus muss mindestens 100 sein.",
  LOAD_BALANCE: "Enable load balancer",
  LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
  MAX_INTERVAL: "Maximale Intervall in Tagen",
  MAX_INTERVAL_DESC: "Das maximale Intervall (in Tagen) f\xFCr Wiederholungen. Standard sind 100 Jahre.",
  MAX_INTERVAL_MIN_WARNING: "Das maximale Interall muss mindestens ein Tag sein.",
  MAX_LINK_CONTRIB: "Maximaler Einfluss von Links",
  MAX_LINK_CONTRIB_DESC: "Maximaler Einfluss der Einfachheiten verlinkter Notizen zur gewichteten initialen Einfachheit einer neuen Lernkarte.",
  LOGGING: "Protokollierung",
  DISPLAY_SCHEDULING_DEBUG_INFO: "Informationen zum Debugging in der Entwicklerkonsole anzeigen",
  DISPLAY_PARSER_DEBUG_INFO: "Informationen zum parser Debugging in der Entwicklerkonsole anzeigen",
  SCHEDULING: "Scheduling",
  EXPERIMENTAL: "Experimental",
  HELP: "Help",
  STORE_IN_NOTES: "In the notes",
  // sidebar.ts
  NOTES_REVIEW_QUEUE: "Anstehende Notizen zur Wiederholung",
  CLOSE: "Schliessen",
  NEW: "Neu",
  YESTERDAY: "Gestern",
  TODAY: "Heute",
  TOMORROW: "Morgen",
  // stats-modal.tsx
  STATS_TITLE: "Statistiken",
  MONTH: "Monat",
  QUARTER: "Quartal",
  YEAR: "Jahr",
  LIFETIME: "Lebenslang",
  FORECAST: "Prognose",
  FORECAST_DESC: "Anzahl der k\xFCnftig anstehenden Karten",
  SCHEDULED: "Anstehend",
  DAYS: "Tage",
  NUMBER_OF_CARDS: "Anzahl der Karten",
  REVIEWS_PER_DAY: "Durchschnitt: ${avg} Wiederholungen/Tag",
  INTERVALS: "Intervalle",
  INTERVALS_DESC: "Intervalle bis Wiederholungen anstehen",
  COUNT: "Anzahl",
  INTERVALS_SUMMARY: "Durchschnittliches Intervall: ${avg}, L\xE4ngstes Intervall: ${longest}",
  EASES: "Schwierigkeit",
  EASES_SUMMARY: "Durchschnittliche Schwierigkeit: ${avgEase}",
  EASE: "Ease",
  CARD_TYPES: "Kategorisierung",
  CARD_TYPES_DESC: "Verlegte Karten eingeschlossen",
  CARD_TYPE_NEW: "Neu",
  CARD_TYPE_YOUNG: "Jung",
  CARD_TYPE_MATURE: "Ausgereift",
  CARD_TYPES_SUMMARY: "Insgesamt ${totalCardsCount} Karten",
  SEARCH: "Search",
  PREVIOUS: "Previous",
  NEXT: "Next"
};

// src/lang/locale/en.ts
var en_default = {
  // flashcard-modal.tsx
  DECKS: "Decks",
  DUE_CARDS: "Due Cards",
  NEW_CARDS: "New Cards",
  TOTAL_CARDS: "Total Cards",
  BACK: "Back",
  SKIP: "Skip",
  EDIT_CARD: "Edit Card",
  RESET_CARD_PROGRESS: "Reset card's progress",
  HARD: "Hard",
  GOOD: "Good",
  EASY: "Easy",
  SHOW_ANSWER: "Show Answer",
  CARD_PROGRESS_RESET: "Card's progress has been reset.",
  SAVE: "Save",
  CANCEL: "Cancel",
  NO_INPUT: "No input provided.",
  CURRENT_EASE_HELP_TEXT: "Current Ease: ",
  CURRENT_INTERVAL_HELP_TEXT: "Current Interval: ",
  CARD_GENERATED_FROM: "Generated from: ${notePath}",
  // main.ts
  OPEN_NOTE_FOR_REVIEW: "Open a note for review",
  REVIEW_CARDS: "Review flashcards",
  REVIEW_DIFFICULTY_FILE_MENU: "Review: ${difficulty}",
  REVIEW_NOTE_DIFFICULTY_CMD: "Review note as ${difficulty}",
  CRAM_ALL_CARDS: "Select a deck to cram",
  REVIEW_ALL_CARDS: "Review flashcards from all notes",
  REVIEW_CARDS_IN_NOTE: "Review flashcards in this note",
  CRAM_CARDS_IN_NOTE: "Cram flashcards in this note",
  VIEW_STATS: "View statistics",
  OPEN_REVIEW_QUEUE_VIEW: "Open Notes Review Queue in sidebar",
  STATUS_BAR: "Review: ${dueNotesCount} note(s), ${dueFlashcardsCount} card(s) due",
  SYNC_TIME_TAKEN: "Sync took ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "Note is saved under ignored folder (check settings).",
  PLEASE_TAG_NOTE: "Please tag the note appropriately for reviewing (in settings).",
  RESPONSE_RECEIVED: "Response received.",
  NO_DECK_EXISTS: "No deck exists for ${deckName}",
  ALL_CAUGHT_UP: "You're all caught up now :D.",
  // scheduling.ts
  DAYS_STR_IVL: "${interval} day(s)",
  MONTHS_STR_IVL: "${interval} month(s)",
  YEARS_STR_IVL: "${interval} year(s)",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}y",
  // settings.ts
  SETTINGS_HEADER: "Spaced Repetition",
  GROUP_TAGS_FOLDERS: "Tags & Folders",
  GROUP_FLASHCARD_REVIEW: "Flashcard Review",
  GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
  GROUP_DATA_STORAGE: "Storage of Scheduling Data",
  GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
  GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
  GROUP_CONTRIBUTING: "Contributing",
  CHECK_WIKI: 'For more information, check the <a href="${wikiUrl}">wiki</a>.',
  GITHUB_DISCUSSIONS: 'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
  GITHUB_ISSUES: 'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
  GITHUB_SOURCE_CODE: 'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
  CODE_CONTRIBUTION_INFO: '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
  TRANSLATION_CONTRIBUTION_INFO: '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
  FOLDERS_TO_IGNORE: "Folders to ignore",
  FOLDERS_TO_IGNORE_DESC: "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
  OBSIDIAN_INTEGRATION: "Integration into Obsidian",
  FLASHCARDS: "Flashcards",
  FLASHCARD_EASY_LABEL: "Easy Button Text",
  FLASHCARD_GOOD_LABEL: "Good Button Text",
  FLASHCARD_HARD_LABEL: "Hard Button Text",
  FLASHCARD_EASY_DESC: 'Customize the label for the "Easy" Button',
  FLASHCARD_GOOD_DESC: 'Customize the label for the "Good" Button',
  FLASHCARD_HARD_DESC: 'Customize the label for the "Hard" Button',
  REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
  REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
  FLASHCARD_TAGS: "Flashcard tags",
  FLASHCARD_TAGS_DESC: "Enter tags separated by spaces or newlines i.e. #flashcards #deck2 #deck3.",
  CONVERT_FOLDERS_TO_DECKS: "Convert folders to decks and subdecks",
  CONVERT_FOLDERS_TO_DECKS_DESC: "This is an alternative to the Flashcard tags option above.",
  INLINE_SCHEDULING_COMMENTS: "Save scheduling comment on the same line as the flashcard's last line?",
  INLINE_SCHEDULING_COMMENTS_DESC: "Turning this on will make the HTML comments not break list formatting.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Bury sibling cards until the next day",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "Siblings are cards generated from the same card text i.e. cloze deletions",
  SHOW_CARD_CONTEXT: "Show context in cards",
  SHOW_CARD_CONTEXT_DESC: "i.e. Title > Heading 1 > Subheading > ... > Subheading",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC: "Useful to know how far in the future your cards are being pushed.",
  CARD_MODAL_HEIGHT_PERCENT: "Flashcard Height Percentage",
  CARD_MODAL_SIZE_PERCENT_DESC: "Should be set to 100% on mobile or if you have very large images",
  RESET_DEFAULT: "Reset to default",
  CARD_MODAL_WIDTH_PERCENT: "Flashcard Width Percentage",
  RANDOMIZE_CARD_ORDER: "Randomize card order during review?",
  REVIEW_CARD_ORDER_WITHIN_DECK: "Order cards in a deck are displayed during review",
  REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "Sequentially within a deck (All new cards first)",
  REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "Sequentially within a deck (All due cards first)",
  REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Randomly within a deck (All new cards first)",
  REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "Randomly within a deck (All due cards first)",
  REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
  REVIEW_DECK_ORDER: "Order decks are displayed during review",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL: "Sequentially (once all cards in previous deck reviewed)",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM: "Randomly (once all cards in previous deck reviewed)",
  REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
  DISABLE_CLOZE_CARDS: "Disable cloze cards?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "Convert ==highlights== to clozes",
  CONVERT_HIGHLIGHTS_TO_CLOZES_DESC: 'Add/remove the <code>${defaultPattern}</code> from your "Cloze Patterns"',
  CONVERT_BOLD_TEXT_TO_CLOZES: "Convert **bolded text** to clozes",
  CONVERT_BOLD_TEXT_TO_CLOZES_DESC: 'Add/remove the <code>${defaultPattern}</code> from your "Cloze Patterns"',
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "Convert {{curly brackets}} to clozes",
  CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC: 'Add/remove the <code>${defaultPattern}</code> from your "Cloze Patterns"',
  CLOZE_PATTERNS: "Cloze Patterns",
  CLOZE_PATTERNS_DESC: 'Enter cloze patterns separated by newlines. Check the <a href="${docsUrl}">wiki</a> for guidance.',
  INLINE_CARDS_SEPARATOR: "Separator for inline flashcards",
  FIX_SEPARATORS_MANUALLY_WARNING: "Note that after changing this you have to manually edit any flashcards you already have.",
  INLINE_REVERSED_CARDS_SEPARATOR: "Separator for inline reversed flashcards",
  MULTILINE_CARDS_SEPARATOR: "Separator for multiline flashcards",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "Separator for multiline reversed flashcards",
  MULTILINE_CARDS_END_MARKER: "Characters denoting the end of clozes and multiline flashcards",
  NOTES: "Notes",
  NOTE: "Note",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "Tags to review",
  TAGS_TO_REVIEW_DESC: "Enter tags separated by spaces or newlines i.e. #review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "Open a random note for review",
  OPEN_RANDOM_NOTE_DESC: "When you turn this off, notes are ordered by importance (PageRank).",
  AUTO_NEXT_NOTE: "Open next note automatically after a review",
  MAX_N_DAYS_REVIEW_QUEUE: "Maximum number of days to display on note review panel",
  MIN_ONE_DAY: "The number of days must be at least 1.",
  VALID_NUMBER_WARNING: "Please provide a valid number.",
  UI: "User Interface",
  OPEN_IN_TAB: "Open in new tab",
  OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
  SHOW_STATUS_BAR: "Show status bar",
  SHOW_STATUS_BAR_DESC: "Turn this off to hide the flashcard's review status in Obsidian's status bar",
  SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
  SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
  ENABLE_FILE_MENU_REVIEW_OPTIONS: "Enable the review options in the file menu (e.g. Review: Easy, Good, Hard)",
  ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "If you disable the review options in the file menu, you can review your notes using the plugin commands and, if you defined them, the associated command hotkeys.",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "Deck trees should be initially displayed as expanded",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "Turn this off to collapse nested decks in the same card. Useful if you have cards which belong to many decks in the same file.",
  ALGORITHM: "Algorithm",
  CHECK_ALGORITHM_WIKI: 'For more information, check the <a href="${algoUrl}">algorithm details</a>.',
  SM2_OSR_VARIANT: "OSR's variant of SM-2",
  BASE_EASE: "Base ease",
  BASE_EASE_DESC: "minimum = 130, preferrably approximately 250.",
  BASE_EASE_MIN_WARNING: "The base ease must be at least 130.",
  LAPSE_INTERVAL_CHANGE: "Interval change when you review a flashcard/note as hard",
  LAPSE_INTERVAL_CHANGE_DESC: "newInterval = oldInterval * intervalChange / 100.",
  EASY_BONUS: "Easy Bonus",
  EASY_BONUS_DESC: "The easy bonus allows you to set the difference in intervals between answering Good and Easy on a flashcard/note (minimum = 100%).",
  EASY_BONUS_MIN_WARNING: "The easy bonus must be at least 100.",
  LOAD_BALANCE: "Enable load balancer",
  LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
  MAX_INTERVAL: "Maximum interval in days",
  MAX_INTERVAL_DESC: "Allows you to place an upper limit on the interval (default = 100 years).",
  MAX_INTERVAL_MIN_WARNING: "The maximum interval must be at least 1 day.",
  MAX_LINK_CONTRIB: "Maximum link contribution",
  MAX_LINK_CONTRIB_DESC: "Maximum contribution of the weighted ease of linked notes to the initial ease.",
  LOGGING: "Logging",
  DISPLAY_SCHEDULING_DEBUG_INFO: "Show the scheduler's debugging information on the developer console",
  DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
  SCHEDULING: "Scheduling",
  EXPERIMENTAL: "Experimental",
  HELP: "Help",
  STORE_IN_NOTES: "In the notes",
  // sidebar.ts
  NOTES_REVIEW_QUEUE: "Notes Review Queue",
  CLOSE: "Close",
  NEW: "New",
  YESTERDAY: "Yesterday",
  TODAY: "Today",
  TOMORROW: "Tomorrow",
  // stats-modal.tsx
  STATS_TITLE: "Statistics",
  MONTH: "Month",
  QUARTER: "Quarter",
  YEAR: "Year",
  LIFETIME: "Lifetime",
  FORECAST: "Forecast",
  FORECAST_DESC: "The number of cards due in the future",
  SCHEDULED: "Scheduled",
  DAYS: "Days",
  NUMBER_OF_CARDS: "Number of cards",
  REVIEWS_PER_DAY: "Average: ${avg} reviews/day",
  INTERVALS: "Intervals",
  INTERVALS_DESC: "Delays until reviews are shown again",
  COUNT: "Count",
  INTERVALS_SUMMARY: "Average interval: ${avg}, Longest interval: ${longest}",
  EASES: "Eases",
  EASES_SUMMARY: "Average ease: ${avgEase}",
  EASE: "Ease",
  CARD_TYPES: "Card Types",
  CARD_TYPES_DESC: "This includes buried cards as well, if any",
  CARD_TYPE_NEW: "New",
  CARD_TYPE_YOUNG: "Young",
  CARD_TYPE_MATURE: "Mature",
  CARD_TYPES_SUMMARY: "Total cards: ${totalCardsCount}",
  SEARCH: "Search",
  PREVIOUS: "Previous",
  NEXT: "Next"
};

// src/lang/locale/en-gb.ts
var en_gb_default = {};

// src/lang/locale/es.ts
var es_default = {
  // flashcard-modal.tsx
  DECKS: "Mazos",
  DUE_CARDS: "Tarjetas Vencidas",
  NEW_CARDS: "Tarjetas Nuevas",
  TOTAL_CARDS: "Tarjetas Totales",
  BACK: "Atr\xE1s",
  SKIP: "Saltar",
  EDIT_CARD: "Editar Tarjeta",
  RESET_CARD_PROGRESS: "Reiniciar progreso de la tarjeta",
  HARD: "Dif\xEDcil",
  GOOD: "Bien",
  EASY: "F\xE1cil",
  SHOW_ANSWER: "Mostrar Respuesta",
  CARD_PROGRESS_RESET: "El progreso de la tarjeta se ha reiniciado.",
  SAVE: "Guardar",
  CANCEL: "Cancelar",
  NO_INPUT: "Se ha prove\xEDdo entrada.",
  CURRENT_EASE_HELP_TEXT: "Facilidad Actual: ",
  CURRENT_INTERVAL_HELP_TEXT: "Intervalo Actual: ",
  CARD_GENERATED_FROM: "Generado Desde: ${notePath}",
  // main.ts
  OPEN_NOTE_FOR_REVIEW: "Abrir nota para revisi\xF3n",
  REVIEW_CARDS: "Revisar Tarjetas",
  REVIEW_DIFFICULTY_FILE_MENU: "Revisar: ${difficulty}",
  REVIEW_NOTE_DIFFICULTY_CMD: "Revisar nota como ${difficulty}",
  CRAM_ALL_CARDS: "Selecciona un mazo a memorizar",
  REVIEW_ALL_CARDS: "Revisar tarjetas de todas las notas",
  REVIEW_CARDS_IN_NOTE: "Revisar tarjetas en esta nota",
  CRAM_CARDS_IN_NOTE: "Memorizar tarjetas en esta nota",
  VIEW_STATS: "Ver estad\xEDsticas",
  OPEN_REVIEW_QUEUE_VIEW: "Open Notes Review Queue in sidebar",
  STATUS_BAR: "Revisar: ${dueNotesCount} nota(s), ${dueFlashcardsCount} tarjetas vencidas",
  SYNC_TIME_TAKEN: "La sincronizaci\xF3n tom\xF3 ${t} milisegundos",
  NOTE_IN_IGNORED_FOLDER: "La nota est\xE1 guardada en un directorio ignorado (revisa los ajustes).",
  PLEASE_TAG_NOTE: "Por favor etiquete apropiadamente la nota para revisi\xF3n (en los ajustes).",
  RESPONSE_RECEIVED: "Respuesta Recibida",
  NO_DECK_EXISTS: "No existen mazos para: ${deckName}",
  ALL_CAUGHT_UP: "\xA1Est\xE1s al d\xEDa! \u{1F603}",
  // scheduling.ts
  DAYS_STR_IVL: "${interval} d\xEDa(s)",
  MONTHS_STR_IVL: "${interval} mes(es)",
  YEARS_STR_IVL: "${interval} a\xF1o(s)",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}a",
  // settings.ts
  SETTINGS_HEADER: "Extensi\xF3n de Repetici\xF3n Espaciada",
  GROUP_TAGS_FOLDERS: "Tags & Folders",
  GROUP_FLASHCARD_REVIEW: "Flashcard Review",
  GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
  GROUP_DATA_STORAGE: "Storage of Scheduling Data",
  GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
  GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
  GROUP_CONTRIBUTING: "Contributing",
  CHECK_WIKI: 'Para m\xE1s informaci\xF3n revisa la <a href="${wikiUrl}">wiki</a>.',
  GITHUB_DISCUSSIONS: 'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
  GITHUB_ISSUES: 'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
  GITHUB_SOURCE_CODE: 'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
  CODE_CONTRIBUTION_INFO: '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
  TRANSLATION_CONTRIBUTION_INFO: '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
  FOLDERS_TO_IGNORE: "Directorios a ignorar",
  FOLDERS_TO_IGNORE_DESC: "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
  OBSIDIAN_INTEGRATION: "Integration into Obsidian",
  FLASHCARDS: "Tarjetas de Memorizaci\xF3n",
  FLASHCARD_EASY_LABEL: "Texto del bot\xF3n: F\xE1cil",
  FLASHCARD_GOOD_LABEL: "Texto del bot\xF3n: Bien",
  FLASHCARD_HARD_LABEL: "Texto del bot\xF3n: Dif\xEDcil",
  FLASHCARD_EASY_DESC: "Personalize la etiqueta para el bot\xF3n: F\xE1cil",
  FLASHCARD_GOOD_DESC: "Personalize la etiqueta para el bot\xF3n: Bien",
  FLASHCARD_HARD_DESC: "Personalize la etiqueta para el bot\xF3n: Dif\xEDcil",
  REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
  REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
  FLASHCARD_TAGS: "Etiquetas de las Tarjetas de Memorizaci\xF3n",
  FLASHCARD_TAGS_DESC: "Escriba las etiquetas separadas por espacios o saltos de l\xEDnea, por ejemplo, #memorizar #mazo2 #mazo3",
  CONVERT_FOLDERS_TO_DECKS: "\xBFConvertir directorios a mazos y submazos?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "Esta es una opci\xF3n alternativa a las etiquetas de las Tarjetas de Memorizaci\xF3n.",
  INLINE_SCHEDULING_COMMENTS: "\xBFGuardar el comentario para programaci\xF3n de las tarjetas en la \xFAltima l\xEDnea?",
  INLINE_SCHEDULING_COMMENTS_DESC: "Activar esto har\xE1 que los comentarios HTML no rompan el formato de las listas.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "\xBFEnterrar tarjetas hermanas hasta el siguiente d\xEDa?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "Los hermanos son tarjetas generadas del mismo texto de la tarjeta, por ejemplo, deletreos de huecos (cloze deletions en ingl\xE9s)",
  SHOW_CARD_CONTEXT: "\xBFMostrar contexto en las tarjetas?",
  SHOW_CARD_CONTEXT_DESC: "Por Ejemplo: T\xEDtulo > Cabecera > Sub-Cabecera > ... > Sub-Cabecera",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC: "Useful to know how far in the future your cards are being pushed.",
  CARD_MODAL_HEIGHT_PERCENT: "Porcentaje de la altura de las tarjetas de memoria",
  CARD_MODAL_SIZE_PERCENT_DESC: "Deber\xEDa ser establecido en 100% si tienes im\xE1genes grandes",
  RESET_DEFAULT: "Reiniciar a la configuraci\xF3n por defecto",
  CARD_MODAL_WIDTH_PERCENT: "Porcentaje del ancho de las tarjetas de memoria",
  RANDOMIZE_CARD_ORDER: "\xBFAleatorizar el orden de las tarjetas para revisi\xF3n?",
  REVIEW_CARD_ORDER_WITHIN_DECK: "Order cards in a deck are displayed during review",
  REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "Sequentially within a deck (All new cards first)",
  REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "Sequentially within a deck (All due cards first)",
  REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Randomly within a deck (All new cards first)",
  REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "Randomly within a deck (All due cards first)",
  REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
  REVIEW_DECK_ORDER: "Order decks are displayed during review",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL: "Sequentially (once all cards in previous deck reviewed)",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM: "Randomly (once all cards in previous deck reviewed)",
  REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
  DISABLE_CLOZE_CARDS: "\xBFDeshabilitar deletreo de huecos en las tarjetas?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "\xBFConvertir ==resaltados== a deletreo de huecos?",
  CONVERT_HIGHLIGHTS_TO_CLOZES_DESC: 'A\xF1adir/eliminar el <code>${defaultPattern}</code> de tus "Patrones de Deletreo de Huecos"',
  CONVERT_BOLD_TEXT_TO_CLOZES: "\xBFConvertir **texto en negrita** a deletreo de huecos?",
  CONVERT_BOLD_TEXT_TO_CLOZES_DESC: 'A\xF1adir/eliminar el <code>${defaultPattern}</code> de tus "Patrones de Deletreo de Huecos"',
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "\xBFConvertir {{llaves rizadas}} a deletreo de huecos?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC: 'A\xF1adir/eliminar el <code>${defaultPattern}</code> de tus "Patrones de Deletreo de Huecos"',
  CLOZE_PATTERNS: "Patrones de deletreo de huecos",
  CLOZE_PATTERNS_DESC: 'Escriba los patrones de deletreo de huecos separados por saltos de l\xEDnea. . Check the <a href="${docsUrl}">wiki</a> for guidance.',
  INLINE_CARDS_SEPARATOR: "Separador de tarjetas de memorizaci\xF3n en l\xEDnea",
  FIX_SEPARATORS_MANUALLY_WARNING: "Note que despu\xE9s de cambiar este ajuste, tendr\xE1 que cambiar manualmente todas las notas que tenga.",
  INLINE_REVERSED_CARDS_SEPARATOR: "Separador de tarjetas de memorizaci\xF3n para tarjetas de notas invertidas",
  MULTILINE_CARDS_SEPARATOR: "Separador para tarjetas de memorizaci\xF3n multil\xEDnea",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "Separador para tarjetas de memorizaci\xF3n multil\xEDnea invertidas",
  MULTILINE_CARDS_END_MARKER: "Caracteres que denotan el fin de los clozes y tarjetas did\xE1cticas de varias l\xEDneas",
  NOTES: "Notes",
  NOTE: "Note",
  REVIEW_PANE_ON_STARTUP: "Activar panel de revisi\xF3n de notas al arrancar",
  TAGS_TO_REVIEW: "Etiquetas a revisar",
  TAGS_TO_REVIEW_DESC: "Escriba las etiquetas separadas por espacios o saltos de l\xEDneas, por ejemplo, #revisi\xF3n #etiqueta2 #etiqueta3.",
  OPEN_RANDOM_NOTE: "Abrir una nota al azar para revisar",
  OPEN_RANDOM_NOTE_DESC: "Cuando deshabilita esto, las notas son ordenadas por importancia (Algoritmo PageRank).",
  AUTO_NEXT_NOTE: "Abrir la siguiente nota autom\xE1ticamente despu\xE9s de una revisi\xF3n",
  ENABLE_FILE_MENU_REVIEW_OPTIONS: "Habilita las opciones de revisi\xF3n en el men\xFA Archivo (por ejemplo: Revisar: F\xE1cil, Bien, Dif\xEDcil)",
  ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "Si desactivas las opciones de revisi\xF3n en el men\xFA Archivo, puedes revisar tus notas usando los comandos del plugin y, si los definiste, las teclas r\xE1pidas asociadas.",
  MAX_N_DAYS_REVIEW_QUEUE: "N\xFAmero m\xE1ximo de d\xEDas a mostrar en el panel derecho.",
  MIN_ONE_DAY: "El n\xFAmero de d\xEDas debe ser al menos uno.",
  VALID_NUMBER_WARNING: "Por favor especifique un n\xFAmero v\xE1lido.",
  UI: "User Interface",
  OPEN_IN_TAB: "Open in new tab",
  OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
  SHOW_STATUS_BAR: "Show status bar",
  SHOW_STATUS_BAR_DESC: "Turn this off to hide the flashcard's review status in Obsidian's status bar",
  SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
  SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "Los \xE1rboles de mazos deber\xEDan ser expandidos al inicio.",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "Desactiva esto para contraer mazos anidados en la misma tarjeta. \xDAtil si tienes tarjetas que pertenecen a muchos mazos en el mismo archivo.",
  ALGORITHM: "Algoritmo",
  CHECK_ALGORITHM_WIKI: 'Para m\xE1s informaci\xF3n, revisa la <a href="${algoUrl}">implementaci\xF3n del algoritmo</a>.',
  SM2_OSR_VARIANT: "OSR's variant of SM-2",
  BASE_EASE: "Base ease",
  BASE_EASE_DESC: "El m\xEDnimo es 130, es preferible que est\xE9 aproximado a 250.",
  BASE_EASE_MIN_WARNING: "La facilidad base de las tarjetas debe ser al menos 130.",
  LAPSE_INTERVAL_CHANGE: "El intervalo cambiar\xE1 cuando se revise una tarjeta o nota como Dif\xEDcil.",
  LAPSE_INTERVAL_CHANGE_DESC: "NuevoInterval = ViejoIntervalo * CambioDeIntervalo / 100.",
  EASY_BONUS: "Bonificaci\xF3n para F\xE1cil",
  EASY_BONUS_DESC: "La bonificaci\xF3n para F\xE1cil te permite establecer la diferencia entre intervalos al responder Bien y F\xE1cil en las tarjetas o notas (m\xEDnimo = 100%).",
  EASY_BONUS_MIN_WARNING: "El bono de facilidad debe ser al menos 100.",
  LOAD_BALANCE: "Enable load balancer",
  LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
  MAX_INTERVAL: "Intervalo m\xE1ximo en d\xEDas",
  MAX_INTERVAL_DESC: "Te permite establecer un l\xEDmite mayor en el intervalo (por defecto es de 100 a\xF1os).",
  MAX_INTERVAL_MIN_WARNING: "El intervalo m\xE1ximo debe ser de al menos un d\xEDa.",
  MAX_LINK_CONTRIB: "Contribuci\xF3n m\xE1xima de las notas vinculadas.",
  MAX_LINK_CONTRIB_DESC: "Contribuci\xF3n m\xE1xima de la facilidad ponderada de las notas vinculadas a la facilidad inicial.",
  LOGGING: "Registro",
  DISPLAY_SCHEDULING_DEBUG_INFO: "\xBFMostrar informaci\xF3n de depuraci\xF3n en la consola de desarrollador",
  DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
  SCHEDULING: "Scheduling",
  EXPERIMENTAL: "Experimental",
  HELP: "Help",
  STORE_IN_NOTES: "In the notes",
  // sidebar.ts
  NOTES_REVIEW_QUEUE: "Cola de notas a revisar",
  CLOSE: "Cerrar",
  NEW: "Nuevo",
  YESTERDAY: "Ayer",
  TODAY: "Hoy",
  TOMORROW: "Ma\xF1ana",
  // stats-modal.tsx
  STATS_TITLE: "Estad\xEDsticas",
  MONTH: "Mes",
  QUARTER: "Trimestre o Cuatrimestre",
  // En Inglés: Quarter.
  YEAR: "A\xF1o",
  LIFETIME: "Tiempo de Vida",
  FORECAST: "Pron\xF3stico",
  FORECAST_DESC: "El n\xFAmero de tarjetas vencidas en el futuro",
  SCHEDULED: "Programado",
  DAYS: "D\xEDas",
  NUMBER_OF_CARDS: "N\xFAmero de tarjetas",
  REVIEWS_PER_DAY: "Carga: ${avg} Revisiones por d\xEDa",
  INTERVALS: "Intervalos",
  INTERVALS_DESC: "Retrasos hasta que las revisiones se muestren de nuevo",
  COUNT: "Conteo",
  INTERVALS_SUMMARY: "Intervalo de carga: ${avg}, Intervalo mayor: ${longest}",
  EASES: "Facilidad",
  EASES_SUMMARY: "Carga de Facilidad: ${avgEase}",
  EASE: "Ease",
  CARD_TYPES: "Tipos de tarjetas",
  CARD_TYPES_DESC: "Esto incluye tambi\xE9n a las tarjetas enterradas, si las hay",
  CARD_TYPE_NEW: "Nueva",
  CARD_TYPE_YOUNG: "Joven",
  CARD_TYPE_MATURE: "Madura",
  CARD_TYPES_SUMMARY: "Tarjetas Totales: ${totalCardsCount}",
  SEARCH: "Search",
  PREVIOUS: "Previous",
  NEXT: "Next"
};

// src/lang/locale/fr.ts
var fr_default = {
  // flashcard-modal.tsx
  DECKS: "Paquets",
  DUE_CARDS: "Cartes dues",
  NEW_CARDS: "Nouvelles cartes",
  TOTAL_CARDS: "Total de cartes",
  BACK: "Pr\xE9c\xE9dent",
  SKIP: "Sauter",
  EDIT_CARD: "Modifier la carte",
  RESET_CARD_PROGRESS: "Remettre \xE0 z\xE9ro le niveau de cette carte",
  HARD: "Difficile",
  GOOD: "Correct",
  EASY: "Facile",
  SHOW_ANSWER: "Montrer la r\xE9ponse",
  CARD_PROGRESS_RESET: "Le niveau de la carte a \xE9t\xE9 remis \xE0 z\xE9ro.",
  SAVE: "Sauvegarder",
  CANCEL: "Annuler",
  NO_INPUT: "Pas de contenu.",
  CURRENT_EASE_HELP_TEXT: "Facilit\xE9 actuelle : ",
  CURRENT_INTERVAL_HELP_TEXT: "Intervalle actuel : ",
  CARD_GENERATED_FROM: "G\xE9n\xE9r\xE9 depuis : ${notePath}",
  // main.ts
  OPEN_NOTE_FOR_REVIEW: "Ouvrir une note \xE0 apprendre",
  REVIEW_CARDS: "Apprendre les flashcards",
  REVIEW_DIFFICULTY_FILE_MENU: "Apprentissage : ${difficulty}",
  REVIEW_NOTE_DIFFICULTY_CMD: "Difficult\xE9 de la r\xE9vision : ${difficulty}",
  CRAM_ALL_CARDS: "Choisir un deck \xE0 r\xE9viser",
  REVIEW_ALL_CARDS: "Apprendre les flashcards dans toutes les notes",
  REVIEW_CARDS_IN_NOTE: "Apprendre les flashcards dans cette note",
  CRAM_CARDS_IN_NOTE: "R\xE9viser les flashcards dans cette note",
  VIEW_STATS: "Voir les statistiques",
  OPEN_REVIEW_QUEUE_VIEW: "Ouvrir la file d'attente des notes \xE0 apprendre dans la barre verticale",
  STATUS_BAR: "Apprentissage : ${dueNotesCount} note(s), ${dueFlashcardsCount} carte(s) dues",
  SYNC_TIME_TAKEN: "Synchronis\xE9 en ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "La note est dans un dossier ignor\xE9 (voir param\xE8tres).",
  PLEASE_TAG_NOTE: "Ajoutez le bon tag \xE0 la note pour l'apprendre (dans les param\xE8tres).",
  RESPONSE_RECEIVED: "R\xE9ponse enregistr\xE9e.",
  NO_DECK_EXISTS: "Pas de paquet sous le nom ${deckName}",
  ALL_CAUGHT_UP: "Bravo, vous \xEAtes \xE0 jour !",
  // scheduling.ts
  DAYS_STR_IVL: "${interval} jour(s)",
  MONTHS_STR_IVL: "${interval} mois(s)",
  YEARS_STR_IVL: "${interval} an(s)",
  DAYS_STR_IVL_MOBILE: "${interval}j",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}a",
  // settings.ts
  SETTINGS_HEADER: "Spaced Repetition",
  GROUP_TAGS_FOLDERS: "Tags & Dossiers",
  GROUP_FLASHCARD_REVIEW: "Apprentissage des flashcards",
  GROUP_FLASHCARD_SEPARATORS: "S\xE9parateurs de flashcards",
  GROUP_DATA_STORAGE: "Stockage des informations de planification",
  GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
  GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
  GROUP_CONTRIBUTING: "Contribuer",
  CHECK_WIKI: 'Pour plus d\'informations, visitez le <a href="${wikiUrl}">wiki</a>.',
  GITHUB_DISCUSSIONS: 'Visitez les <a href="${discussionsUrl}">discussions</a> pour des questions-r\xE9ponses, des retours ou une discussion g\xE9n\xE9raliste.',
  GITHUB_ISSUES: 'Cr\xE9ez un ticket <a href="${issuesUrl}">sur GitHub</a> si vous trouvez un bug ou voulez demander une fonctionnalit\xE9.',
  GITHUB_SOURCE_CODE: 'Code source du projet disponible sur <a href="${githubProjectUrl}">GitHub</a>',
  CODE_CONTRIBUTION_INFO: 'Information sur les <a href="${codeContributionUrl}">contributions au code</a>',
  TRANSLATION_CONTRIBUTION_INFO: 'Informations sur la <a href="${translationContributionUrl}">traduction du plugin</a> dans votre langue',
  FOLDERS_TO_IGNORE: "Dossiers \xE0 ignorer",
  FOLDERS_TO_IGNORE_DESC: "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
  OBSIDIAN_INTEGRATION: "Integration into Obsidian",
  FLASHCARDS: "Flashcards",
  FLASHCARD_EASY_LABEL: "Bouton Facile",
  FLASHCARD_GOOD_LABEL: "Bouton Correct",
  FLASHCARD_HARD_LABEL: "Bouton Difficile",
  FLASHCARD_EASY_DESC: "Changez le texte du bouton Facile",
  FLASHCARD_GOOD_DESC: "Changez le texte du bouton Correct",
  FLASHCARD_HARD_DESC: "Changez le texte du bouton Difficile",
  REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
  REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
  FLASHCARD_TAGS: "Tags des flashcards",
  FLASHCARD_TAGS_DESC: "Entrez les tags s\xE9par\xE9s par un espace ou une ligne i.e. #flashcards #paquet2 #paquet3.",
  CONVERT_FOLDERS_TO_DECKS: "Convertir les dossiers en paquets et sous-paquets ?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "Ceci est une alternative aux tags de flashcards pr\xE9sent\xE9s ci-dessus.",
  INLINE_SCHEDULING_COMMENTS: "Sauvegarder le commentaire de planification dans la derni\xE8re ligne de la flashcard ?",
  INLINE_SCHEDULING_COMMENTS_DESC: "Activer ceci emp\xEAche les commentaires HTML de casser la mise en page des listes.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Enterrer les cartes s\u0153urs jusqu'au lendemain ?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "Les cartes s\u0153urs sont les cartes g\xE9n\xE9r\xE9es depuis le m\xEAme texte, par exemple pour les textes \xE0 trous",
  SHOW_CARD_CONTEXT: "Montrer le contexte dans les cartes ?",
  SHOW_CARD_CONTEXT_DESC: "ex. Titre de la note > Titre 1 > Sous-titre > ... > Sous-titre",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC: "Useful to know how far in the future your cards are being pushed.",
  CARD_MODAL_HEIGHT_PERCENT: "Pourcentage de hauteur de la flashcard",
  CARD_MODAL_SIZE_PERCENT_DESC: "Devrait \xEAtre 100% sur mobile ou en cas de grandes images",
  RESET_DEFAULT: "R\xE9initialiser les param\xE8tres",
  CARD_MODAL_WIDTH_PERCENT: "Pourcentage de largeur de la flashcard",
  RANDOMIZE_CARD_ORDER: "Apprendre les cartes dans un ordre al\xE9atoire ?",
  REVIEW_CARD_ORDER_WITHIN_DECK: "Ordre d'affichage des cartes d'un paquet pendant les r\xE9visions",
  REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "Dans l'ordre du paquet (Nouvelles cartes d'abord)",
  REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "Dans l'ordre du paquet (Cartes dues d'abord)",
  REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Al\xE9atoirement dans le paquet (Nouvelles cartes d'abord)",
  REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "Al\xE9atoirement dans le paquet (Cartes dues d'abord)",
  REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Carte au hasard dans un paquet au hasard",
  REVIEW_DECK_ORDER: "Ordre d'affichage des paquets pendant les r\xE9visions",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL: "S\xE9quentiel (quand toutes les cartes du paquet pr\xE9c\xE9dent sont apprises)",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM: "Al\xE9atoire (quand toutes les cartes du paquet pr\xE9c\xE9dent sont apprises)",
  REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Carte au hasard dans un paquet au hasard",
  DISABLE_CLOZE_CARDS: "D\xE9sactiver les textes \xE0 trous ?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "Convertir ==soulignages== en trous ?",
  CONVERT_HIGHLIGHTS_TO_CLOZES_DESC: 'Ajouter/supprimer le <code>${defaultPattern}</code> de vos "Cloze Patterns"',
  CONVERT_BOLD_TEXT_TO_CLOZES: "Convertir **gras** en trous ?",
  CONVERT_BOLD_TEXT_TO_CLOZES_DESC: 'Ajouter/supprimer le <code>${defaultPattern}</code> de vos "Cloze Patterns"',
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "Convertir {{crochets}} en trous ?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC: 'Ajouter/supprimer le <code>${defaultPattern}</code> de vos "Cloze Patterns"',
  CLOZE_PATTERNS: "Cloze Patterns",
  CLOZE_PATTERNS_DESC: 'Enter cloze patterns separated by newlines. Check the <a href="${docsUrl}">wiki</a> for guidance.',
  INLINE_CARDS_SEPARATOR: "S\xE9parateur pour flashcards en une ligne",
  FIX_SEPARATORS_MANUALLY_WARNING: "Apr\xE8s avoir chang\xE9 ce r\xE9glage, vous devrez manuellement mettre \xE0 jour toutes vos flashcards.",
  INLINE_REVERSED_CARDS_SEPARATOR: "S\xE9parateur pour flashcards invers\xE9es en une ligne",
  MULTILINE_CARDS_SEPARATOR: "S\xE9parateur pour flashcards en plusieurs lignes",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "S\xE9parateur pour flashcards invers\xE9es en plusieurs lignes",
  MULTILINE_CARDS_END_MARKER: "Caract\xE8res de fin de textes \xE0 trous ou de flashcards en plusieurs lignes",
  NOTES: "Notes",
  NOTE: "Note",
  REVIEW_PANE_ON_STARTUP: "Montrer le module d'apprentissage des notes au d\xE9marrage",
  TAGS_TO_REVIEW: "Tags \xE0 apprendre",
  TAGS_TO_REVIEW_DESC: "Entrez les tags s\xE9par\xE9s par un espace ou une ligne i.e. #review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "Ouvrir une note \xE0 apprendre au hasard",
  OPEN_RANDOM_NOTE_DESC: "Si vous d\xE9sactivez cette option, les notes sont tri\xE9es par importance (PageRank).",
  AUTO_NEXT_NOTE: "Ouvrir la prochaine note automatiquement apr\xE8s un apprentissage",
  MAX_N_DAYS_REVIEW_QUEUE: "Jours maximum affich\xE9s dans la barre de droite",
  MIN_ONE_DAY: "Le nombre de jours doit \xEAtre au moins 1.",
  VALID_NUMBER_WARNING: "Entrez un nombre valide.",
  UI: "User Interface",
  OPEN_IN_TAB: "Open in new tab",
  OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
  SHOW_STATUS_BAR: "Show status bar",
  SHOW_STATUS_BAR_DESC: "Turn this off to hide the flashcard's review status in Obsidian's status bar",
  SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
  SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
  ENABLE_FILE_MENU_REVIEW_OPTIONS: "Enable the review options in the file menu (e.g. Review: Easy, Good, Hard)",
  ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "If you disable the review options in the file menu, you can review your notes using the plugin commands and, if you defined them, the associated command hotkeys.",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "Les dossiers de paquets devraient initialement tous \xEAtre ouverts",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "D\xE9sactivez pour r\xE9duire les paquets dans la m\xEAme carte. Ce r\xE9glage est utile si vous avez des cartes qui appartiennent \xE0 beaucoup de paquets \xE0 la fois.",
  ALGORITHM: "Algorithme",
  CHECK_ALGORITHM_WIKI: `Pour en savoir plus, lisez l'<a href="\${algoUrl}">impl\xE9mentation de l'algorithme</a>.`,
  SM2_OSR_VARIANT: "OSR's variant of SM-2",
  BASE_EASE: "Facilit\xE9 de base",
  BASE_EASE_DESC: "minimum = 130, recommand\xE9 = vers 250.",
  BASE_EASE_MIN_WARNING: "La facilit\xE9 de base doit \xEAtre sup\xE9rieure \xE0 130.",
  LAPSE_INTERVAL_CHANGE: "Changement d'intervalle quand vous indiquez qu'une flashcard/note a \xE9t\xE9 difficile",
  LAPSE_INTERVAL_CHANGE_DESC: "nouvelIntervalle = ancienIntervalle * changementIntervalle / 100.",
  EASY_BONUS: "Bonus Facile",
  EASY_BONUS_DESC: "Le bonus Facile vous permet d'augmenter l'intervalle entre une r\xE9ponse Correct et une r\xE9ponse Facile sur une flashcard/note (minimum = 100%).",
  EASY_BONUS_MIN_WARNING: "Le bonus Facile doit \xEAtre au moins 100.",
  LOAD_BALANCE: "Enable load balancer",
  LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
  MAX_INTERVAL: "Intervalle maximum (en jours)",
  MAX_INTERVAL_DESC: "Vous permet de mettre une limite maximale sur l'intervalle (par d\xE9faut, 100 ans).",
  MAX_INTERVAL_MIN_WARNING: "L'intervalle maximum doit \xEAtre au moins 1 jour.",
  MAX_LINK_CONTRIB: "Contribution maximum des liens",
  MAX_LINK_CONTRIB_DESC: "Contribution maximum de la facilit\xE9 pond\xE9r\xE9e des notes li\xE9es \xE0 la facilit\xE9 initiale.",
  LOGGING: "Logging",
  DISPLAY_SCHEDULING_DEBUG_INFO: "Afficher les informations de d\xE9bogage dans la console de d\xE9veloppement",
  DISPLAY_PARSER_DEBUG_INFO: "Afficher les informations de d\xE9bogage pour le parser dans la console de d\xE9veloppement",
  SCHEDULING: "Scheduling",
  EXPERIMENTAL: "Experimental",
  HELP: "Help",
  STORE_IN_NOTES: "In the notes",
  // sidebar.ts
  NOTES_REVIEW_QUEUE: "Cartes \xE0 apprendre",
  CLOSE: "Fermer",
  NEW: "Nouveau",
  YESTERDAY: "Hier",
  TODAY: "Aujourd'hui",
  TOMORROW: "Demain",
  // stats-modal.tsx
  STATS_TITLE: "Statistiques",
  MONTH: "Mois",
  QUARTER: "Trimestre",
  YEAR: "Ann\xE9e",
  LIFETIME: "Toujours",
  FORECAST: "Pr\xE9visions",
  FORECAST_DESC: "Le nombre de cartes dues dans le futur",
  SCHEDULED: "Planifi\xE9",
  DAYS: "Jours",
  NUMBER_OF_CARDS: "Nombre de cartes",
  REVIEWS_PER_DAY: "Moyenne : ${avg} apprentissages / jour",
  INTERVALS: "Intervalles",
  INTERVALS_DESC: "Dur\xE9e avant de remontrer une carte",
  COUNT: "Total",
  INTERVALS_SUMMARY: "Intervalle moyen : ${avg}. Intervalle maximum: ${longest}",
  EASES: "Facilit\xE9",
  EASES_SUMMARY: "Facilit\xE9 moyenne : ${avgEase}",
  EASE: "Ease",
  CARD_TYPES: "Types de cartes",
  CARD_TYPES_DESC: "Ceci inclut les cartes enterr\xE9es, s'il y en a",
  CARD_TYPE_NEW: "Nouvelles",
  CARD_TYPE_YOUNG: "En cours d'apprentissage",
  CARD_TYPE_MATURE: "Matures",
  CARD_TYPES_SUMMARY: "Total de cartes : ${totalCardsCount}",
  SEARCH: "Search",
  PREVIOUS: "Previous",
  NEXT: "Next"
};

// src/lang/locale/hi.ts
var hi_default = {};

// src/lang/locale/id.ts
var id_default = {};

// src/lang/locale/it.ts
var it_default = {
  // flashcard-modal.tsx
  DECKS: "Mazzi",
  DUE_CARDS: "Schede da fare",
  NEW_CARDS: "Schede nuove",
  TOTAL_CARDS: "Schede totali",
  BACK: "Indietro",
  SKIP: "Salta",
  EDIT_CARD: "Modifica scheda",
  RESET_CARD_PROGRESS: "Ripristina i progressi della scheda",
  HARD: "Difficile",
  GOOD: "Buono",
  EASY: "Facile",
  SHOW_ANSWER: "Mostra risposta",
  CARD_PROGRESS_RESET: "I progressi della scheda sono stati ripristinati",
  SAVE: "Salva",
  CANCEL: "Cancella",
  NO_INPUT: "Non \xE8 stato provvisto alcun input",
  CURRENT_EASE_HELP_TEXT: "Difficolt\xE0 attuale: ",
  CURRENT_INTERVAL_HELP_TEXT: "Intervallo attuale: ",
  CARD_GENERATED_FROM: "Generato da: ${notePath}",
  // main.ts
  OPEN_NOTE_FOR_REVIEW: "Apri una nota per rivisita",
  REVIEW_CARDS: "Rivisita schede",
  REVIEW_DIFFICULTY_FILE_MENU: "Rivisita: ${difficulty}",
  REVIEW_NOTE_DIFFICULTY_CMD: "Revisita note come ${difficulty}",
  CRAM_ALL_CARDS: "Seleziona un mazzo da memorizzare",
  REVIEW_ALL_CARDS: "Seleziona schede da rivedere",
  REVIEW_CARDS_IN_NOTE: "Rivedi schede in questa nota",
  CRAM_CARDS_IN_NOTE: "Memorizza schede in questa nota",
  VIEW_STATS: "Vedi statistiche",
  OPEN_REVIEW_QUEUE_VIEW: "Open Notes Review Queue in sidebar",
  STATUS_BAR: "Da rivedere: ${dueNotesCount} scheda/e, ${dueFlashcardsCount} schede in ritardo",
  SYNC_TIME_TAKEN: "Sincronizzato in ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "La nota \xE8 salvata in una cartella ignorata (rivedi le impostazioni).",
  PLEASE_TAG_NOTE: "Per favore etichetta la nota appropriatamente per la revisione (nelle impostazioni).",
  RESPONSE_RECEIVED: "Risposta ricevuta.",
  NO_DECK_EXISTS: "Non esistono mazzi per ${deckName}",
  ALL_CAUGHT_UP: "Sei al passo! :D.",
  // scheduling.ts
  DAYS_STR_IVL: "${interval} giorno/i",
  MONTHS_STR_IVL: "${interval} mese/i",
  YEARS_STR_IVL: "${interval} anno/i",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}y",
  // settings.ts
  SETTINGS_HEADER: "Plugin per ripetizione spaziata",
  GROUP_TAGS_FOLDERS: "Tags & Folders",
  GROUP_FLASHCARD_REVIEW: "Flashcard Review",
  GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
  GROUP_DATA_STORAGE: "Storage of Scheduling Data",
  GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
  GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
  GROUP_CONTRIBUTING: "Contributing",
  CHECK_WIKI: 'Per maggiori informazioni, rivolgersi alla <a href="${wikiUrl}">wiki</a>.',
  GITHUB_DISCUSSIONS: 'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
  GITHUB_ISSUES: 'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
  GITHUB_SOURCE_CODE: 'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
  CODE_CONTRIBUTION_INFO: '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
  TRANSLATION_CONTRIBUTION_INFO: '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
  FOLDERS_TO_IGNORE: "Cartelle da ignorare",
  FOLDERS_TO_IGNORE_DESC: "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
  OBSIDIAN_INTEGRATION: "Integration into Obsidian",
  FLASHCARDS: "Schede",
  FLASHCARD_EASY_LABEL: "Testo del bottone facile",
  FLASHCARD_GOOD_LABEL: "Testo del bottone buono",
  FLASHCARD_HARD_LABEL: "Testo del bottone difficile",
  FLASHCARD_EASY_DESC: 'Personalizza il testo per il pulsante "Facile"',
  FLASHCARD_GOOD_DESC: 'Personalizza il testo per il pulsante "Buono"',
  FLASHCARD_HARD_DESC: 'Personalizza il testo per il pulsante "Difficile"',
  REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
  REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
  FLASHCARD_TAGS: "Etichette delle schede",
  FLASHCARD_TAGS_DESC: "Inserire etichette separate da spazi o a capi, per esempio #flashcards #deck2 #deck3.",
  CONVERT_FOLDERS_TO_DECKS: "Trasformare cartelle in mazzi e sotto-mazzi?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "Questa \xE8 un'alternativa all'opzione delle etichette delle schede sopra.",
  INLINE_SCHEDULING_COMMENTS: "Salvare il commento per l'orario sulla stessa linea dell'ultimna linea della scheda?",
  INLINE_SCHEDULING_COMMENTS_DESC: "Attivando quest'impostazione far\xF2 s\xEC che i commento HTML non rompino la formattazione delle liste.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Sotterrare schede sorelle fino al giorno dopo?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "Le schede sorelle sono schede generate dallo stesso testo della scheda, per esempio i.e. cloze deletions",
  SHOW_CARD_CONTEXT: "Mostrare contesto nelle schede?",
  SHOW_CARD_CONTEXT_DESC: "per esempio, Titolo > Intestazione 1 > Sottotitolo 1 > ... > Sottotitolo",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC: "Useful to know how far in the future your cards are being pushed.",
  CARD_MODAL_HEIGHT_PERCENT: "Percentuale altezza schede",
  CARD_MODAL_SIZE_PERCENT_DESC: "Dovrebbe essere 100% se sei su telefono o se hai immagini molto grandi",
  RESET_DEFAULT: "Reimposta alle impostazioni iniziali",
  CARD_MODAL_WIDTH_PERCENT: "Percentuale di larghezza delle schede",
  RANDOMIZE_CARD_ORDER: "Rendere casuale l'ordine delle schede durante la revisione?",
  REVIEW_CARD_ORDER_WITHIN_DECK: "L'ordine in cui le schede saranno visualizzate all'interno del mazzo",
  REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "Sequenzialmente dentro il mazzo (prima schede nuove)",
  REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "Sequenzialmente dentro il mazzo (prima schede in ritardo)",
  REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "A caso dentro il mazzo (prima schede nuove)",
  REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "A caso dentro il mazzo (prima schede in ritardo)",
  REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Scheda a caso da mazzo a caso",
  REVIEW_DECK_ORDER: "L'ordine in cui i mazzi vengono mostrati durante la revisione",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL: "Sequenzialmente (quando le schede nel mazzo precedente saranno state riviste)",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM: "A caso (quando le schede nel mazzo precedente saranno state riviste)",
  REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Scheda a caso da mazzo a caso",
  DISABLE_CLOZE_CARDS: "Disabilita schede con spazi da riempire?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "Convertire ==testo evidenziato== in spazi da riempire?",
  CONVERT_HIGHLIGHTS_TO_CLOZES_DESC: 'Aggiungi/rimuovi <code>${defaultPattern}</code> dai tuoi "Modelli per spazi da riempire"',
  CONVERT_BOLD_TEXT_TO_CLOZES: "Convertire **testo in grassetto** in spazi da riempire",
  CONVERT_BOLD_TEXT_TO_CLOZES_DESC: 'Aggiungi/rimuovi <code>${defaultPattern}</code> dai tuoi "Modelli per spazi da riempire"',
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "Convertire {{parentesi graffe}} in spazi da riempire?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC: 'Aggiungi/rimuovi <code>${defaultPattern}</code> dai tuoi "Modelli per spazi da riempire"',
  CLOZE_PATTERNS: "Modelli di spazi da riempire",
  CLOZE_PATTERNS_DESC: 'Inserisci i modelli di spazi da riempire separati da a capo. Check the <a href="${docsUrl}">wiki</a> for guidance.',
  INLINE_CARDS_SEPARATOR: "Separatore per schede sulla stessa riga",
  FIX_SEPARATORS_MANUALLY_WARNING: "Si avvisa che dopo aver cambiato questo dovrai manualmente modificare le schede che hai gi\xE0.",
  INLINE_REVERSED_CARDS_SEPARATOR: "Separatore per schede all'incontrario sulla stessa riga",
  MULTILINE_CARDS_SEPARATOR: "Separatore per schede su pi\xF9 righe",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "Separatore per schede all'incontrario su pi\xF9 righe",
  MULTILINE_CARDS_END_MARKER: "Caratteri che denotano la fine di carte con spazi da riempiere e carte multilinea",
  NOTES: "Note",
  NOTE: "Note",
  REVIEW_PANE_ON_STARTUP: "Abilita il pannello di revisione note all'avvio",
  TAGS_TO_REVIEW: "Etichette da rivedere",
  TAGS_TO_REVIEW_DESC: "Inserisci le etichette separate da spazi o a capi, tipo #review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "Apri una nota a caso per revisione",
  OPEN_RANDOM_NOTE_DESC: "Quando lo disabiliti, le note saranno ordinate per importanza (PageRank).",
  AUTO_NEXT_NOTE: "Apri la prossima nota automaticamente dopo la revisione",
  ENABLE_FILE_MENU_REVIEW_OPTIONS: "Abilita le opzioni di revisione nel menu File (es.: Rivisita: Facile, Buono, Difficile)",
  ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "Se disabiliti le opzioni di revisione nel menu File, puoi rivedere le tue note utilizzando i comandi del plugin e, se li hai definiti, le scorciatoie da tastiera associate.",
  MAX_N_DAYS_REVIEW_QUEUE: "Numero di giorni massimi da visualizzare nel pannello di destra",
  MIN_ONE_DAY: "Il numero di giorni deve essere almeno 1.",
  VALID_NUMBER_WARNING: "Per favore, mettere un numero valido.",
  UI: "User Interface",
  OPEN_IN_TAB: "Open in new tab",
  OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
  SHOW_STATUS_BAR: "Show status bar",
  SHOW_STATUS_BAR_DESC: "Turn this off to hide the flashcard's review status in Obsidian's status bar",
  SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
  SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "Alberti di mazzi dovrebbero essere inizialmente visualizzate come espansi",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "Disabilitami per collassare mazzi annidati nella stessa scheda. Utile se hai schede che appartengono a pi\xF9 mazzi nello stesso file.",
  ALGORITHM: "Algoritmo",
  CHECK_ALGORITHM_WIKI: "Per maggiori informazioni, visita <a href='${algoUrl}'>l'implementazione dell'algoritmo</a>.",
  SM2_OSR_VARIANT: "OSR's variant of SM-2",
  BASE_EASE: "Difficolt\xE0 base",
  BASE_EASE_DESC: "mino = 130, preferibilmente circa 250.",
  BASE_EASE_MIN_WARNING: "La difficolt\xE0 base deve essere di almeno 130.",
  LAPSE_INTERVAL_CHANGE: "L'intervallo cambier\xE0 segnando una scheda / nota come difficile",
  LAPSE_INTERVAL_CHANGE_DESC: "Intervallo nuovo = intervallo vecchio * cambio intervallo / 100.",
  EASY_BONUS: "Bonus facilit\xE0",
  EASY_BONUS_DESC: "Il bonus facilit\xE0 ti permette di impostare le differenze negli intervalli tra il rispondere Buono e Facile su una scheda o nota (minimo 100%).",
  EASY_BONUS_MIN_WARNING: "Il bonus facilit\xE0 deve essere di almeno 100.",
  LOAD_BALANCE: "Enable load balancer",
  LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
  MAX_INTERVAL: "Intervallo massimo in giorni",
  MAX_INTERVAL_DESC: "Ti permette di mettere un limite massimo all'intervallo (default 100 anni).",
  MAX_INTERVAL_MIN_WARNING: "L'intervallo massimo deve essere di almeno 1 giorno.",
  MAX_LINK_CONTRIB: "Contributo massimo delle note collegate",
  MAX_LINK_CONTRIB_DESC: "Contributo massimo della difficolt\xE0 pasata delle note collegate alla difficolt\xE0 iniziale.",
  LOGGING: "Registrando",
  DISPLAY_SCHEDULING_DEBUG_INFO: "Visualizza informazione di debug sulla console per sviluppatori",
  DISPLAY_PARSER_DEBUG_INFO: "Visualizza informazione di debug riguardanti il parser sulla console per sviluppatori",
  SCHEDULING: "Scheduling",
  EXPERIMENTAL: "Experimental",
  HELP: "Help",
  STORE_IN_NOTES: "In the notes",
  // sidebar.ts
  NOTES_REVIEW_QUEUE: "Coda di note da rivedere",
  CLOSE: "Chiusi",
  NEW: "Nuovo/a",
  YESTERDAY: "Ieri",
  TODAY: "Oggi",
  TOMORROW: "Domani",
  // stats-modal.tsx
  STATS_TITLE: "Statistiche",
  MONTH: "Mese",
  QUARTER: "Trimestre",
  YEAR: "Anno",
  LIFETIME: "Per tutta la vita",
  FORECAST: "Previsione",
  FORECAST_DESC: "Il numero di schede che saranno in ritardo in futuro",
  SCHEDULED: "Programmate",
  DAYS: "Giorni",
  NUMBER_OF_CARDS: "Numero di schede",
  REVIEWS_PER_DAY: "Media: ${avg} revisioni/giorno",
  INTERVALS: "Intervalli",
  INTERVALS_DESC: "Ritardi finch\xE9 le revisioni saranno visualizzate di nuovo",
  COUNT: "Conta",
  INTERVALS_SUMMARY: "Intervallo medio: ${avg}, Intervallo massimo: ${longest}",
  EASES: "Difficolt\xE0",
  EASES_SUMMARY: "Difficolt\xE0 media: ${avgEase}",
  EASE: "Ease",
  CARD_TYPES: "Tipi di schede",
  CARD_TYPES_DESC: "Include eventuali schede sepolte",
  CARD_TYPE_NEW: "Nuove",
  CARD_TYPE_YOUNG: "Giovani",
  CARD_TYPE_MATURE: "Mature",
  CARD_TYPES_SUMMARY: "Schede tottali: ${totalCardsCount}",
  SEARCH: "Search",
  PREVIOUS: "Previous",
  NEXT: "Next"
};

// src/lang/locale/ja.ts
var ja_default = {
  // flashcard-modal.tsx
  DECKS: "\u30C7\u30C3\u30AD",
  DUE_CARDS: "\u671F\u65E5\u306E\u30AB\u30FC\u30C9",
  NEW_CARDS: "\u65B0\u898F\u306E\u30AB\u30FC\u30C9",
  TOTAL_CARDS: "\u30AB\u30FC\u30C9\u5408\u8A08",
  BACK: "Back",
  SKIP: "Skip",
  EDIT_CARD: "Edit Card",
  RESET_CARD_PROGRESS: "\u30AB\u30FC\u30C9\u306E\u9032\u6357\u3092\u30EA\u30BB\u30C3\u30C8",
  HARD: "Hard",
  GOOD: "Good",
  EASY: "Easy",
  SHOW_ANSWER: "\u89E3\u7B54\u3092\u8868\u793A",
  CARD_PROGRESS_RESET: "\u30AB\u30FC\u30C9\u306E\u9032\u6357\u304C\u30EA\u30BB\u30C3\u30C8\u3055\u308C\u307E\u3057\u305F\u3002",
  SAVE: "Save",
  CANCEL: "Cancel",
  NO_INPUT: "No input provided.",
  CURRENT_EASE_HELP_TEXT: "Current Ease: ",
  CURRENT_INTERVAL_HELP_TEXT: "Current Interval: ",
  CARD_GENERATED_FROM: "Generated from: ${notePath}",
  // main.ts
  OPEN_NOTE_FOR_REVIEW: "\u30EC\u30D3\u30E5\u30FC\u3059\u308B\u30CE\u30FC\u30C8\u3092\u958B\u304F",
  REVIEW_CARDS: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u30EC\u30D3\u30E5\u30FC",
  REVIEW_DIFFICULTY_FILE_MENU: "\u30EC\u30D3\u30E5\u30FC: ${difficulty}",
  REVIEW_NOTE_DIFFICULTY_CMD: "\u30CE\u30FC\u30C8\u3092${difficulty}\u3068\u3057\u3066\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  REVIEW_ALL_CARDS: "\u3059\u3079\u3066\u306E\u30CE\u30FC\u30C8\u304B\u3089\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u3092\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  CRAM_ALL_CARDS: "Select a deck to cram",
  REVIEW_CARDS_IN_NOTE: "\u3053\u306E\u30CE\u30FC\u30C8\u306E\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u3092\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  CRAM_CARDS_IN_NOTE: "\u3053\u306E\u30CE\u30FC\u30C8\u306E\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u3092\u8A70\u3081\u8FBC\u307F\u5B66\u7FD2\u3059\u308B",
  VIEW_STATS: "\u7D71\u8A08\u3092\u95B2\u89A7\u3059\u308B",
  OPEN_REVIEW_QUEUE_VIEW: "Open Notes Review Queue in sidebar",
  STATUS_BAR: "\u30EC\u30D3\u30E5\u30FC: ${dueNotesCount}\u30CE\u30FC\u30C8, ${dueFlashcardsCount}\u30AB\u30FC\u30C9\u304C\u671F\u65E5",
  SYNC_TIME_TAKEN: "\u540C\u671F\u306B${t}ms\u304B\u304B\u308A\u307E\u3057\u305F\u3002",
  NOTE_IN_IGNORED_FOLDER: "\u30CE\u30FC\u30C8\u304C\u7121\u8996\u3059\u308B\u30D5\u30A9\u30EB\u30C0\u306B\u4FDD\u5B58\u3055\u308C\u3066\u3044\u307E\u3059(\u8A2D\u5B9A\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044)\u3002",
  PLEASE_TAG_NOTE: "\u30EC\u30D3\u30E5\u30FC\u3092\u884C\u3046\u306B\u306F\u30CE\u30FC\u30C8\u306B\u5BFE\u3057\u3066\u6B63\u3057\u304F\u30BF\u30B0\u4ED8\u3051\u3057\u3066\u304F\u3060\u3055\u3044(\u8A2D\u5B9A\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044)\u3002",
  RESPONSE_RECEIVED: "\u7B54\u3048\u3092\u53D7\u3051\u53D6\u308A\u307E\u3057\u305F\u3002",
  NO_DECK_EXISTS: "${deckName}\u306B\u306F\u30C7\u30C3\u30AD\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002",
  ALL_CAUGHT_UP: "\u4ECA\u65E5\u306E\u8AB2\u984C\u3092\u3059\u3079\u3066\u9054\u6210\u3057\u307E\u3057\u305F :D",
  // scheduling.ts
  DAYS_STR_IVL: "${interval}\u65E5\u5F8C",
  MONTHS_STR_IVL: "${interval}\u6708\u5F8C",
  YEARS_STR_IVL: "${interval}\u5E74\u5F8C",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}y",
  // settings.ts
  SETTINGS_HEADER: "Spaced Repetition",
  GROUP_TAGS_FOLDERS: "Tags & Folders",
  GROUP_FLASHCARD_REVIEW: "Flashcard Review",
  GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
  GROUP_DATA_STORAGE: "Storage of Scheduling Data",
  GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
  GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
  GROUP_CONTRIBUTING: "Contributing",
  CHECK_WIKI: '\u8A73\u7D30\u306B\u3064\u3044\u3066\u306F<a href="${wikiUrl}">wiki</a>\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002',
  GITHUB_DISCUSSIONS: 'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
  GITHUB_ISSUES: 'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
  GITHUB_SOURCE_CODE: 'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
  CODE_CONTRIBUTION_INFO: '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
  TRANSLATION_CONTRIBUTION_INFO: '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
  FOLDERS_TO_IGNORE: "\u7121\u8996\u3059\u308B\u30D5\u30A9\u30EB\u30C0",
  FOLDERS_TO_IGNORE_DESC: "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
  OBSIDIAN_INTEGRATION: "Integration into Obsidian",
  FLASHCARDS: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9",
  FLASHCARD_EASY_LABEL: "Easy Button Text",
  FLASHCARD_GOOD_LABEL: "Good Button Text",
  FLASHCARD_HARD_LABEL: "Hard Button Text",
  FLASHCARD_EASY_DESC: 'Customize the label for the "Easy" Button',
  FLASHCARD_GOOD_DESC: 'Customize the label for the "Good" Button',
  FLASHCARD_HARD_DESC: 'Customize the label for the "Hard" Button',
  REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
  REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
  FLASHCARD_TAGS: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BF\u30B0",
  FLASHCARD_TAGS_DESC: '\u30BF\u30B0\u3092\u30B9\u30DA\u30FC\u30B9\u307E\u305F\u306F\u6539\u884C\u3067\u533A\u5207\u3063\u3066\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u4F8B: "#flashcards #deck2 #deck3"',
  CONVERT_FOLDERS_TO_DECKS: "\u30D5\u30A9\u30EB\u30C0\u3092\u30C7\u30C3\u30AD\u3068\u30B5\u30D6\u30C7\u30C3\u30AD\u3068\u3057\u3066\u4F7F\u7528\u3057\u307E\u3059\u304B\uFF1F",
  CONVERT_FOLDERS_TO_DECKS_DESC: "\u3053\u308C\u306F\u4E0A\u8A18\u306E\u30BF\u30B0\u3092\u4F7F\u7528\u3057\u305F\u30C7\u30C3\u30AD\u69CB\u7BC9\u306E\u4EE3\u66FF\u3068\u306A\u308B\u30AA\u30D7\u30B7\u30E7\u30F3\u3067\u3059\u3002",
  INLINE_SCHEDULING_COMMENTS: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u6700\u7D42\u884C\u3068\u540C\u4E00\u306E\u884C\u306B\u30B9\u30B1\u30B8\u30E5\u30FC\u30EA\u30F3\u30B0\u30B3\u30E1\u30F3\u30C8\u3092\u4FDD\u5B58\u3057\u307E\u3059\u304B\uFF1F",
  INLINE_SCHEDULING_COMMENTS_DESC: "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u6709\u52B9\u5316\u3059\u308B\u3068\u3001HTML\u30B3\u30E1\u30F3\u30C8\u306B\u3088\u3063\u3066Markdown\u306E\u30EA\u30B9\u30C8\u30D5\u30A9\u30FC\u30DE\u30C3\u30C8\u304C\u5D29\u308C\u306A\u304F\u306A\u308A\u307E\u3059\u3002",
  BURY_SIBLINGS_TILL_NEXT_DAY: "\u6B21\u306E\u30EC\u30D3\u30E5\u30FC\u307E\u3067\u30B7\u30D6\u30EA\u30F3\u30B0\u3092\u5EF6\u671F\u3057\u307E\u3059\u304B\uFF1F",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "\u30B7\u30D6\u30EA\u30F3\u30B0\u306F\u540C\u4E00\u306E\u30AB\u30FC\u30C9\u30C6\u30AD\u30B9\u30C8\u304B\u3089\u751F\u6210\u3055\u308C\u305F\u30AB\u30FC\u30C9\u3001\u3064\u307E\u308A\u7A74\u57CB\u3081\u554F\u984C\u306E\u6D3E\u751F\u30AB\u30FC\u30C9\u3067\u3059\u3002",
  SHOW_CARD_CONTEXT: "\u30AB\u30FC\u30C9\u306B\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u3092\u8868\u793A\u3057\u307E\u3059\u304B\uFF1F",
  SHOW_CARD_CONTEXT_DESC: "\uFF62\u30BF\u30A4\u30C8\u30EB > \u898B\u51FA\u3057 1 > \u526F\u898B\u51FA\u3057 > ... > \u526F\u898B\u51FA\u3057\uFF63\u306E\u8868\u793A\u3092\u884C\u3046\u304B\u3069\u3046\u304B\u3092\u6C7A\u3081\u307E\u3059\u3002",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC: "Useful to know how far in the future your cards are being pushed.",
  CARD_MODAL_HEIGHT_PERCENT: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u7E26\u30B5\u30A4\u30BA\u306E\u30D1\u30FC\u30BB\u30F3\u30C6\u30FC\u30B8",
  CARD_MODAL_SIZE_PERCENT_DESC: "\u30E2\u30D0\u30A4\u30EB\u7248\u3001\u307E\u305F\u306F\u975E\u5E38\u306B\u5927\u304D\u306A\u30B5\u30A4\u30BA\u306E\u753B\u50CF\u304C\u3042\u308B\u5834\u5408\u306B\u306F100%\u306B\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002",
  RESET_DEFAULT: "\u30C7\u30D5\u30A9\u30EB\u30C8\u5024\u306B\u30EA\u30BB\u30C3\u30C8\u3059\u308B",
  CARD_MODAL_WIDTH_PERCENT: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u6A2A\u30B5\u30A4\u30BA\u306E\u30D1\u30FC\u30BB\u30F3\u30C6\u30FC\u30B8",
  RANDOMIZE_CARD_ORDER: "\u30EC\u30D3\u30E5\u30FC\u4E2D\u306E\u30AB\u30FC\u30C9\u306E\u9806\u756A\u3092\u30E9\u30F3\u30C0\u30E0\u306B\u3057\u307E\u3059\u304B\uFF1F",
  REVIEW_CARD_ORDER_WITHIN_DECK: "Order cards in a deck are displayed during review",
  REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "Sequentially within a deck (All new cards first)",
  REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "Sequentially within a deck (All due cards first)",
  REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Randomly within a deck (All new cards first)",
  REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "Randomly within a deck (All due cards first)",
  REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
  REVIEW_DECK_ORDER: "Order decks are displayed during review",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL: "Sequentially (once all cards in previous deck reviewed)",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM: "Randomly (once all cards in previous deck reviewed)",
  REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
  DISABLE_CLOZE_CARDS: "\u7A74\u57CB\u3081\u30AB\u30FC\u30C9\u3092\u7121\u52B9\u5316\u3057\u307E\u3059\u304B\uFF1F",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "==\u30CF\u30A4\u30E9\u30A4\u30C8==\u3092\u7A74\u57CB\u3081\u3068\u3057\u3066\u4F7F\u7528\u3057\u307E\u3059\u304B\uFF1F",
  CONVERT_HIGHLIGHTS_TO_CLOZES_DESC: "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u6709\u52B9\u5316\u3059\u308B\u3068\u3001\u300C\u7A74\u57CB\u3081\u30D1\u30BF\u30FC\u30F3\u300D\u306B${defaultPattern}\u304C\u8FFD\u52A0\u3055\u308C\u307E\u3059\u3002",
  CONVERT_BOLD_TEXT_TO_CLOZES: "**\u30DC\u30FC\u30EB\u30C9\u4F53**\u3092\u7A74\u57CB\u3081\u3068\u3057\u3066\u4F7F\u7528\u3057\u307E\u3059\u304B\uFF1F",
  CONVERT_BOLD_TEXT_TO_CLOZES_DESC: "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u6709\u52B9\u5316\u3059\u308B\u3068\u3001\u300C\u7A74\u57CB\u3081\u30D1\u30BF\u30FC\u30F3\u300D\u306B${defaultPattern}\u304C\u8FFD\u52A0\u3055\u308C\u307E\u3059\u3002",
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "{{\u4E2D\u62EC\u5F27}}\u3092\u7A74\u57CB\u3081\u3068\u3057\u3066\u4F7F\u7528\u3057\u307E\u3059\u304B\uFF1F",
  CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC: "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u6709\u52B9\u5316\u3059\u308B\u3068\u3001\u300C\u7A74\u57CB\u3081\u30D1\u30BF\u30FC\u30F3\u300D\u306B${defaultPattern}\u304C\u8FFD\u52A0\u3055\u308C\u307E\u3059\u3002",
  CLOZE_PATTERNS: "\u7A74\u57CB\u3081\u30D1\u30BF\u30FC\u30F3",
  CLOZE_PATTERNS_DESC: '\u6539\u884C\u3067\u533A\u5207\u3063\u3066\u7A74\u57CB\u3081\u30D1\u30BF\u30FC\u30F3\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002 Check the <a href="${docsUrl}">wiki</a> for guidance.',
  INLINE_CARDS_SEPARATOR: "\u30A4\u30F3\u30E9\u30A4\u30F3\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC",
  FIX_SEPARATORS_MANUALLY_WARNING: "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u5909\u66F4\u3059\u308B\u5834\u5408\u306B\u306F\u3001\u4F5C\u6210\u6E08\u307F\u306E\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u3092\u624B\u52D5\u3067\u7DE8\u96C6\u3057\u76F4\u3059\u5FC5\u8981\u304C\u3042\u308B\u3053\u3068\u306B\u6CE8\u610F\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  INLINE_REVERSED_CARDS_SEPARATOR: "\u30A4\u30F3\u30E9\u30A4\u30F3\u306E\u8868\u88CF\u53CD\u8EE2\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC",
  MULTILINE_CARDS_SEPARATOR: "\u8907\u6570\u884C\u306E\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "\u8907\u6570\u884C\u306E\u8868\u88CF\u53CD\u8EE2\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306B\u4F7F\u7528\u3059\u308B\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC",
  MULTILINE_CARDS_END_MARKER: "\u30AF\u30ED\u30FC\u30BA\u3068\u8907\u6570\u884C\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9\u306E\u7D42\u308F\u308A\u3092\u793A\u3059\u6587\u5B57",
  NOTES: "\u30CE\u30FC\u30C8",
  NOTE: "Note",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "\u30EC\u30D3\u30E5\u30FC\u306B\u4F7F\u7528\u3059\u308B\u30BF\u30B0",
  TAGS_TO_REVIEW_DESC: '\u30BF\u30B0\u3092\u30B9\u30DA\u30FC\u30B9\u307E\u305F\u306F\u6539\u884C\u3067\u533A\u5207\u3063\u3066\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u4F8B: "#review #tag2 #tag3"',
  OPEN_RANDOM_NOTE: "\u30E9\u30F3\u30C0\u30E0\u306B\u30CE\u30FC\u30C8\u3092\u958B\u3044\u3066\u30EC\u30D3\u30E5\u30FC\u3059\u308B",
  OPEN_RANDOM_NOTE_DESC: "\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u304C\u7121\u52B9\u5316\u3055\u308C\u3066\u3044\u308B\u72B6\u614B\u3067\u306F\u3001\u30CE\u30FC\u30C8\u306F\u91CD\u8981\u5EA6(\u30DA\u30FC\u30B8\u30E9\u30F3\u30AF)\u306B\u3088\u308B\u9806\u756A\u3067\u8868\u793A\u3055\u308C\u307E\u3059\u3002",
  AUTO_NEXT_NOTE: "\u30EC\u30D3\u30E5\u30FC\u5F8C\u306B\u6B21\u306E\u30CE\u30FC\u30C8\u3092\u81EA\u52D5\u7684\u306B\u958B\u304F",
  ENABLE_FILE_MENU_REVIEW_OPTIONS: "\u30D5\u30A1\u30A4\u30EB\u30E1\u30CB\u30E5\u30FC\u3067\u30EC\u30D3\u30E5\u30FC\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u6709\u52B9\u306B\u3057\u3066\u304F\u3060\u3055\u3044\uFF08\u4F8B: Easy, Good, Hard\uFF09",
  ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "\u30D5\u30A1\u30A4\u30EB\u30E1\u30CB\u30E5\u30FC\u3067\u30EC\u30D3\u30E5\u30FC\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u7121\u52B9\u306B\u3057\u305F\u5834\u5408\u3001\u30D7\u30E9\u30B0\u30A4\u30F3\u30B3\u30DE\u30F3\u30C9\u3084\u3001\u8A2D\u5B9A\u3057\u3066\u3044\u308B\u5834\u5408\u306F\u5BFE\u5FDC\u3059\u308B\u30DB\u30C3\u30C8\u30AD\u30FC\u3092\u4F7F\u7528\u3057\u3066\u30E1\u30E2\u3092\u30EC\u30D3\u30E5\u30FC\u3067\u304D\u307E\u3059\u3002",
  MAX_N_DAYS_REVIEW_QUEUE: "\u53F3\u30D1\u30CD\u30EB\u306B\u8868\u793A\u3059\u308B\u6700\u5927\u306E\u65E5\u6570",
  MIN_ONE_DAY: "\u65E5\u6570\u306B\u306F1\u4EE5\u4E0A\u306E\u6570\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  VALID_NUMBER_WARNING: "\u6709\u52B9\u306A\u6570\u5B57\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  UI: "User Interface",
  OPEN_IN_TAB: "Open in new tab",
  OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
  SHOW_STATUS_BAR: "Show status bar",
  SHOW_STATUS_BAR_DESC: "Turn this off to hide the flashcard's review status in Obsidian's status bar",
  SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
  SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "\u30C7\u30C3\u30AD \u30C4\u30EA\u30FC\u306F\u6700\u521D\u306F\u5C55\u958B\u3057\u3066\u8868\u793A\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "\u3053\u308C\u3092\u30AA\u30D5\u306B\u3059\u308B\u3068\u3001\u540C\u3058\u30AB\u30FC\u30C9\u5185\u306E\u30CD\u30B9\u30C8\u3055\u308C\u305F\u30C7\u30C3\u30AD\u304C\u6298\u308A\u305F\u305F\u307E\u308C\u307E\u3059\u3002\u540C\u3058\u30D5\u30A1\u30A4\u30EB\u306B\u591A\u304F\u306E\u30C7\u30C3\u30AD\u306B\u5C5E\u3059\u308B\u30AB\u30FC\u30C9\u304C\u3042\u308B\u5834\u5408\u306B\u4FBF\u5229\u3067\u3059\u3002",
  ALGORITHM: "\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0",
  CHECK_ALGORITHM_WIKI: '\u8A73\u7D30\u306B\u3064\u3044\u3066\u306F<a href="${algoUrl}">\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\u306E\u5B9F\u88C5</a>\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002',
  SM2_OSR_VARIANT: "OSR's variant of SM-2",
  BASE_EASE: "\u30D9\u30FC\u30B9\u306E\u6613\u3057\u3055",
  BASE_EASE_DESC: "\u6700\u5C0F\u5024\u306F130\u3067\u3059\u304C\u3001 \u9069\u6B63\u5024\u306F\u304A\u304A\u3088\u305D250\u3067\u3059\u3002",
  BASE_EASE_MIN_WARNING: "\u30D9\u30FC\u30B9\u306E\u6613\u3057\u3055\u306B\u306F130\u4EE5\u4E0A\u306E\u6570\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  LAPSE_INTERVAL_CHANGE: "\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9/\u30CE\u30FC\u30C8\u3092Hard\u3068\u3057\u3066\u30EC\u30D3\u30E5\u30FC\u3057\u305F\u969B\u306E\u9593\u9694\u5909\u66F4",
  LAPSE_INTERVAL_CHANGE_DESC: '"\u65B0\u3057\u3044\u9593\u9694 = \u4EE5\u524D\u306E\u9593\u9694 * \u9593\u9694\u5909\u66F4 / 100" \u3068\u3057\u3066\u8A08\u7B97\u3055\u308C\u307E\u3059\u3002',
  EASY_BONUS: "Easy\u30DC\u30FC\u30CA\u30B9",
  EASY_BONUS_DESC: "Easy\u30DC\u30FC\u30CA\u30B9\u306B\u3088\u3063\u3066\u30D5\u30E9\u30C3\u30B7\u30E5\u30AB\u30FC\u30C9/\u30CE\u30FC\u30C8\u306B\u304A\u3051\u308B\u9593\u9694\u306E\u5DEE\u5206\u3092\u8A2D\u5B9A\u3067\u304D\u307E\u3059(\u6700\u5C0F\u5024 = 100%)\u3002",
  EASY_BONUS_MIN_WARNING: "Easy\u30DC\u30FC\u30CA\u30B9\u306B\u306F100\u4EE5\u4E0A\u306E\u6570\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  LOAD_BALANCE: "Enable load balancer",
  LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
  MAX_INTERVAL: "Maximum interval in days",
  MAX_INTERVAL_DESC: "\u9593\u9694\u306B\u4E0A\u9650\u5024\u3092\u8A2D\u5B9A\u3059\u308B\u3053\u3068\u304C\u3067\u304D\u307E\u3059(\u30C7\u30D5\u30A9\u30EB\u30C8\u5024 = 100\u5E74)\u3002",
  MAX_INTERVAL_MIN_WARNING: "\u9593\u9694\u306E\u6700\u5927\u5024\u306B\u306F1\u4EE5\u4E0A\u306E\u6570\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  MAX_LINK_CONTRIB: "\u30EA\u30F3\u30AF\u30B3\u30F3\u30C8\u30EA\u30D3\u30E5\u30FC\u30B7\u30E7\u30F3\u306E\u6700\u5927\u5024",
  MAX_LINK_CONTRIB_DESC: "\u6700\u521D\u306E\u6613\u3057\u3055\u306B\u5BFE\u3057\u3066\u3001\u30EA\u30F3\u30AF\u3055\u308C\u305F\u30CE\u30FC\u30C8\u306E\u91CD\u307F\u4ED8\u3051\u3055\u308C\u305F\u6613\u3057\u3055\u304C\u5BC4\u4E0E\u3059\u308B\u6700\u5927\u5024\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  LOGGING: "\u30ED\u30B0\u7BA1\u7406",
  DISPLAY_SCHEDULING_DEBUG_INFO: "\u30C7\u30D9\u30ED\u30C3\u30D1\u30FC\u30B3\u30F3\u30BD\u30FC\u30EB\u306B\u3066\u30C7\u30D0\u30C3\u30B0\u60C5\u5831\u3092\u8868\u793A\u3057\u307E\u3059\u304B",
  DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
  SCHEDULING: "Scheduling",
  EXPERIMENTAL: "Experimental",
  HELP: "Help",
  STORE_IN_NOTES: "In the notes",
  // sidebar.ts
  NOTES_REVIEW_QUEUE: "\u30CE\u30FC\u30C8\u30EC\u30D3\u30E5\u30FC\u306E\u30AD\u30E5\u30FC",
  CLOSE: "\u9589\u3058\u308B",
  NEW: "\u65B0\u898F",
  YESTERDAY: "\u6628\u65E5",
  TODAY: "\u4ECA\u65E5",
  TOMORROW: "\u660E\u65E5",
  // stats-modal.tsx
  STATS_TITLE: "\u7D71\u8A08",
  MONTH: "Month",
  QUARTER: "Quarter",
  YEAR: "Year",
  LIFETIME: "Lifetime",
  FORECAST: "\u4E88\u6E2C",
  FORECAST_DESC: "\u5FA9\u7FD2\u671F\u65E5\u304C\u6765\u308B\u30AB\u30FC\u30C9\u306E\u679A\u6570",
  SCHEDULED: "\u30B9\u30B1\u30B8\u30E5\u30FC\u30EA\u30F3\u30B0\u6E08\u307F",
  DAYS: "\u65E5",
  NUMBER_OF_CARDS: "\u30AB\u30FC\u30C9\u6570",
  REVIEWS_PER_DAY: "\u5E73\u5747: ${avg}\u30EC\u30D3\u30E5\u30FC/\u65E5",
  INTERVALS: "\u9593\u9694",
  INTERVALS_DESC: "\u6B21\u306E\u30EC\u30D3\u30E5\u30FC\u4E88\u5B9A\u65E5",
  COUNT: "\u30AB\u30A6\u30F3\u30C8",
  INTERVALS_SUMMARY: "\u9593\u9694\u306E\u5E73\u5747\u5024: ${avg}, \u6700\u9577\u306E\u9593\u9694: ${longest}",
  EASES: "\u6613\u3057\u3055",
  EASES_SUMMARY: "\u6613\u3057\u3055\u306E\u5E73\u5747\u5024: ${avgEase}",
  EASE: "Ease",
  CARD_TYPES: "\u30AB\u30FC\u30C9\u30BF\u30A4\u30D7",
  CARD_TYPES_DESC: "\u5EF6\u671F\u306E\u30AB\u30FC\u30C9\u304C\u3042\u308B\u5834\u5408\u306B\u306F\u3053\u308C\u306B\u542B\u307E\u308C\u307E\u3059",
  CARD_TYPE_NEW: "\u65B0\u898F",
  CARD_TYPE_YOUNG: "\u5FA9\u7FD2(\u521D\u671F)",
  CARD_TYPE_MATURE: "\u5FA9\u7FD2(\u5F8C\u671F)",
  CARD_TYPES_SUMMARY: "\u30AB\u30FC\u30C9\u306E\u5408\u8A08: ${totalCardsCount}\u679A",
  SEARCH: "Search",
  PREVIOUS: "Previous",
  NEXT: "Next"
};

// src/lang/locale/ko.ts
var ko_default = {
  // flashcard-modal.tsx
  DECKS: "\uB371",
  DUE_CARDS: "\uB2E4\uC2DC \uBCFC \uCE74\uB4DC\uB4E4",
  NEW_CARDS: "\uC0C8\uB85C\uC6B4 \uCE74\uB4DC\uB4E4",
  TOTAL_CARDS: "\uC804\uCCB4 \uCE74\uB4DC\uB4E4",
  BACK: "Back",
  SKIP: "Skip",
  EDIT_CARD: "Edit Card",
  RESET_CARD_PROGRESS: "\uCE74\uB4DC\uC758 \uC9C4\uD589\uC0C1\uD669\uC744 \uCD08\uAE30\uD654\uD569\uB2C8\uB2E4.",
  HARD: "\uC5B4\uB824\uC6C0(Hard)",
  GOOD: "\uC88B\uC74C(Good)",
  EASY: "\uC26C\uC6C0(Easy)",
  SHOW_ANSWER: "\uC815\uB2F5 \uD655\uC778\uD558\uAE30",
  CARD_PROGRESS_RESET: "\uCE74\uB4DC\uC758 \uC9C4\uD589\uC0C1\uD669\uC774 \uCD08\uAE30\uD654\uB418\uC5C8\uC2B5\uB2C8\uB2E4.",
  SAVE: "Save",
  CANCEL: "Cancel",
  NO_INPUT: "No input provided.",
  CURRENT_EASE_HELP_TEXT: "Current Ease: ",
  CURRENT_INTERVAL_HELP_TEXT: "Current Interval: ",
  CARD_GENERATED_FROM: "Generated from: ${notePath}",
  // main.ts
  OPEN_NOTE_FOR_REVIEW: "\uB9AC\uBDF0\uD560 \uB178\uD2B8 \uC5F4\uAE30",
  REVIEW_CARDS: "\uD50C\uB798\uC2DC\uCE74\uB4DC \uB9AC\uBDF0",
  REVIEW_DIFFICULTY_FILE_MENU: "\uB9AC\uBDF0: ${difficulty}",
  REVIEW_NOTE_DIFFICULTY_CMD: "\uB178\uD2B8\uB97C ${difficulty}\uC73C\uB85C \uB9AC\uBDF0\uD569\uB2C8\uB2E4",
  REVIEW_ALL_CARDS: "\uBAA8\uB4E0 \uB178\uD2B8\uB4E4\uC758 \uD50C\uB798\uC2DC\uCE74\uB4DC\uB4E4\uC744 \uB9AC\uBDF0\uD569\uB2C8\uB2E4",
  CRAM_ALL_CARDS: "Select a deck to cram",
  REVIEW_CARDS_IN_NOTE: "\uC774 \uB178\uD2B8\uC758 \uD50C\uB798\uC2DC\uCE74\uB4DC\uB4E4\uC744 \uB9AC\uBDF0\uD569\uB2C8\uB2E4",
  CRAM_CARDS_IN_NOTE: "\uC774 \uB178\uD2B8\uC758 \uD50C\uB798\uC2DC\uCE74\uB4DC\uB4E4\uC744 \uBCBC\uB77D\uCE58\uAE30\uD569\uB2C8\uB2E4.",
  VIEW_STATS: "\uD1B5\uACC4 \uD655\uC778",
  OPEN_REVIEW_QUEUE_VIEW: "Open Notes Review Queue in sidebar",
  STATUS_BAR: "--\uB9AC\uBDF0: ${dueNotesCount} \uB178\uD2B8, ${dueFlashcardsCount} \uCE74\uB4DC \uB0A8\uC558\uC2B5\uB2C8\uB2E4.",
  SYNC_TIME_TAKEN: "\uB3D9\uAE30\uD654\uC5D0 ${t}\uBC00\uB9AC\uCD08 \uAC78\uB838\uC2B5\uB2C8\uB2E4",
  NOTE_IN_IGNORED_FOLDER: "\uB178\uD2B8\uAC00 \uBB34\uC2DC\uB41C \uD3F4\uB354 \uC544\uB798\uC5D0 \uC800\uC7A5\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4. (\uC124\uC815\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694)",
  PLEASE_TAG_NOTE: "\uB9AC\uBDF0\uB97C \uD558\uAE30\uC704\uD574 \uB178\uD2B8\uC5D0 \uC801\uC808\uD788 \uD0DC\uADF8\uD574\uC8FC\uC138\uC694. (\uC124\uC815\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694)",
  RESPONSE_RECEIVED: "\uC694\uCCAD\uC774 \uC644\uB8CC\uB418\uC5C8\uC2B5\uB2C8\uB2E4",
  NO_DECK_EXISTS: "${deckName}\uC774\uB77C\uB294 \uC774\uB984\uC758 \uB371\uC774 \uC874\uC7AC\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.",
  ALL_CAUGHT_UP: "\uBAA8\uB450 \uD655\uC778\uD588\uC2B5\uB2C8\uB2E4. :D",
  // scheduling.ts
  DAYS_STR_IVL: "${interval} \uC77C \uD6C4",
  MONTHS_STR_IVL: "${interval} \uAC1C\uC6D4 \uD6C4",
  YEARS_STR_IVL: "${interval} \uB144 \uD6C4",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}y",
  // settings.ts
  SETTINGS_HEADER: "Spaced Repetition",
  GROUP_TAGS_FOLDERS: "Tags & Folders",
  GROUP_FLASHCARD_REVIEW: "Flashcard Review",
  GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
  GROUP_DATA_STORAGE: "Storage of Scheduling Data",
  GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
  GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
  GROUP_CONTRIBUTING: "Contributing",
  CHECK_WIKI: '\uB354 \uB9CE\uC740 \uC815\uBCF4\uB97C \uC6D0\uD558\uC2DC\uBA74, <a href="${wikiUrl}">wiki</a>\uB97C \uD655\uC778\uD574\uC8FC\uC138\uC694.',
  GITHUB_DISCUSSIONS: 'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
  GITHUB_ISSUES: 'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
  GITHUB_SOURCE_CODE: 'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
  CODE_CONTRIBUTION_INFO: '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
  TRANSLATION_CONTRIBUTION_INFO: '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
  FOLDERS_TO_IGNORE: "\uBB34\uC2DC\uD560 \uD3F4\uB354\uB4E4",
  FOLDERS_TO_IGNORE_DESC: "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
  OBSIDIAN_INTEGRATION: "Integration into Obsidian",
  FLASHCARDS: "\uD50C\uB798\uC2DC\uCE74\uB4DC",
  FLASHCARD_EASY_LABEL: "Easy Button Text",
  FLASHCARD_GOOD_LABEL: "Good Button Text",
  FLASHCARD_HARD_LABEL: "Hard Button Text",
  FLASHCARD_EASY_DESC: 'Customize the label for the "Easy" Button',
  FLASHCARD_GOOD_DESC: 'Customize the label for the "Good" Button',
  FLASHCARD_HARD_DESC: 'Customize the label for the "Hard" Button',
  REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
  REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
  FLASHCARD_TAGS: "\uD50C\uB798\uC2DC\uCE74\uB4DC \uD0DC\uADF8",
  FLASHCARD_TAGS_DESC: "\uD0DC\uADF8\uB97C \uACF5\uBC31 \uB610\uB294 \uBE48 \uC904\uB85C \uAD6C\uBD84\uD574\uC11C \uC785\uB825\uD574\uC8FC\uC138\uC694. \uC608) '#flashcards #deck2 #deck3'",
  CONVERT_FOLDERS_TO_DECKS: "\uD3F4\uB354\uB97C \uB371\uACFC \uC11C\uBE0C\uB371\uC73C\uB85C \uC0AC\uC6A9\uD560\uAE4C\uC694?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "\uC774 \uAE30\uB2A5\uC740 \uC704\uC758 \uD50C\uB798\uC2DC\uCE74\uB4DC \uD0DC\uADF8 \uC635\uC158\uC744 \uB300\uCCB4\uD569\uB2C8\uB2E4.",
  INLINE_SCHEDULING_COMMENTS: "\uD50C\uB798\uC2DC\uCE74\uB4DC\uC758 \uB9C8\uC9C0\uB9C9 \uC904\uACFC \uB3D9\uC77C\uD55C \uC904\uC5D0 \uC2A4\uCF00\uC904\uB9C1 \uCF54\uBA58\uD2B8\uB97C \uC800\uC7A5\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  INLINE_SCHEDULING_COMMENTS_DESC: "\uC774 \uC635\uC158\uC744 \uC0AC\uC6A9\uD558\uBA74 HTML \uC8FC\uC11D\uC774 \uBAA9\uB85D\uC758 \uD3EC\uB9E4\uD305\uC744 \uBB34\uB108\uD2B8\uB9AC\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Sibling \uCE74\uB4DC\uB97C \uB2E4\uC74C\uB0A0\uAE4C\uC9C0 \uBB3B\uC5B4\uB450\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "Sibling \uCE74\uB4DC\uB294 \uB3D9\uC77C\uD55C \uCE74\uB4DC \uD14D\uC2A4\uD2B8\uC5D0\uC11C \uC0DD\uC131\uB41C \uCE74\uB4DC\uC785\uB2C8\uB2E4. i.e. cloze deletions",
  SHOW_CARD_CONTEXT: "\uCE74\uB4DC\uC758 \uBB38\uB9E5(context)\uC744 \uD45C\uC2DC\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  SHOW_CARD_CONTEXT_DESC: "\uCE74\uB4DC\uC5D0\uC11C 'Title > Heading 1 > Subheading > ... > Subheading' \uC758 \uD45C\uC2DC\uB97C \uD560\uC9C0 \uC124\uC815\uD569\uB2C8\uB2E4.",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC: "Useful to know how far in the future your cards are being pushed.",
  CARD_MODAL_HEIGHT_PERCENT: "\uD50C\uB798\uC2DC\uCE74\uB4DC \uB192\uC774 \uBE44\uC728",
  CARD_MODAL_SIZE_PERCENT_DESC: "\uBAA8\uBC14\uC77C \uBC84\uC804 \uD639\uC740 \uB9E4\uC6B0 \uD070 \uC774\uBBF8\uC9C0\uAC00 \uC788\uB294 \uACBD\uC6B0 100%\uB85C \uC124\uC815\uD574\uC57C \uD569\uB2C8\uB2E4.",
  RESET_DEFAULT: "\uAE30\uBCF8\uAC12\uC73C\uB85C \uCD08\uAE30\uD654",
  CARD_MODAL_WIDTH_PERCENT: "\uD50C\uB798\uC2DC\uCE74\uB4DC \uB108\uBE44 \uBE44\uC728",
  RANDOMIZE_CARD_ORDER: "\uB9AC\uBDF0\uC911\uC778 \uCE74\uB4DC\uC758 \uC21C\uC11C\uB97C \uB79C\uB364\uC73C\uB85C \uB450\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  REVIEW_CARD_ORDER_WITHIN_DECK: "Order cards in a deck are displayed during review",
  REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "Sequentially within a deck (All new cards first)",
  REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "Sequentially within a deck (All due cards first)",
  REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Randomly within a deck (All new cards first)",
  REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "Randomly within a deck (All due cards first)",
  REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
  REVIEW_DECK_ORDER: "Order decks are displayed during review",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL: "Sequentially (once all cards in previous deck reviewed)",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM: "Randomly (once all cards in previous deck reviewed)",
  REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
  DISABLE_CLOZE_CARDS: "\uBE48 \uCE78 \uCC44\uC6B0\uAE30 \uCE74\uB4DC\uB97C \uBE44\uD65C\uC131\uD654\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "==highlights== \uB97C \uBE48 \uCE78 \uCC44\uC6B0\uAE30\uB85C \uC804\uD658\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  CONVERT_HIGHLIGHTS_TO_CLOZES_DESC: '"\uBE48 \uCE78 \uCC44\uC6B0\uAE30 \uD328\uD134" \uC5D0\uC11C <code>${defaultPattern}</code> \uB97C \uCD94\uAC00/\uC81C\uAC70\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?',
  CONVERT_BOLD_TEXT_TO_CLOZES: "**bolded text** \uB97C \uBE48 \uCE78 \uCC44\uC6B0\uAE30\uB85C \uC804\uD658\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  CONVERT_BOLD_TEXT_TO_CLOZES_DESC: '"\uBE48 \uCE78 \uCC44\uC6B0\uAE30 \uD328\uD134" \uC5D0\uC11C <code>${defaultPattern}</code> \uB97C \uCD94\uAC00/\uC81C\uAC70\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?',
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "{{curly brackets}} \uB97C \uBE48 \uCE78 \uCC44\uC6B0\uAE30\uB85C \uC804\uD658\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC: '"\uBE48 \uCE78 \uCC44\uC6B0\uAE30 \uD328\uD134" \uC5D0\uC11C <code>${defaultPattern}</code> \uB97C \uCD94\uAC00/\uC81C\uAC70\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?',
  CLOZE_PATTERNS: "\uBE48 \uCE78 \uCC44\uC6B0\uAE30 \uD328\uD134",
  CLOZE_PATTERNS_DESC: '\uBE48 \uCE78 \uCC44\uC6B0\uAE30 \uD328\uD134\uC744 \uC785\uB825\uD574\uC8FC\uC138\uC694. \uC904\uBC14\uAFC8\uC73C\uB85C \uAD6C\uBD84\uD569\uB2C8\uB2E4. Check the <a href="${docsUrl}">wiki</a> for guidance.',
  INLINE_CARDS_SEPARATOR: "\uC778\uB77C\uC778 \uD50C\uB798\uC2DC\uCE74\uB4DC \uAD6C\uBD84\uC790",
  FIX_SEPARATORS_MANUALLY_WARNING: "\uC8FC\uC758: \uC774 \uC635\uC158\uC744 \uC218\uC815\uD55C \uD6C4\uC5D0\uB294 \uC774\uBBF8 \uC791\uC131\uB41C \uD50C\uB798\uC2DC\uCE74\uB4DC\uB97C \uC218\uB3D9\uC73C\uB85C \uC218\uC815\uD574\uC57C \uD568\uC744 \uC8FC\uC758\uD558\uC2ED\uC2DC\uC624.",
  INLINE_REVERSED_CARDS_SEPARATOR: "\uC778\uB77C\uC778 \uBC18\uC804 \uD50C\uB798\uC2DC\uCE74\uB4DC \uAD6C\uBD84\uC790",
  MULTILINE_CARDS_SEPARATOR: "\uC5EC\uB7EC \uC904 \uD50C\uB798\uC2DC\uCE74\uB4DC \uAD6C\uBD84\uC790",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "\uC5EC\uB7EC \uC904 \uBC18\uC804 \uD50C\uB798\uC2DC\uCE74\uB4DC \uAD6C\uBD84\uC790",
  MULTILINE_CARDS_END_MARKER: "\uD074\uB85C\uC988\uC640 \uB2E4\uC911 \uD589 \uD50C\uB798\uC2DC\uCE74\uB4DC\uC758 \uB05D\uC744 \uB098\uD0C0\uB0B4\uB294 \uBB38\uC790",
  NOTES: "\uB178\uD2B8",
  NOTE: "Note",
  REVIEW_PANE_ON_STARTUP: "Enable note review pane on startup",
  TAGS_TO_REVIEW: "\uB9AC\uBDF0\uC5D0 \uC0AC\uC6A9\uD560 \uD0DC\uADF8",
  TAGS_TO_REVIEW_DESC: "\uD0DC\uADF8\uB97C \uACF5\uBC31 \uB610\uB294 \uBE48 \uC904\uB85C \uAD6C\uBD84\uD574\uC11C \uC785\uB825\uD574\uC8FC\uC138\uC694. \uC608) '#review #tag2 #tag3'",
  OPEN_RANDOM_NOTE: "\uB9AC\uBDF0\uB97C \uC704\uD574 \uB79C\uB364 \uB178\uD2B8\uB97C \uC5FD\uB2C8\uB2E4.",
  OPEN_RANDOM_NOTE_DESC: "\uC774 \uC635\uC158\uC774 \uAEBC\uC838\uC788\uC73C\uBA74, \uB178\uD2B8\uB294 \uC911\uC694\uB3C4(\uD398\uC774\uC9C0 \uB7AD\uD06C)\uC5D0 \uB530\uB77C \uC815\uB82C\uB429\uB2C8\uB2E4.",
  AUTO_NEXT_NOTE: "\uB9AC\uBDF0 \uD6C4\uC5D0 \uB2E4\uC74C \uB178\uD2B8\uB97C \uC790\uB3D9\uC73C\uB85C \uC5FD\uB2C8\uB2E4.",
  ENABLE_FILE_MENU_REVIEW_OPTIONS: "\uD30C\uC77C \uBA54\uB274\uC5D0\uC11C \uAC80\uD1A0 \uC635\uC158\uC744 \uD65C\uC131\uD654\uD558\uC138\uC694 (\uC608: \uAC80\uD1A0: \uC26C\uC6C0, \uC88B\uC74C, \uC5B4\uB824\uC6C0)",
  ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "\uD30C\uC77C \uBA54\uB274\uC5D0\uC11C \uAC80\uD1A0 \uC635\uC158\uC744 \uBE44\uD65C\uC131\uD654\uD558\uBA74 \uD50C\uB7EC\uADF8\uC778 \uBA85\uB839\uC744 \uC0AC\uC6A9\uD574 \uB178\uD2B8\uB97C \uAC80\uD1A0\uD560 \uC218 \uC788\uC73C\uBA70, \uC815\uC758\uB41C \uACBD\uC6B0\uC5D0\uB294 \uAD00\uB828\uB41C \uB2E8\uCD95\uD0A4\uB3C4 \uC0AC\uC6A9\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.",
  MAX_N_DAYS_REVIEW_QUEUE: "\uC624\uB978\uCABD \uD328\uB110\uC5D0 \uD45C\uC2DC\uD560 \uCD5C\uB300 \uC77C\uC218",
  MIN_ONE_DAY: "\uC801\uC5B4\uB3C4 1\uC774\uC0C1\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
  VALID_NUMBER_WARNING: "\uC720\uD6A8\uD55C \uC22B\uC790\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694.",
  UI: "User Interface",
  OPEN_IN_TAB: "Open in new tab",
  OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
  SHOW_STATUS_BAR: "Show status bar",
  SHOW_STATUS_BAR_DESC: "Turn this off to hide the flashcard's review status in Obsidian's status bar",
  SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
  SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "\uB371 \uD2B8\uB9AC\uB294 \uCC98\uC74C\uC5D0 \uD655\uC7A5\uB41C \uAC83\uC73C\uB85C \uD45C\uC2DC\uB418\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "\uAC19\uC740 \uCE74\uB4DC\uC5D0 \uC911\uCCA9\uB41C \uB371\uC744 \uC811\uC73C\uB824\uBA74 \uC774 \uC635\uC158\uC744 \uB044\uC2ED\uC2DC\uC624. \uAC19\uC740 \uD30C\uC77C\uC5D0 \uC5EC\uB7EC \uB371\uC5D0 \uC18D\uD55C \uCE74\uB4DC\uAC00 \uC788\uB294 \uACBD\uC6B0 \uC720\uC6A9\uD569\uB2C8\uB2E4.",
  ALGORITHM: "\uC54C\uACE0\uB9AC\uC998",
  CHECK_ALGORITHM_WIKI: '\uB354 \uB9CE\uC740 \uC815\uBCF4\uB97C \uC6D0\uD558\uC2DC\uBA74, <a href="${algoUrl}">algorithm details</a>\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.',
  SM2_OSR_VARIANT: "OSR's variant of SM-2",
  BASE_EASE: "\uAE30\uBCF8 ease",
  BASE_EASE_DESC: "\uCD5C\uC19F\uAC12 = 130, \uC801\uC815\uCE58\uB294 \uB300\uB7B5 250\uC785\uB2C8\uB2E4.",
  BASE_EASE_MIN_WARNING: "\uAE30\uBCF8 ease\uB294 \uC801\uC5B4\uB3C4 130 \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
  LAPSE_INTERVAL_CHANGE: "\uD50C\uB798\uC2DC\uCE74\uB4DC/\uB178\uD2B8\uB97C \uC5B4\uB824\uC6C0(Hard)\uC73C\uB85C \uB9AC\uBDF0\uD588\uC744 \uB54C\uC758 \uAC04\uACA9 \uBCC0\uACBD",
  LAPSE_INTERVAL_CHANGE_DESC: "\uC0C8\uB85C\uC6B4 \uAC04\uACA9 = \uC774\uC804 \uAC04\uACA9 * \uAC04\uACA9\uBCC0\uACBD \uAC12 / 100.",
  EASY_BONUS: "\uC26C\uC6C0(Easy) \uBCF4\uB108\uC2A4",
  EASY_BONUS_DESC: "\uC26C\uC6C0(Easy) \uBCF4\uB108\uC2A4\uB294 \uD50C\uB798\uC2DC\uCE74\uB4DC/\uB178\uD2B8\uC5D0\uC11C \uC88B\uC74C(Good)\uACFC \uC26C\uC6C0(Easy) \uC0AC\uC774\uC758 \uAC04\uACA9 \uCC28\uC774\uB97C \uC124\uC815\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4. (\uCD5C\uC18C = 100%)",
  EASY_BONUS_MIN_WARNING: "\uC26C\uC6C0(Easy) \uBCF4\uB108\uC2A4\uB294 \uC801\uC5B4\uB3C4 100\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
  LOAD_BALANCE: "Enable load balancer",
  LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
  MAX_INTERVAL: "Maximum interval in days",
  MAX_INTERVAL_DESC: "\uAC04\uACA9\uC758 \uC0C1\uD55C\uC120\uC744 \uB458 \uC218 \uC788\uC2B5\uB2C8\uB2E4. (\uAE30\uBCF8\uAC12 = 100\uB144)",
  MAX_INTERVAL_MIN_WARNING: "\uCD5C\uB300 \uAC04\uACA9\uC740 \uC801\uC5B4\uB3C4 1\uC77C\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
  MAX_LINK_CONTRIB: "\uCD5C\uB300 \uC5F0\uACB0 \uAE30\uC5EC\uB3C4",
  MAX_LINK_CONTRIB_DESC: "\uB9C1\uD06C\uB41C \uB178\uD2B8\uC758 \uCD08\uAE30 ease\uC5D0 \uB300\uD55C \uAC00\uC911\uCE58\uAC00 \uC801\uC6A9\uB41C ease\uC758 \uCD5C\uB300 \uAE30\uC5EC\uB3C4\uC785\uB2C8\uB2E4.",
  LOGGING: "\uB85C\uAE45",
  DISPLAY_SCHEDULING_DEBUG_INFO: "\uB514\uBC84\uAE45 \uC815\uBCF4\uB97C \uAC1C\uBC1C\uC790 \uCF58\uC194\uC5D0 \uD45C\uC2DC\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C",
  DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
  SCHEDULING: "Scheduling",
  EXPERIMENTAL: "Experimental",
  HELP: "Help",
  STORE_IN_NOTES: "In the notes",
  // sidebar.ts
  NOTES_REVIEW_QUEUE: "\uB9AC\uBDF0\uD560 \uB178\uD2B8 \uB300\uAE30\uC5F4",
  CLOSE: "\uB2EB\uAE30",
  NEW: "New",
  YESTERDAY: "\uC5B4\uC81C",
  TODAY: "\uC624\uB298",
  TOMORROW: "\uB0B4\uC77C",
  // stats-modal.tsx
  STATS_TITLE: "\uD1B5\uACC4",
  MONTH: "\uC6D4",
  QUARTER: "\uBD84\uAE30",
  YEAR: "\uB144",
  LIFETIME: "\uD3C9\uC0DD",
  FORECAST: "\uC608\uCE21",
  FORECAST_DESC: "\uC774\uD6C4\uC5D0 \uD559\uC2B5\uD560 \uCE74\uB4DC\uC758 \uC218",
  SCHEDULED: "Scheduled",
  DAYS: "\uC77C",
  NUMBER_OF_CARDS: "\uCE74\uB4DC\uC758 \uC218",
  REVIEWS_PER_DAY: "\uD3C9\uADE0: ${avg} \uB9AC\uBDF0/\uC77C",
  INTERVALS: "\uAC04\uACA9",
  INTERVALS_DESC: "\uB9AC\uBDF0\uB97C \uB2E4\uC2DC \uD560 \uB54C \uAE4C\uC9C0\uC758 \uAE30\uAC04",
  COUNT: "Count",
  INTERVALS_SUMMARY: "\uD3C9\uADE0 \uAC04\uACA9: ${avg}, \uAC00\uC7A5 \uAE34 \uAC04\uACA9: ${longest}",
  EASES: "Eases",
  EASES_SUMMARY: "Average ease: ${avgEase}",
  EASE: "Ease",
  CARD_TYPES: "\uCE74\uB4DC \uD0C0\uC785",
  CARD_TYPES_DESC: "\uC5EC\uAE30\uC5D0\uB294 \uBB3B\uC5B4\uB454 \uCE74\uB4DC\uB3C4 \uD3EC\uD568\uB429\uB2C8\uB2E4.",
  CARD_TYPE_NEW: "New",
  CARD_TYPE_YOUNG: "Young",
  CARD_TYPE_MATURE: "Mature",
  CARD_TYPES_SUMMARY: "\uC804\uCCB4 \uCE74\uB4DC \uC218: ${totalCardsCount}",
  SEARCH: "Search",
  PREVIOUS: "Previous",
  NEXT: "Next"
};

// src/lang/locale/mr.ts
var mr_default = {};

// src/lang/locale/nl.ts
var nl_default = {};

// src/lang/locale/no.ts
var no_default = {};

// src/lang/locale/pl.ts
var pl_default = {
  // flashcard-modal.tsx
  DECKS: "Talie",
  DUE_CARDS: "Fiszki z terminem",
  NEW_CARDS: "Nowe fiszki",
  TOTAL_CARDS: "Wszystkie karty",
  BACK: "Wstecz",
  SKIP: "Pomi\u0144",
  EDIT_CARD: "Edytuj kart\u0119",
  RESET_CARD_PROGRESS: "Zresetuj post\u0119p karty",
  HARD: "Trudne",
  GOOD: "\u015Arednio Trudne",
  EASY: "\u0141atwe",
  SHOW_ANSWER: "Poka\u017C odpowied\u017A",
  CARD_PROGRESS_RESET: "Post\u0119p karty zosta\u0142 zresetowany.",
  SAVE: "Zapisz",
  CANCEL: "Anuluj",
  NO_INPUT: "Nie wprowadzono warto\u015Bci.",
  CURRENT_EASE_HELP_TEXT: "Aktualna \u0142atwo\u015B\u0107: ",
  CURRENT_INTERVAL_HELP_TEXT: "Aktualny interwa\u0142: ",
  CARD_GENERATED_FROM: "Wygenerowano z: ${notePath}",
  // main.ts
  OPEN_NOTE_FOR_REVIEW: "Otw\xF3rz notatk\u0119 do przegl\u0105du",
  REVIEW_CARDS: "Przegl\u0105daj fiszki",
  REVIEW_DIFFICULTY_FILE_MENU: "Przegl\u0105daj: ${difficulty}",
  REVIEW_NOTE_DIFFICULTY_CMD: "Przegl\u0105daj notatk\u0119 jako ${difficulty}",
  CRAM_ALL_CARDS: "Wybierz tali\u0119 do intensywnego uczenia",
  REVIEW_ALL_CARDS: "Przegl\u0105daj fiszki ze wszystkich notatek",
  REVIEW_CARDS_IN_NOTE: "Przegl\u0105daj fiszki w tej notatce",
  CRAM_CARDS_IN_NOTE: "Intensywne uczenie fiszek w tej notatce",
  VIEW_STATS: "Wy\u015Bwietl statystyki",
  OPEN_REVIEW_QUEUE_VIEW: "Open Notes Review Queue in sidebar",
  STATUS_BAR: "Przegl\u0105daj: ${dueNotesCount} notatek, ${dueFlashcardsCount} fiszek z terminem",
  SYNC_TIME_TAKEN: "Synchronizacja zaj\u0119\u0142a ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "Notatka jest zapisana w folderze zignorowanym (sprawd\u017A ustawienia).",
  PLEASE_TAG_NOTE: "Prosz\u0119 odpowiednio otagowa\u0107 notatk\u0119 do przegl\u0105du (w ustawieniach).",
  RESPONSE_RECEIVED: "Otrzymano odpowied\u017A.",
  NO_DECK_EXISTS: "Nie istnieje talia o nazwie ${deckName}",
  ALL_CAUGHT_UP: "Jeste\u015B teraz na bie\u017C\u0105co :D.",
  // scheduling.ts
  DAYS_STR_IVL: "${interval} dni",
  MONTHS_STR_IVL: "${interval} miesi\u0119cy",
  YEARS_STR_IVL: "${interval} lata",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}r",
  // settings.ts
  SETTINGS_HEADER: "Spaced Repetition",
  GROUP_TAGS_FOLDERS: "Tags & Folders",
  GROUP_FLASHCARD_REVIEW: "Flashcard Review",
  GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
  GROUP_DATA_STORAGE: "Storage of Scheduling Data",
  GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
  GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
  GROUP_CONTRIBUTING: "Contributing",
  CHECK_WIKI: 'Aby uzyska\u0107 wi\u0119cej informacji, sprawd\u017A <a href="${wikiUrl}">wiki</a>.',
  GITHUB_DISCUSSIONS: 'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
  GITHUB_ISSUES: 'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
  GITHUB_SOURCE_CODE: 'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
  CODE_CONTRIBUTION_INFO: '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
  TRANSLATION_CONTRIBUTION_INFO: '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
  FOLDERS_TO_IGNORE: "Foldery do zignorowania",
  FOLDERS_TO_IGNORE_DESC: "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
  OBSIDIAN_INTEGRATION: "Integration into Obsidian",
  FLASHCARDS: "Fiszki",
  FLASHCARD_EASY_LABEL: "Tekst przycisku \u0141atwe",
  FLASHCARD_GOOD_LABEL: "Tekst przycisku \u015Arednio trudne",
  FLASHCARD_HARD_LABEL: "Tekst przycisku Trudne",
  FLASHCARD_EASY_DESC: 'Dostosuj etykiet\u0119 dla przycisku "\u0141atwe"',
  FLASHCARD_GOOD_DESC: 'Dostosuj etykiet\u0119 dla przycisku "\u015Arednio trudne"',
  FLASHCARD_HARD_DESC: 'Dostosuj etykiet\u0119 dla przycisku "Trudne"',
  REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
  REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
  FLASHCARD_TAGS: "Tagi fiszek",
  FLASHCARD_TAGS_DESC: "Wprowad\u017A tagi oddzielone spacj\u0105 lub nowymi liniami, np. #fiszki #talia2 #talia3.",
  CONVERT_FOLDERS_TO_DECKS: "Czy konwertowa\u0107 foldery na talie i podtalie?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "Jest to alternatywa dla opcji tag\xF3w fiszek powy\u017Cej.",
  INLINE_SCHEDULING_COMMENTS: "Czy zachowa\u0107 komentarz harmonogramowania w tej samej linii co ostatnia linia fiszki?",
  INLINE_SCHEDULING_COMMENTS_DESC: "W\u0142\u0105czenie tej opcji sprawi, \u017Ce komentarze HTML nie b\u0119d\u0105 przerywa\u0107 formatowania listy.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Czy ukrywa\u0107 karty rodze\u0144stwa do nast\u0119pnego dnia?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "Rodze\u0144stwo to karty wygenerowane z tego samego tekstu karty, np. usuni\u0119cia zamaskowane",
  SHOW_CARD_CONTEXT: "Czy pokazywa\u0107 kontekst na kartach?",
  SHOW_CARD_CONTEXT_DESC: "np. Tytu\u0142 > Nag\u0142\xF3wek 1 > Podnag\u0142\xF3wek > ... > Podnag\u0142\xF3wek",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC: "Useful to know how far in the future your cards are being pushed.",
  CARD_MODAL_HEIGHT_PERCENT: "Procentowa wysoko\u015B\u0107 fiszki",
  CARD_MODAL_SIZE_PERCENT_DESC: "Powinno by\u0107 ustawione na 100% na urz\u0105dzeniach mobilnych lub gdy masz bardzo du\u017Ce obrazy",
  RESET_DEFAULT: "Zresetuj do domy\u015Blnych",
  CARD_MODAL_WIDTH_PERCENT: "Procentowa szeroko\u015B\u0107 fiszki",
  RANDOMIZE_CARD_ORDER: "Czy losowa\u0107 kolejno\u015B\u0107 kart podczas przegl\u0105du?",
  REVIEW_CARD_ORDER_WITHIN_DECK: "Kolejno\u015B\u0107 kart w talii wy\u015Bwietlana podczas przegl\u0105dania",
  REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "Kolejno w ramach talii (Najpierw wszystkie nowe karty)",
  REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "Kolejno w ramach talii (Najpierw wszystkie karty z terminem)",
  REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Losowo w ramach talii (Najpierw wszystkie nowe karty)",
  REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "Losowo w ramach talii (Najpierw wszystkie karty z terminem)",
  REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Losowa karta z losowej talii",
  REVIEW_DECK_ORDER: "Kolejno\u015B\u0107 talii wy\u015Bwietlana podczas przegl\u0105dania",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL: "Kolejno (gdy wszystkie karty w poprzedniej talii przegl\u0105dni\u0119te)",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM: "Losowo (gdy wszystkie karty w poprzedniej talii przegl\u0105dni\u0119te)",
  REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Losowa karta z losowej talii",
  DISABLE_CLOZE_CARDS: "Wy\u0142\u0105czy\u0107 karty zamaskowane?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "Konwertowa\u0107 ==pod\u015Bwietlenia== na karty zamaskowane?",
  CONVERT_HIGHLIGHTS_TO_CLOZES_DESC: 'Dodaj/usu\u0144 <code>${defaultPattern}</code> z "Wzory kart zamaskowanych"',
  CONVERT_BOLD_TEXT_TO_CLOZES: "Konwertowa\u0107 pogrubiony tekst na karty zamaskowane?",
  CONVERT_BOLD_TEXT_TO_CLOZES_DESC: 'Dodaj/usu\u0144 <code>${defaultPattern}</code> z "Wzory kart zamaskowanych"',
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "Konwertowa\u0107 {{klamry}} na karty zamaskowane?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC: 'Dodaj/usu\u0144 <code>${defaultPattern}</code> z "Wzory kart zamaskowanych"',
  CLOZE_PATTERNS: "Wzory kart zamaskowanych",
  CLOZE_PATTERNS_DESC: 'Wprowad\u017A wzory kart zamaskowanych oddzielone nowymi liniami. Check the <a href="${docsUrl}">wiki</a> for guidance.',
  INLINE_CARDS_SEPARATOR: "Separator dla kart zamaskowanych w linii",
  FIX_SEPARATORS_MANUALLY_WARNING: "Pami\u0119taj, \u017Ce po zmianie tego musisz r\u0119cznie edytowa\u0107 wszystkie karty zamaskowane, kt\xF3re ju\u017C masz.",
  INLINE_REVERSED_CARDS_SEPARATOR: "Separator dla kart zamaskowanych odwr\xF3conych w linii",
  MULTILINE_CARDS_SEPARATOR: "Separator dla kart zamaskowanych wieloliniowych",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "Separator dla kart zamaskowanych odwr\xF3conych wieloliniowych",
  MULTILINE_CARDS_END_MARKER: "Caracteres que denotam o fim de clozes e flashcards multilineares",
  NOTES: "Notatki",
  NOTE: "Note",
  REVIEW_PANE_ON_STARTUP: "W\u0142\u0105czy\u0107 panel przegl\u0105du notatek przy starcie",
  TAGS_TO_REVIEW: "Tagi do przegl\u0105du",
  TAGS_TO_REVIEW_DESC: "Wprowad\u017A tagi oddzielone spacj\u0105 lub nowymi liniami, np. #przegl\u0105d #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "Otw\xF3rz losow\u0105 notatk\u0119 do przegl\u0105du",
  OPEN_RANDOM_NOTE_DESC: "Po wy\u0142\u0105czeniu tej opcji notatki s\u0105 uporz\u0105dkowane wed\u0142ug istotno\u015Bci (PageRank).",
  AUTO_NEXT_NOTE: "Automatycznie otwiera\u0107 nast\u0119pn\u0105 notatk\u0119 po przegl\u0105dzie",
  ENABLE_FILE_MENU_REVIEW_OPTIONS: "Wy\u0142\u0105czy\u0107 opcje przegl\u0105du w menu pliku, tj. Przegl\u0105daj: \u0141atwe Dobrze Trudne",
  ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "Je\u015Bli wy\u0142\u0105czysz opcje przegl\u0105du w menu Plik, mo\u017Cesz przegl\u0105da\u0107 swoje notatki za pomoc\u0105 polece\u0144 wtyczki i, je\u015Bli je zdefiniowa\u0142e\u015B, przypisanych skr\xF3t\xF3w klawiszowych.",
  MAX_N_DAYS_REVIEW_QUEUE: "Maksymalna liczba dni do wy\u015Bwietlenia w panelu prawym",
  MIN_ONE_DAY: "Liczba dni musi wynosi\u0107 co najmniej 1.",
  VALID_NUMBER_WARNING: "Podaj prawid\u0142ow\u0105 liczb\u0119.",
  UI: "User Interface",
  OPEN_IN_TAB: "Open in new tab",
  OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
  SHOW_STATUS_BAR: "Show status bar",
  SHOW_STATUS_BAR_DESC: "Turn this off to hide the flashcard's review status in Obsidian's status bar",
  SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
  SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "Podtalie powinny by\u0107 pocz\u0105tkowo wy\u015Bwietlane rozszerzone",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "Wy\u0142\u0105cz to, aby zwin\u0105\u0107 zagnie\u017Cd\u017Cone talie w tej samej karcie. Przydatne, je\u015Bli karty nale\u017C\u0105 do wielu talii w tym samym pliku.",
  ALGORITHM: "Algorytm",
  CHECK_ALGORITHM_WIKI: 'Aby uzyska\u0107 wi\u0119cej informacji, sprawd\u017A <a href="${algoUrl}">implementacj\u0119 algorytmu</a>.',
  SM2_OSR_VARIANT: "OSR's variant of SM-2",
  BASE_EASE: "Podstawowa \u0142atwo\u015B\u0107",
  BASE_EASE_DESC: "minimum = 130, preferowana warto\u015B\u0107 to oko\u0142o 250.",
  BASE_EASE_MIN_WARNING: "Podstawowa \u0142atwo\u015B\u0107 musi wynosi\u0107 co najmniej 130.",
  LAPSE_INTERVAL_CHANGE: "Zmiana interwa\u0142u podczas przegl\u0105dania fiszki/notatki jako trudne",
  LAPSE_INTERVAL_CHANGE_DESC: "nowyInterwa\u0142 = staryInterwa\u0142 * zmianaInterwa\u0142u / 100.",
  EASY_BONUS: "Bonus za \u0142atwe",
  EASY_BONUS_DESC: "Bonus za \u0142atwe pozwala ustawi\u0107 r\xF3\u017Cnic\u0119 w interwa\u0142ach mi\u0119dzy odpowiedziami \u015Arednio trudne i \u0141atwe na fiszce/notatce (minimum = 100%).",
  EASY_BONUS_MIN_WARNING: "Bonus za \u0142atwe musi wynosi\u0107 co najmniej 100.",
  LOAD_BALANCE: "Enable load balancer",
  LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
  MAX_INTERVAL: "Maksymalny interwa\u0142 w dniach",
  MAX_INTERVAL_DESC: "Pozwala na ustawienie g\xF3rnego limitu interwa\u0142u (domy\u015Blnie = 100 lat).",
  MAX_INTERVAL_MIN_WARNING: "Maksymalny interwa\u0142 musi wynosi\u0107 co najmniej 1 dzie\u0144.",
  MAX_LINK_CONTRIB: "Maksymalny wk\u0142ad \u0142\u0105cza",
  MAX_LINK_CONTRIB_DESC: "Maksymalny wk\u0142ad wa\u017Conej \u0142atwo\u015Bci po\u0142\u0105czonych notatek do pocz\u0105tkowej \u0142atwo\u015Bci.",
  LOGGING: "Logowanie",
  DISPLAY_SCHEDULING_DEBUG_INFO: "Wy\u015Bwietl informacje debugowania w konsoli deweloperskiej",
  DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
  SCHEDULING: "Scheduling",
  EXPERIMENTAL: "Experimental",
  HELP: "Help",
  STORE_IN_NOTES: "In the notes",
  // sidebar.ts
  NOTES_REVIEW_QUEUE: "Kolejka przegl\u0105du notatek",
  CLOSE: "Zamknij",
  NEW: "Nowe",
  YESTERDAY: "Wczoraj",
  TODAY: "Dzisiaj",
  TOMORROW: "Jutro",
  // stats-modal.tsx
  STATS_TITLE: "Statystyki",
  MONTH: "Miesi\u0105c",
  QUARTER: "Kwarta\u0142",
  YEAR: "Rok",
  LIFETIME: "Ca\u0142e \u017Cycie",
  FORECAST: "Prognoza",
  FORECAST_DESC: "Liczba kart z terminem w przysz\u0142o\u015Bci",
  SCHEDULED: "Zaplanowane",
  DAYS: "Dni",
  NUMBER_OF_CARDS: "Liczba kart",
  REVIEWS_PER_DAY: "\u015Arednio: ${avg} przegl\u0105d\xF3w/dzie\u0144",
  INTERVALS: "Interwa\u0142y",
  INTERVALS_DESC: "Op\xF3\u017Anienia przed ponownym pokazaniem przegl\u0105d\xF3w",
  COUNT: "Liczba",
  INTERVALS_SUMMARY: "\u015Aredni interwa\u0142: ${avg}, Najd\u0142u\u017Cszy interwa\u0142: ${longest}",
  EASES: "\u0141atwo\u015Bci",
  EASES_SUMMARY: "\u015Arednia \u0142atwo\u015B\u0107: ${avgEase}",
  EASE: "Ease",
  CARD_TYPES: "Typy kart",
  CARD_TYPES_DESC: "Obejmuje tak\u017Ce ukryte karty, je\u015Bli takie s\u0105",
  CARD_TYPE_NEW: "Nowe",
  CARD_TYPE_YOUNG: "M\u0142ode",
  CARD_TYPE_MATURE: "Stare",
  CARD_TYPES_SUMMARY: "\u0141\u0105czna liczba kart: ${totalCardsCount}",
  SEARCH: "Search",
  PREVIOUS: "Previous",
  NEXT: "Next"
};

// src/lang/locale/pt.ts
var pt_default = {};

// src/lang/locale/pt-br.ts
var pt_br_default = {
  // flashcard-modal.tsx
  DECKS: "Baralhos",
  DUE_CARDS: "Cartas para Colocar em Dia",
  NEW_CARDS: "Novas Cartas",
  TOTAL_CARDS: "Total de Cartas",
  BACK: "Voltar",
  SKIP: "Pular",
  EDIT_CARD: "Editar Cart\xE3o",
  RESET_CARD_PROGRESS: "Reiniciar o Progresso da Carta",
  HARD: "Dif\xEDcil",
  GOOD: "OK",
  EASY: "F\xE1cil",
  SHOW_ANSWER: "Mostrar Resposta",
  CARD_PROGRESS_RESET: "O Progresso da Carta foi reiniciado",
  SAVE: "Salvar",
  CANCEL: "Cancelar",
  NO_INPUT: "Nenhuma entrada fornecida.",
  CURRENT_EASE_HELP_TEXT: "Facilidade atual: ",
  CURRENT_INTERVAL_HELP_TEXT: "Intervalo atual: ",
  CARD_GENERATED_FROM: "Gerada a partir de: ${notePath}",
  // main.ts
  OPEN_NOTE_FOR_REVIEW: "Abrir uma nota para revisar",
  REVIEW_CARDS: "Revisar flashcards",
  REVIEW_DIFFICULTY_FILE_MENU: "Revis\xE3o: ${difficulty}",
  REVIEW_NOTE_DIFFICULTY_CMD: "Revisar nota como ${difficulty}",
  REVIEW_ALL_CARDS: "Revisar flashcards de todas as notas",
  CRAM_ALL_CARDS: "Selecione um baralho para revisar",
  REVIEW_CARDS_IN_NOTE: "Revisar flashcards nessa nota",
  CRAM_CARDS_IN_NOTE: "Revisar todas as flashcards nessa nota",
  VIEW_STATS: "Ver estat\xEDsticas",
  OPEN_REVIEW_QUEUE_VIEW: "Open Notes Review Queue in sidebar",
  STATUS_BAR: "Revis\xE3o: ${dueNotesCount} nota(s), ${dueFlashcardsCount} Carta(s) para colocar em dia",
  SYNC_TIME_TAKEN: "Sincroniza\xE7\xE3o levou ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "Nota \xE9 salva na pasta ignorada (cheque as configura\xE7\xF5es).",
  PLEASE_TAG_NOTE: "Por favor etiquete a nota apropriadamente para revisar (nas configura\xE7\xF5es).",
  RESPONSE_RECEIVED: "Resposta recebida.",
  NO_DECK_EXISTS: "Nenhum baralho existe para ${deckName}",
  ALL_CAUGHT_UP: "Voc\xEA colocou tudo em dia agora :D.",
  // scheduling.ts
  DAYS_STR_IVL: "${interval} dia(s)",
  MONTHS_STR_IVL: "${interval} m\xEAs(es)",
  YEARS_STR_IVL: "${interval} ano(s)",
  DAYS_STR_IVL_MOBILE: "${interval}d",
  MONTHS_STR_IVL_MOBILE: "${interval}m",
  YEARS_STR_IVL_MOBILE: "${interval}a",
  // settings.ts
  SETTINGS_HEADER: "Spaced Repetition",
  GROUP_TAGS_FOLDERS: "Tags & Folders",
  GROUP_FLASHCARD_REVIEW: "Flashcard Review",
  GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
  GROUP_DATA_STORAGE: "Storage of Scheduling Data",
  GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
  GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
  GROUP_CONTRIBUTING: "Contributing",
  CHECK_WIKI: 'Para mais informa\xE7\xF5es, cheque a <a href="${wikiUrl}">wiki</a>.',
  GITHUB_DISCUSSIONS: 'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
  GITHUB_ISSUES: 'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
  GITHUB_SOURCE_CODE: 'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
  CODE_CONTRIBUTION_INFO: '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
  TRANSLATION_CONTRIBUTION_INFO: '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
  FOLDERS_TO_IGNORE: "Pastas para ignorar",
  FOLDERS_TO_IGNORE_DESC: "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
  OBSIDIAN_INTEGRATION: "Integration into Obsidian",
  FLASHCARDS: "Flashcards",
  FLASHCARD_EASY_LABEL: "Texto do Bot\xE3o de F\xE1cil",
  FLASHCARD_GOOD_LABEL: "Texto do Bot\xE3o de OK",
  FLASHCARD_HARD_LABEL: "Texto do Bot\xE3o de Dif\xEDcil",
  FLASHCARD_EASY_DESC: 'Customize o r\xF3tulo para o bot\xE3o de "F\xE1cil"',
  FLASHCARD_GOOD_DESC: 'Customize o r\xF3tulo para o bot\xE3o de "OK"',
  FLASHCARD_HARD_DESC: 'Customize o r\xF3tulo para o bot\xE3o de "Dif\xEDcil"',
  REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
  REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
  FLASHCARD_TAGS: "Etiquetas dos Flashcards",
  FLASHCARD_TAGS_DESC: "Insira etiquetas separadas por espa\xE7os ou quebras de linha ex: #flashcards #baralho2 #baralho3.",
  CONVERT_FOLDERS_TO_DECKS: "Converter pastas para baralhos e sub-baralhos?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "Isso \xE9 uma alternativa para a op\xE7\xE3o de etiqueta dos Flashcards em cima.",
  INLINE_SCHEDULING_COMMENTS: "Salvar coment\xE1rios de agendamento na mesma linha que a \xFAltima linha do flashcard?",
  INLINE_SCHEDULING_COMMENTS_DESC: "Ligar isso vai fazer com que os coment\xE1rios em HTML n\xE3o quebrem a formata\xE7\xE3o de listas.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Enterrar cartas irm\xE3s at\xE9 o pr\xF3ximo dia?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "Cartas irm\xE3s s\xE3o geradas pelo texto da mesma carta ex: omiss\xE3o de palavras",
  SHOW_CARD_CONTEXT: "Mostrar contexto nas cartas?",
  SHOW_CARD_CONTEXT_DESC: "ex: T\xEDtulo > Cabe\xE7alho 1 > Subcabe\xE7alho > ... > Subcabe\xE7alho",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC: "Useful to know how far in the future your cards are being pushed.",
  CARD_MODAL_HEIGHT_PERCENT: "Porcentagem da Altura do Flashcard",
  CARD_MODAL_SIZE_PERCENT_DESC: "Deveria estar configurado em 100% em dispositivos m\xF3veis ou se voc\xEA tem imagens muito grandes",
  RESET_DEFAULT: "Reiniciar para a pr\xE9-defini\xE7\xE3o",
  CARD_MODAL_WIDTH_PERCENT: "Porcentagem de Largura do Flashcard",
  RANDOMIZE_CARD_ORDER: "Aleatorizar a ordem das cartas durante a revis\xE3o?",
  REVIEW_CARD_ORDER_WITHIN_DECK: "Order cards in a deck are displayed during review",
  REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "Sequentially within a deck (All new cards first)",
  REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "Sequentially within a deck (All due cards first)",
  REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Randomly within a deck (All new cards first)",
  REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "Randomly within a deck (All due cards first)",
  REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
  REVIEW_DECK_ORDER: "Order decks are displayed during review",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL: "Sequentially (once all cards in previous deck reviewed)",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM: "Randomly (once all cards in previous deck reviewed)",
  REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Random card from random deck",
  DISABLE_CLOZE_CARDS: "Desabilitar cartas que usam omiss\xE3o de palavras?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "Converter ==marca-texto== em omiss\xF5es?",
  CONVERT_HIGHLIGHTS_TO_CLOZES_DESC: 'Adiciona/remove o <code>${defaultPattern}</code> dos seus "Padr\xF5es de Omiss\xE3o"',
  CONVERT_BOLD_TEXT_TO_CLOZES: "Converter **texto em negrito** em omiss\xF5es?",
  CONVERT_BOLD_TEXT_TO_CLOZES_DESC: 'Adiciona/remove o <code>${defaultPattern}</code> dos seus "Padr\xF5es de Omiss\xE3o"',
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "Converter {{chaves}} em omiss\xF5es?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC: 'Adiciona/remove o <code>${defaultPattern}</code> dos seus "Padr\xF5es de Omiss\xE3o"',
  CLOZE_PATTERNS: "Padr\xF5es de Omiss\xE3o",
  CLOZE_PATTERNS_DESC: 'Entre os padr\xF5es de omiss\xE3o separados por quebras de linha. Check the <a href="${docsUrl}">wiki</a> for guidance.',
  INLINE_CARDS_SEPARATOR: "Separador para flashcards inline",
  FIX_SEPARATORS_MANUALLY_WARNING: "Note que depois de mudar isso voc\xEA vai ter que manualmente mudar quaisquer flashcards que voc\xEA tenha.",
  INLINE_REVERSED_CARDS_SEPARATOR: "Separador para flashcards inline reversos",
  MULTILINE_CARDS_SEPARATOR: "Separador para flashcards de m\xFAltiplas linhas",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "Separador para flashcards de m\xFAltiplas linhas reversos",
  MULTILINE_CARDS_END_MARKER: "Caracteres que denotam o fim de clozes e flashcards multilinha",
  NOTES: "Notas",
  NOTE: "Note",
  REVIEW_PANE_ON_STARTUP: "Habilitar painel de revis\xE3o de notas na inicializa\xE7\xE3o",
  TAGS_TO_REVIEW: "Etiquetas para revisar",
  TAGS_TO_REVIEW_DESC: "Insira etiquetas separadas por espa\xE7os ou quebra de linhas ex: #revisar #etiqueta2 #etiqueta3.",
  OPEN_RANDOM_NOTE: "Abrir uma nota aleat\xF3ria para revisar",
  OPEN_RANDOM_NOTE_DESC: "Quando voc\xEA desabilitar isso, as notas v\xE3o ser ordenadas por import\xE2ncia (PageRank).",
  AUTO_NEXT_NOTE: "Abrir a pr\xF3xima nota automaticamente depois de uma revis\xE3o",
  ENABLE_FILE_MENU_REVIEW_OPTIONS: "Ative as op\xE7\xF5es de revis\xE3o no menu Arquivo (ex.: Revis\xE3o: F\xE1cil, OK, Dif\xEDcil)",
  ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "Se voc\xEA desativar as op\xE7\xF5es de revis\xE3o no menu Arquivo, poder\xE1 revisar suas anota\xE7\xF5es usando os comandos do plugin e, se os tiver definido, as teclas de atalho associadas.",
  MAX_N_DAYS_REVIEW_QUEUE: "N\xFAmero m\xE1ximo de dias para exibir no painel direito",
  MIN_ONE_DAY: "O n\xFAmero de dias deve ser pelo menos 1.",
  VALID_NUMBER_WARNING: "Por favor Insira um n\xFAmero v\xE1lido.",
  UI: "User Interface",
  OPEN_IN_TAB: "Open in new tab",
  OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
  SHOW_STATUS_BAR: "Show status bar",
  SHOW_STATUS_BAR_DESC: "Turn this off to hide the flashcard's review status in Obsidian's status bar",
  SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
  SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "\xC1rvores de baralhos devem inicialmente ser exibidas como expandidas",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "Desabilite isso para colapsar baralhos que est\xE3o um dentro do outro na mesma carta. \xDAtil se voc\xEA tem cartas que pertencem a muitos baralhos em um mesmo arquivo.",
  ALGORITHM: "Algor\xEDtmo",
  CHECK_ALGORITHM_WIKI: 'Para mais informa\xE7\xF5es, cheque a <a href="${algoUrl}">implementa\xE7\xE3o do algor\xEDtmo</a>.',
  SM2_OSR_VARIANT: "OSR's variant of SM-2",
  BASE_EASE: "Facilidade base",
  BASE_EASE_DESC: "m\xEDnimo = 130, preferivelmente por volta de 250.",
  BASE_EASE_MIN_WARNING: "A facilidade base deve ser pelo menos 130.",
  LAPSE_INTERVAL_CHANGE: "Mudan\xE7a de intervalo quando voc\xEA revisa um(a) flashcard/nota como dif\xEDcil",
  LAPSE_INTERVAL_CHANGE_DESC: "novoIntervalo = velhoIntervalo * mudancaIntervalo / 100.",
  EASY_BONUS: "B\xF4nus de F\xE1cil",
  EASY_BONUS_DESC: "O b\xF4nus de f\xE1cil te permite mudar a difer\xEAncia entre intervalos de responder OK e F\xE1cil em um(a) flashcard/nota (m\xEDnimo = 100%).",
  EASY_BONUS_MIN_WARNING: "O b\xF4nus de f\xE1cil deve ser pelo menos 100.",
  LOAD_BALANCE: "Enable load balancer",
  LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
  MAX_INTERVAL: "Intervalo m\xE1ximo em dias",
  MAX_INTERVAL_DESC: "Te permite colocar um limite m\xE1ximo no intervalo (pr\xE9-defini\xE7\xE3o = 100 anos).",
  MAX_INTERVAL_MIN_WARNING: "O intervalo m\xE1ximo deve ser pelo menos 1 dia.",
  MAX_LINK_CONTRIB: "Contribui\xE7\xE3o M\xE1xima de Links",
  MAX_LINK_CONTRIB_DESC: "Contribui\xE7\xE3o m\xE1xima da facilidade ponderada das notas linkadas \xE0 facilidade inicial.",
  LOGGING: "Logging",
  DISPLAY_SCHEDULING_DEBUG_INFO: "Mostrar informa\xE7\xE3o de debugging no console de desenvolvimento",
  DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
  SCHEDULING: "Scheduling",
  EXPERIMENTAL: "Experimental",
  HELP: "Help",
  STORE_IN_NOTES: "In the notes",
  // sidebar.ts
  NOTES_REVIEW_QUEUE: "Fila de Notas para Revisar",
  CLOSE: "Fechar",
  NEW: "Novo",
  YESTERDAY: "Ontem",
  TODAY: "Hoje",
  TOMORROW: "Amanh\xE3",
  // stats-modal.tsx
  STATS_TITLE: "Estat\xEDsticas",
  MONTH: "M\xEAs",
  QUARTER: "Trimestre",
  YEAR: "Ano",
  LIFETIME: "Tempo Total",
  FORECAST: "Previs\xE3o",
  FORECAST_DESC: "O n\xFAmero de cartas a serem colocadas em dia no futuro",
  SCHEDULED: "Agendado",
  DAYS: "Dias",
  NUMBER_OF_CARDS: "N\xFAmero de cartas",
  REVIEWS_PER_DAY: "M\xE9dia: ${avg} revis\xF5es/dia",
  INTERVALS: "Intervalos",
  INTERVALS_DESC: "Atrasos at\xE9 que as revis\xF5es sejam exibidas de novo",
  COUNT: "Contagem",
  INTERVALS_SUMMARY: "Intervalo em m\xE9dia: ${avg}, Maior intervalo: ${longest}",
  EASES: "Facilidades",
  EASES_SUMMARY: "Facilidade em m\xE9dia: ${avgEase}",
  EASE: "Ease",
  CARD_TYPES: "Tipos de Cartas",
  CARD_TYPES_DESC: "Isso tamb\xE9m inclui cartas enterradas, caso existam",
  CARD_TYPE_NEW: "Novo",
  CARD_TYPE_YOUNG: "Jovem",
  CARD_TYPE_MATURE: "Amadurecido",
  CARD_TYPES_SUMMARY: "Total de cartas: ${totalCardsCount}",
  SEARCH: "Search",
  PREVIOUS: "Previous",
  NEXT: "Next"
};

// src/lang/locale/ro.ts
var ro_default = {};

// src/lang/locale/ru.ts
var ru_default = {
  // flashcard-modal.tsx
  DECKS: "\u041A\u043E\u043B\u043E\u0434\u044B",
  DUE_CARDS: "\u041F\u043E\u0432\u0442\u043E\u0440\u044F\u0435\u043C\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  NEW_CARDS: "\u041D\u043E\u0432\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  TOTAL_CARDS: "\u0412\u0441\u0435\u0433\u043E \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  BACK: "\u041D\u0430\u0437\u0430\u0434",
  SKIP: "\u041F\u0440\u043E\u043F\u0443\u0441\u0442\u0438\u0442\u044C",
  EDIT_CARD: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0443",
  RESET_CARD_PROGRESS: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u043F\u0440\u043E\u0433\u0440\u0435\u0441\u0441 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  HARD: "\u0421\u043B\u043E\u0436\u043D\u043E",
  GOOD: "\u041D\u043E\u0440\u043C\u0430\u043B\u044C\u043D\u043E",
  EASY: "\u041B\u0435\u0433\u043A\u043E",
  SHOW_ANSWER: "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u043E\u0442\u0432\u0435\u0442",
  CARD_PROGRESS_RESET: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u043F\u0440\u043E\u0433\u0440\u0435\u0441\u0441 \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  SAVE: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C",
  CANCEL: "\u041E\u0442\u043C\u0435\u043D\u0430",
  NO_INPUT: "\u041F\u0443\u0441\u0442\u043E\u0439 \u0432\u0432\u043E\u0434.",
  CURRENT_EASE_HELP_TEXT: "\u0422\u0435\u043A\u0443\u0449\u0438\u0439 \u043F\u0440\u043E\u0433\u0440\u0435\u0441\u0441: ",
  CURRENT_INTERVAL_HELP_TEXT: "\u0422\u0435\u043A\u0443\u0449\u0438\u0439 \u0438\u043D\u0442\u0435\u0440\u0432\u0430\u043B: ",
  CARD_GENERATED_FROM: "\u0421\u0433\u0435\u043D\u0435\u0440\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u043E \u0438\u0437: ${notePath}",
  // main.ts
  OPEN_NOTE_FOR_REVIEW: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u0434\u043B\u044F \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F",
  REVIEW_CARDS: "\u0418\u0437\u0443\u0447\u0430\u0442\u044C \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  REVIEW_DIFFICULTY_FILE_MENU: "\u0418\u0437\u0443\u0447\u0435\u043D\u0438\u0435: ${difficulty}",
  REVIEW_NOTE_DIFFICULTY_CMD: "\u0418\u0437\u0443\u0447\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u043A\u0430\u043A ${difficulty}",
  CRAM_ALL_CARDS: "\u0417\u0443\u0431\u0440\u0438\u0442\u044C \u0432\u0441\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432 \u044D\u0442\u043E\u0439 \u043A\u043E\u043B\u043E\u0434\u0435",
  REVIEW_ALL_CARDS: "\u0418\u0437\u0443\u0447\u0430\u0442\u044C \u0432\u0441\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432\u043E \u0432\u0441\u0435\u0445 \u0437\u0430\u043C\u0435\u0442\u043A\u0430\u0445",
  REVIEW_CARDS_IN_NOTE: "\u0418\u0437\u0443\u0447\u0430\u0442\u044C \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432 \u044D\u0442\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0435",
  CRAM_CARDS_IN_NOTE: "\u0417\u0443\u0431\u0440\u0438\u0442\u044C \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432 \u044D\u0442\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0435",
  VIEW_STATS: "\u041F\u043E\u0441\u043C\u043E\u0442\u0440\u0435\u0442\u044C \u0441\u0442\u0430\u0442\u0438\u0441\u0442\u0438\u043A\u0443",
  OPEN_REVIEW_QUEUE_VIEW: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u043E\u0447\u0435\u0440\u0435\u0434\u044C \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F \u0437\u0430\u043C\u0435\u0442\u043E\u043A \u043D\u0430 \u0431\u043E\u043A\u043E\u0432\u043E\u0439 \u043F\u0430\u043D\u0435\u043B\u0438",
  STATUS_BAR: "\u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C: ${dueNotesCount} \u0437\u0430\u043C\u0435\u0442\u043E\u043A, ${dueFlashcardsCount} \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  SYNC_TIME_TAKEN: "\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u0437\u0430\u043D\u044F\u043B\u0430 ${t}\u043C\u0441",
  NOTE_IN_IGNORED_FOLDER: "\u0417\u0430\u043C\u0435\u0442\u043A\u0430 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0430 \u0432 \u0438\u0433\u043D\u043E\u0440\u0438\u0440\u0443\u0435\u043C\u0443\u044E \u043F\u0430\u043F\u043A\u0443 (\u0441\u043C. \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438).",
  PLEASE_TAG_NOTE: "\u0414\u043B\u044F \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F, \u043F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u043E \u043F\u043E\u043C\u0435\u0442\u044C\u0442\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u0442\u0435\u0433\u043E\u043C (\u0441\u043C. \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438).",
  RESPONSE_RECEIVED: "\u041E\u0442\u0432\u0435\u0442 \u043F\u043E\u043B\u0443\u0447\u0435\u043D.",
  NO_DECK_EXISTS: "\u041D\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0443\u0440\u043E\u0432\u043D\u044F ${deckName}",
  ALL_CAUGHT_UP: "\u041C\u043E\u043B\u043E\u0434\u0435\u0446! \u0422\u044B \u0441\u043F\u0440\u0430\u0432\u0438\u043B\u0441\u044F \u0438 \u0434\u043E\u0448\u0435\u043B \u0434\u043E \u043A\u043E\u043D\u0446\u0430! :D",
  // scheduling.ts
  DAYS_STR_IVL: "${interval} \u0434\u043D\u0435\u0439",
  MONTHS_STR_IVL: "${interval} \u043C\u0435\u0441\u044F\u0446\u0435\u0432",
  YEARS_STR_IVL: "${interval} \u0433\u043E\u0434\u043E\u0432",
  DAYS_STR_IVL_MOBILE: "${interval}\u0434.",
  MONTHS_STR_IVL_MOBILE: "${interval}\u043C.",
  YEARS_STR_IVL_MOBILE: "${interval}\u0433.",
  // settings.ts
  SETTINGS_HEADER: "Spaced Repetition",
  GROUP_TAGS_FOLDERS: "Tags & Folders",
  GROUP_FLASHCARD_REVIEW: "Flashcard Review",
  GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
  GROUP_DATA_STORAGE: "Storage of Scheduling Data",
  GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
  GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
  GROUP_CONTRIBUTING: "Contributing",
  CHECK_WIKI: '\u0414\u043B\u044F \u0434\u043E\u043F\u043E\u043B\u043D\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0439 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0438 \u043F\u043E\u0441\u0435\u0442\u0438\u0442\u0435: <a href="${wikiUrl}">wiki</a>.',
  GITHUB_DISCUSSIONS: 'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
  GITHUB_ISSUES: 'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
  GITHUB_SOURCE_CODE: 'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
  CODE_CONTRIBUTION_INFO: '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
  TRANSLATION_CONTRIBUTION_INFO: '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
  FOLDERS_TO_IGNORE: "\u0418\u0433\u043D\u043E\u0440\u0438\u0440\u0443\u0435\u043C\u044B\u0435 \u043F\u0430\u043F\u043A\u0438",
  FOLDERS_TO_IGNORE_DESC: "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
  OBSIDIAN_INTEGRATION: "Integration into Obsidian",
  FLASHCARDS: "\u041A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  FLASHCARD_EASY_LABEL: '\u0422\u0435\u043A\u0441\u0442 \u043A\u043D\u043E\u043F\u043A\u0438 "\u041B\u0435\u0433\u043A\u043E"',
  FLASHCARD_GOOD_LABEL: '\u0422\u0435\u043A\u0441\u0442 \u043A\u043D\u043E\u043F\u043A\u0438 "\u041D\u043E\u0440\u043C\u0430\u043B\u044C\u043D\u043E"',
  FLASHCARD_HARD_LABEL: '\u0422\u0435\u043A\u0441\u0442 \u043A\u043D\u043E\u043F\u043A\u0438 "\u0421\u043B\u043E\u0436\u043D\u043E"',
  FLASHCARD_EASY_DESC: '\u041D\u0430\u0441\u0442\u0440\u043E\u0438\u0442\u044C \u044F\u0440\u043B\u044B\u043A \u0434\u043B\u044F \u043A\u043D\u043E\u043F\u043A\u0438 "\u041B\u0435\u0433\u043A\u043E"',
  FLASHCARD_GOOD_DESC: '\u041D\u0430\u0441\u0442\u0440\u043E\u0438\u0442\u044C \u044F\u0440\u043B\u044B\u043A \u0434\u043B\u044F \u043A\u043D\u043E\u043F\u043A\u0438 "\u041D\u043E\u0440\u043C\u0430\u043B\u044C\u043D\u043E"',
  FLASHCARD_HARD_DESC: '\u041D\u0430\u0441\u0442\u0440\u043E\u0438\u0442\u044C \u044F\u0440\u043B\u044B\u043A \u0434\u043B\u044F \u043A\u043D\u043E\u043F\u043A\u0438 "\u0421\u043B\u043E\u0436\u043D\u043E"',
  REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
  REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
  FLASHCARD_TAGS: "\u0422\u0435\u0433\u0438 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  FLASHCARD_TAGS_DESC: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435 \u0442\u0435\u0433\u0438 \u0440\u0430\u0437\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0435 Enter-\u043E\u043C \u0438\u043B\u0438 \u043F\u0440\u043E\u0431\u0435\u043B\u043E\u043C, \u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: #flashcards #deck2 #deck3.",
  CONVERT_FOLDERS_TO_DECKS: "\u041A\u043E\u043D\u0432\u0435\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u0430\u043F\u043A\u0438 \u0432 \u0443\u0440\u043E\u0432\u043D\u0438 \u0438 \u043F\u043E\u0434\u0443\u0440\u043E\u0432\u043D\u0438?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "\u042D\u0442\u043E \u0430\u043B\u044C\u0442\u0435\u0440\u043D\u0430\u0442\u0438\u0432\u0430 \u043E\u043F\u0438\u0441\u0430\u043D\u043D\u043E\u043C\u0443 \u0432\u044B\u0448\u0435 \u0432\u0430\u0440\u0438\u0430\u043D\u0442\u0443 \u0442\u0435\u0433\u043E\u0432 \u0444\u043B\u044D\u0448-\u043A\u0430\u0440\u0442",
  INLINE_SCHEDULING_COMMENTS: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043A\u043E\u043C\u043C\u0435\u043D\u0442\u0430\u0440\u0438\u0439 \u043F\u043B\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F \u043D\u0430 \u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0435\u0439 \u0441\u0442\u0440\u043E\u043A\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438?",
  INLINE_SCHEDULING_COMMENTS_DESC: "\u0412\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435 \u044D\u0442\u043E\u0439 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0441\u0434\u0435\u043B\u0430\u0435\u0442 \u0442\u0430\u043A, \u0447\u0442\u043E HTML \u043A\u043E\u043C\u043C\u0435\u043D\u0442\u0430\u0440\u0438\u0438 \u043D\u0435 \u0431\u0443\u0434\u0443\u0442 \u043B\u043E\u043C\u0430\u0442\u044C \u0444\u043E\u0440\u043C\u0430\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u0441\u043F\u0438\u0441\u043A\u0430.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "\u041F\u0440\u044F\u0442\u0430\u0442\u044C \u0440\u043E\u0434\u0441\u0442\u0432\u0435\u043D\u043D\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0434\u043E \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E \u0434\u043D\u044F?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "\u0420\u043E\u0434\u0441\u0442\u0432\u0435\u043D\u043D\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 - \u0442\u0435, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u043D\u044B \u0438\u0437 \u043E\u0434\u043D\u043E\u0433\u043E \u0442\u0435\u043A\u0441\u0442\u0430, \u043F\u0440\u0438\u043C\u0435\u0440: \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0441 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0430\u043C\u0438 ([...])",
  SHOW_CARD_CONTEXT: "\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442 (\u0443\u0440\u043E\u0432\u0435\u043D\u044C) \u0432 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0430\u0445 (\u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F)?",
  SHOW_CARD_CONTEXT_DESC: "\u043F\u0440\u0438\u043C\u0435\u0440: Title > Heading 1 > Subheading > ... > Subheading",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC: "Useful to know how far in the future your cards are being pushed.",
  CARD_MODAL_HEIGHT_PERCENT: "\u0412\u044B\u0441\u043E\u0442\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432 \u043F\u0440\u043E\u0446\u0435\u043D\u0442\u0430\u0445",
  CARD_MODAL_SIZE_PERCENT_DESC: "\u0415\u0441\u043B\u0438 \u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442\u0435\u0441\u044C \u043C\u043E\u0431\u0438\u043B\u044C\u043D\u044B\u043C \u0442\u0435\u043B\u0435\u0444\u043E\u043D\u043E\u043C, \u0432\u044B\u0441\u0442\u0430\u0432\u044C\u0442\u0435 100%. \u0418\u043D\u0430\u0447\u0435 \u0443 \u0432\u0430\u0441 \u0431\u0443\u0434\u0443\u0442 \u043E\u0433\u0440\u043E\u043C\u043D\u044B\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F",
  RESET_DEFAULT: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043F\u043E-\u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E",
  CARD_MODAL_WIDTH_PERCENT: "\u0428\u0438\u0440\u0438\u043D\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438 \u0432 \u043F\u0440\u043E\u0446\u0435\u043D\u0442\u0430\u0445",
  RANDOMIZE_CARD_ORDER: "\u0421\u043B\u0443\u0447\u0430\u0439\u043D\u044B\u0439 \u043F\u043E\u0440\u044F\u0434\u043E\u043A \u043A\u0430\u0440\u0442 \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F?",
  REVIEW_CARD_ORDER_WITHIN_DECK: "\u041F\u043E\u0440\u044F\u0434\u043E\u043A \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u043A\u0430\u0440\u0442 \u043A\u043E\u043B\u043E\u0434\u044B \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F",
  REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "\u041F\u043E\u0441\u043B\u0435\u0434\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u043D\u043E \u0432\u043D\u0443\u0442\u0440\u0438 \u043A\u043E\u043B\u043E\u0434\u044B (\u0441\u043D\u0430\u0447\u0430\u043B\u0430 \u0432\u0441\u0435 \u043D\u043E\u0432\u044B\u0435 \u043A\u0430\u0440\u0442\u044B)",
  REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "\u041F\u043E\u0441\u043B\u0435\u0434\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u043D\u043E \u0432\u043D\u0443\u0442\u0440\u0438 \u043A\u043E\u043B\u043E\u0434\u044B (\u0441\u043D\u0430\u0447\u0430\u043B\u0430 \u0432\u0441\u0435 \u043F\u043E\u0432\u0442\u043E\u0440\u044F\u0435\u043C\u044B\u0435 \u043A\u0430\u0440\u0442\u044B)",
  REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "\u0421\u043B\u0443\u0447\u0430\u0439\u043D\u043E \u0432\u043D\u0443\u0442\u0440\u0438 \u043A\u043E\u043B\u043E\u0434\u044B (\u0441\u043D\u0430\u0447\u0430\u043B\u0430 \u0432\u0441\u0435 \u043D\u043E\u0432\u044B\u0435 \u043A\u0430\u0440\u0442\u044B)",
  REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "\u0421\u043B\u0443\u0447\u0430\u0439\u043D\u043E \u0432\u043D\u0443\u0442\u0440\u0438 \u043A\u043E\u043B\u043E\u0434\u044B (\u0441\u043D\u0430\u0447\u0430\u043B\u0430 \u0432\u0441\u0435 \u043F\u043E\u0432\u0442\u043E\u0440\u044F\u0435\u043C\u044B\u0435 \u043A\u0430\u0440\u0442\u044B)",
  REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "\u0421\u043B\u0443\u0447\u0430\u0439\u043D\u0430\u044F \u043A\u0430\u0440\u0442\u0430 \u0438\u0437 \u0441\u043B\u0443\u0447\u0430\u0439\u043D\u043E\u0439 \u043A\u043E\u043B\u043E\u0434\u044B",
  REVIEW_DECK_ORDER: "\u041F\u043E\u0440\u044F\u0434\u043E\u043A \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u043A\u043E\u043B\u043E\u0434 \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL: "\u041F\u043E\u0441\u043B\u0435\u0434\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u043D\u043E  (\u043F\u043E\u0441\u043B\u0435 \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F \u0432\u0441\u0435\u0445 \u043A\u0430\u0440\u0442 \u0438\u0437 \u043F\u0440\u0435\u0434\u044B\u0434\u0443\u0449\u0435\u0439 \u043A\u043E\u043B\u043E\u0434\u044B)",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM: "\u0421\u043B\u0443\u0447\u0430\u0439\u043D\u043E (\u043F\u043E\u0441\u043B\u0435 \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F \u0432\u0441\u0435\u0445 \u043A\u0430\u0440\u0442 \u0438\u0437 \u043F\u0440\u0435\u0434\u044B\u0434\u0443\u0449\u0435\u0439 \u043A\u043E\u043B\u043E\u0434\u044B)",
  REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "\u0421\u043B\u0443\u0447\u0430\u0439\u043D\u0430\u044F \u043A\u0430\u0440\u0442\u0430 \u0438\u0437 \u0441\u043B\u0443\u0447\u0430\u0439\u043D\u043E\u0439 \u043A\u043E\u043B\u043E\u0434\u044B",
  DISABLE_CLOZE_CARDS: "\u0412\u044B\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043A\u0430\u0440\u0442\u044B \u0441 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0430\u043C\u0438 (\u043F\u0440\u0438\u043C\u0435\u0440: [...])?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "\u041A\u043E\u043D\u0432\u0435\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C ==\u0432\u044B\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0439 \u0442\u0435\u043A\u0441\u0442== \u0432 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0438 (\u043F\u0440\u0438\u043C\u0435\u0440: [...])?",
  CONVERT_HIGHLIGHTS_TO_CLOZES_DESC: '\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C/\u0443\u0434\u0430\u043B\u0438\u0442\u044C <code>${defaultPattern}</code> \u0432 \u0432\u0430\u0448\u0438 "\u0428\u0430\u0431\u043B\u043E\u043D\u044B \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u043E\u0432"',
  CONVERT_BOLD_TEXT_TO_CLOZES: "\u041A\u043E\u043D\u0432\u0435\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C **\u0436\u0438\u0440\u043D\u044B\u0439 \u0442\u0435\u043A\u0441\u0442** \u0432 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0438 (\u043F\u0440\u0438\u043C\u0435\u0440: [...])?",
  CONVERT_BOLD_TEXT_TO_CLOZES_DESC: '\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C/\u0443\u0434\u0430\u043B\u0438\u0442\u044C <code>${defaultPattern}</code> \u0432 \u0432\u0430\u0448\u0438 "\u0428\u0430\u0431\u043B\u043E\u043D\u044B \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u043E\u0432"',
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "\u041A\u043E\u043D\u0432\u0435\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C {{\u0444\u0438\u0433\u0443\u0440\u043D\u044B\u0435 \u0441\u043A\u043E\u0431\u043A\u0438}} \u0432 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0438 (\u043F\u0440\u0438\u043C\u0435\u0440: [...])?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC: '\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C/\u0443\u0434\u0430\u043B\u0438\u0442\u044C <code>${defaultPattern}</code> \u0432 \u0432\u0430\u0448\u0438 "\u0428\u0430\u0431\u043B\u043E\u043D\u044B \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u043E\u0432"',
  CLOZE_PATTERNS: "\u0428\u0430\u0431\u043B\u043E\u043D\u044B \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u043E\u0432",
  CLOZE_PATTERNS_DESC: '\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0448\u0430\u0431\u043B\u043E\u043D\u044B \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u043E\u0432, \u0440\u0430\u0437\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0435 \u043F\u0435\u0440\u0435\u0432\u043E\u0434\u0430\u043C\u0438 \u0441\u0442\u0440\u043E\u043A. Check the <a href="${docsUrl}">wiki</a> for guidance.',
  INLINE_CARDS_SEPARATOR: "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C \u0434\u043B\u044F \u0432\u043D\u0443\u0442\u0440\u0438\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  FIX_SEPARATORS_MANUALLY_WARNING: "\u0412\u043D\u0438\u043C\u0430\u043D\u0438\u0435! \u041F\u043E\u0441\u043B\u0435 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u044D\u0442\u043E\u0433\u043E \u0432\u0430\u043C \u043F\u0440\u0438\u0434\u0451\u0442\u0441\u044F \u0432\u0440\u0443\u0447\u043D\u0443\u044E \u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0443\u0436\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438",
  INLINE_REVERSED_CARDS_SEPARATOR: "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C \u0434\u043B\u044F \u043E\u0431\u0440\u0430\u0442\u043D\u044B\u0445 \u0432\u043D\u0443\u0442\u0440\u0438\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  MULTILINE_CARDS_SEPARATOR: "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C \u0434\u043B\u044F \u043C\u043D\u043E\u0433\u043E\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C \u0434\u043B\u044F \u043E\u0431\u0440\u0430\u0442\u043D\u044B\u0445 \u043C\u043D\u043E\u0433\u043E\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  MULTILINE_CARDS_END_MARKER: "\u0421\u0438\u043C\u0432\u043E\u043B\u044B, \u043E\u0431\u043E\u0437\u043D\u0430\u0447\u0430\u044E\u0449\u0438\u0435 \u043A\u043E\u043D\u0435\u0446 \u043A\u043B\u043E\u0437\u043E\u0432 \u0438 \u043C\u043D\u043E\u0433\u043E\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0445 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  NOTES: "\u0417\u0430\u043C\u0435\u0442\u043A\u0438",
  NOTE: "Note",
  REVIEW_PANE_ON_STARTUP: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0430\u043D\u0435\u043B\u044C \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A \u043F\u0440\u0438 \u0437\u0430\u043F\u0443\u0441\u043A\u0435 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u044B",
  TAGS_TO_REVIEW: "\u0422\u0435\u0433\u0438 \u0434\u043B\u044F \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F",
  TAGS_TO_REVIEW_DESC: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0442\u0435\u0433\u0438, \u0440\u0430\u0437\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0435 Enter-\u0430\u043C\u0438 \u0438\u043B\u0438 \u043F\u0440\u043E\u0431\u0435\u043B\u0430\u043C\u0438, \u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: #review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0441\u043B\u0443\u0447\u0430\u0439\u043D\u0443\u044E \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u0434\u043B\u044F \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F",
  OPEN_RANDOM_NOTE_DESC: "\u0415\u0441\u043B\u0438 \u0432\u044B\u043A\u043B\u044E\u0447\u0438\u0442\u044C, \u0442\u043E \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0431\u0443\u0434\u0443\u0442 \u043E\u0442\u0441\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u044B \u043F\u043E \u0432\u0430\u0436\u043D\u043E\u0441\u0442\u0438 (PageRank).",
  AUTO_NEXT_NOTE: "\u041F\u043E\u0441\u043B\u0435 \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u043E\u0442\u043A\u0440\u044B\u0432\u0430\u0442\u044C \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E \u0437\u0430\u043C\u0435\u0442\u043A\u0443",
  ENABLE_FILE_MENU_REVIEW_OPTIONS: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u0435 \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440\u044B \u043E\u0431\u0437\u043E\u0440\u0430 \u0432 \u043C\u0435\u043D\u044E \u0424\u0430\u0439\u043B (\u0442.\u0435.: \u0418\u0437\u0443\u0447\u0435\u043D\u0438\u0435: \u041B\u0435\u0433\u043A\u043E, \u041D\u043E\u0440\u043C\u0430\u043B\u044C\u043D\u043E, \u0421\u043B\u043E\u0436\u043D\u043E)",
  ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "\u0415\u0441\u043B\u0438 \u0432\u044B \u043E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u0435 \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440\u044B \u043E\u0431\u0437\u043E\u0440\u0430 \u0432 \u043C\u0435\u043D\u044E \u0424\u0430\u0439\u043B, \u0432\u044B \u0441\u043C\u043E\u0436\u0435\u0442\u0435 \u043F\u0440\u043E\u0441\u043C\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044C \u0441\u0432\u043E\u0438 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0441 \u043F\u043E\u043C\u043E\u0449\u044C\u044E \u043A\u043E\u043C\u0430\u043D\u0434 \u043F\u043B\u0430\u0433\u0438\u043D\u0430 \u0438, \u0435\u0441\u043B\u0438 \u0432\u044B \u0438\u0445 \u0437\u0430\u0434\u0430\u043B\u0438, \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0445 \u0433\u043E\u0440\u044F\u0447\u0438\u0445 \u043A\u043B\u0430\u0432\u0438\u0448.",
  MAX_N_DAYS_REVIEW_QUEUE: "\u041D\u0430\u0438\u0431\u043E\u043B\u044C\u0448\u0435\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0434\u043D\u0435\u0439 \u0434\u043B\u044F \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435 \u043D\u0430 \u043F\u0430\u043D\u0435\u043B\u0438 \u0441\u043F\u0440\u0430\u0432\u0430",
  MIN_ONE_DAY: "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0434\u043D\u0435\u0439 \u043D\u0435 \u043C\u0435\u043D\u044C\u0448\u0435 1.",
  VALID_NUMBER_WARNING: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u043F\u043E\u0434\u0445\u043E\u0434\u044F\u0449\u0435\u0435 \u0447\u0438\u0441\u043B\u043E.",
  UI: "User Interface",
  OPEN_IN_TAB: "Open in new tab",
  OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
  SHOW_STATUS_BAR: "Show status bar",
  SHOW_STATUS_BAR_DESC: "Turn this off to hide the flashcard's review status in Obsidian's status bar",
  SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
  SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "\u0414\u0435\u0440\u0435\u0432\u044C\u044F \u043A\u043E\u043B\u043E\u0434 \u0434\u043E\u043B\u0436\u043D\u044B \u0438\u0437\u043D\u0430\u0447\u0430\u043B\u044C\u043D\u043E \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0442\u044C\u0441\u044F \u043A\u0430\u043A \u0440\u0430\u0437\u0432\u0435\u0440\u043D\u0443\u0442\u044B\u0435",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u0435 \u044D\u0442\u043E\u0442 \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440, \u0447\u0442\u043E\u0431\u044B \u0441\u0432\u0435\u0440\u043D\u0443\u0442\u044C \u0432\u043B\u043E\u0436\u0435\u043D\u043D\u044B\u0435 \u043A\u043E\u043B\u043E\u0434\u044B \u043D\u0430 \u043E\u0434\u043D\u043E\u0439 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0435. \u041F\u043E\u043B\u0435\u0437\u043D\u043E, \u0435\u0441\u043B\u0438 \u0443 \u0432\u0430\u0441 \u0435\u0441\u0442\u044C \u043A\u0430\u0440\u0442\u044B, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043F\u0440\u0438\u043D\u0430\u0434\u043B\u0435\u0436\u0430\u0442 \u043C\u043D\u043E\u0433\u0438\u043C \u043A\u043E\u043B\u043E\u0434\u0430\u043C \u0432 \u043E\u0434\u043D\u043E\u043C \u0444\u0430\u0439\u043B\u0435.",
  ALGORITHM: "\u0410\u043B\u0433\u043E\u0440\u0438\u0442\u043C",
  CHECK_ALGORITHM_WIKI: '\u0417\u0430 \u0434\u043E\u043F\u043E\u043B\u043D\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0439 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0435\u0439 \u043E\u0431\u0440\u0430\u0449\u0430\u0439\u0442\u0435\u0441\u044C \u043A <a href="${algoUrl}">\u0440\u0435\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F \u0430\u043B\u0433\u043E\u0440\u0438\u0442\u043C\u0430</a>.',
  SM2_OSR_VARIANT: "OSR's variant of SM-2",
  BASE_EASE: "\u0411\u0430\u0437\u043E\u0432\u0430\u044F \u041B\u0451\u0433\u043A\u043E\u0441\u0442\u044C",
  BASE_EASE_DESC: "\u043C\u0438\u043D\u0438\u043C\u0443\u043C = 130, \u043F\u0440\u0435\u0434\u043F\u043E\u0447\u0442\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u043E\u043A\u043E\u043B\u043E 250.",
  BASE_EASE_MIN_WARNING: "\u041B\u0451\u0433\u043A\u043E\u0441\u0442\u044C \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043C\u0438\u043D\u0438\u043C\u0443\u043C 130.",
  LAPSE_INTERVAL_CHANGE: '\u0418\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0435 \u0438\u043D\u0442\u0435\u0440\u0432\u0430\u043B\u0430 \u043F\u0440\u0438 \u0432\u044B\u0431\u043E\u0440\u0435 "\u0421\u043B\u043E\u0436\u043D\u043E" \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438/\u0437\u0430\u043C\u0435\u0442\u043A\u0438',
  LAPSE_INTERVAL_CHANGE_DESC: "\u043D\u043E\u0432\u044B\u0439\u041F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A = \u0441\u0442\u0430\u0440\u044B\u0439\u041F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A * \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0435\u041F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043A\u0430 / 100.",
  EASY_BONUS: "\u041B\u0435\u0433\u043A\u043E: \u0431\u043E\u043D\u0443\u0441",
  EASY_BONUS_DESC: "\u0411\u043E\u043D\u0443\u0441 \u0437\u0430 \u041B\u0435\u0433\u043A\u043E \u043F\u043E\u0437\u0432\u043E\u043B\u044F\u0435\u0442 \u0432\u0430\u043C \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u0440\u0430\u0437\u043D\u0438\u0446\u0443 \u0432 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043A\u0430\u0445 \u043C\u0435\u0436\u0434\u0443 \u043E\u0442\u0432\u0435\u0442\u0430\u043C\u0438 \u0425\u043E\u0440\u043E\u0448\u043E \u0438 \u041B\u0435\u0433\u043A\u043E \u043D\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0435/\u0437\u0430\u043C\u0435\u0442\u043A\u0435 (\u043C\u0438\u043D. = 100%).",
  EASY_BONUS_MIN_WARNING: '\u0411\u043E\u043D\u0443\u0441 \u0437\u0430 "\u041B\u0435\u0433\u043A\u043E" \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C \u043D\u0435 \u043C\u0435\u043D\u044C\u0448\u0435 100.',
  LOAD_BALANCE: "Enable load balancer",
  LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
  MAX_INTERVAL: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0438\u043D\u0442\u0435\u0440\u0432\u0430\u043B \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F \u0432 \u0434\u043D\u044F\u0445",
  MAX_INTERVAL_DESC: "\u041F\u043E\u0437\u0432\u043E\u043B\u044F\u0435\u0442 \u0432\u0430\u043C \u0443\u0441\u0442\u0430\u043D\u0430\u0432\u043B\u0438\u0432\u0430\u0442\u044C \u0432\u0435\u0440\u0445\u043D\u044E\u044E \u0433\u0440\u0430\u043D\u0438\u0446\u0443 \u043D\u0430 \u0438\u043D\u0442\u0435\u0440\u0432\u0430\u043B \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F (\u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E = 100 \u043B\u0435\u0442).",
  MAX_INTERVAL_MIN_WARNING: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0438\u043D\u0442\u0435\u0440\u0432\u0430\u043B \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C \u043D\u0435 \u043C\u0435\u043D\u044C\u0448\u0435 1.",
  MAX_LINK_CONTRIB: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0432\u043A\u043B\u0430\u0434 \u0441\u0432\u044F\u0437\u0438 (\u0441\u0441\u044B\u043B\u043A\u0438)",
  MAX_LINK_CONTRIB_DESC: '\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0432\u043A\u043B\u0430\u0434 \u0441\u0440\u0435\u0434\u043D\u0435\u0433\u043E \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u044F "\u041B\u0451\u0433\u043A\u043E\u0441\u0442\u0438" \u0441\u0432\u044F\u0437\u0430\u043D\u043D\u044B\u0445 \u0437\u0430\u043C\u0435\u0442\u043E\u043A \u0432 \u043D\u0430\u0447\u0430\u043B\u044C\u043D\u0443\u044E "\u041B\u0451\u0433\u043A\u043E\u0441\u0442\u044C".',
  LOGGING: "\u0416\u0443\u0440\u043D\u0430\u043B\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435",
  DISPLAY_SCHEDULING_DEBUG_INFO: "\u041E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0442\u044C \u043E\u0442\u043B\u0430\u0434\u043E\u0447\u043D\u0443\u044E \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044E \u0432 \u043A\u043E\u043D\u0441\u043E\u043B\u0438 \u0440\u0430\u0437\u0440\u0430\u0431\u043E\u0442\u0447\u0438\u043A\u0430",
  DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
  SCHEDULING: "Scheduling",
  EXPERIMENTAL: "Experimental",
  HELP: "Help",
  STORE_IN_NOTES: "In the notes",
  // sidebar.ts
  NOTES_REVIEW_QUEUE: "\u041E\u0447\u0435\u0440\u0435\u0434\u044C \u0437\u0430\u043C\u0435\u0442\u043E\u043A \u043D\u0430 \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0435",
  CLOSE: "\u0417\u0430\u043A\u0440\u044B\u0442\u044C",
  NEW: "\u041D\u043E\u0432\u044B\u0435",
  YESTERDAY: "\u0412\u0447\u0435\u0440\u0430\u0448\u043D\u0438\u0435",
  TODAY: "\u0421\u0435\u0433\u043E\u0434\u043D\u044F\u0448\u043D\u0438\u0435",
  TOMORROW: "\u0417\u0430\u0432\u0442\u0440\u0430\u0448\u043D\u0438\u0435",
  // stats-modal.tsx
  STATS_TITLE: "\u0421\u0442\u0430\u0442\u0438\u0441\u0442\u0438\u043A\u0430",
  MONTH: "\u041C\u0435\u0441\u044F\u0446",
  QUARTER: "\u041A\u0432\u0430\u0440\u0442\u0430\u043B",
  YEAR: "\u0413\u043E\u0434",
  LIFETIME: "\u0412\u0441\u0451 \u0432\u0440\u0435\u043C\u044F",
  FORECAST: "\u041F\u0440\u043E\u0433\u043D\u043E\u0437",
  FORECAST_DESC: "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A \u043F\u0440\u0435\u0434\u0441\u0442\u043E\u044F\u0449\u0438\u0445 \u0434\u043B\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F",
  SCHEDULED: "\u0417\u0430\u043F\u043B\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u043E",
  DAYS: "\u0414\u043D\u0438",
  NUMBER_OF_CARDS: "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  REVIEWS_PER_DAY: "\u0421\u0440\u0435\u0434\u043D\u0435\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E: ${avg} \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u0439 \u0432 \u0434\u0435\u043D\u044C",
  INTERVALS: "\u0418\u043D\u0442\u0435\u0440\u0432\u0430\u043B\u044B",
  INTERVALS_DESC: "\u041F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043A\u0438 \u0432\u0440\u0435\u043C\u0435\u043D\u0438 \u0434\u043E \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E \u043F\u043E\u043A\u0430\u0437\u0430 \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u0432\u0442\u043E\u0440\u0435\u043D\u0438\u044F",
  COUNT: "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E",
  INTERVALS_SUMMARY: "\u0421\u0440\u0435\u0434\u043D\u0438\u0439 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A: ${avg}, \u0421\u0430\u043C\u044B\u0439 \u0434\u043B\u0438\u043D\u043D\u044B\u0439 \u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A: ${longest}",
  EASES: "\u041F\u0440\u043E\u0433\u0440\u0435\u0441\u0441 \u0438\u0437\u0443\u0447\u0435\u043D\u0438\u044F",
  EASES_SUMMARY: "\u0421\u0440\u0435\u0434\u043D\u0435\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u043F\u0440\u043E\u0433\u0440\u0435\u0441\u0441\u0430: ${avgEase}",
  EASE: "Ease",
  CARD_TYPES: "\u0422\u0438\u043F\u044B \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A",
  CARD_TYPES_DESC: "\u0412\u043A\u043B\u044E\u0447\u0430\u044F \u0441\u043F\u0440\u044F\u0442\u0430\u043D\u043D\u044B\u0435 \u043A\u0430\u0440\u0442\u043E\u0447\u043A\u0438, \u0435\u0441\u043B\u0438 \u0442\u0430\u043A\u0438\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0442.",
  CARD_TYPE_NEW: "\u041D\u043E\u0432\u044B\u0445",
  CARD_TYPE_YOUNG: "\u041F\u043E\u0432\u0442\u043E\u0440\u044F\u0435\u043C\u044B\u0445",
  CARD_TYPE_MATURE: "\u0418\u0437\u0443\u0447\u0435\u043D\u043D\u044B\u0445",
  CARD_TYPES_SUMMARY: "\u0412\u0441\u0435\u0433\u043E \u043A\u0430\u0440\u0442\u043E\u0447\u0435\u043A: ${totalCardsCount}",
  SEARCH: "Search",
  PREVIOUS: "Previous",
  NEXT: "Next"
};

// src/lang/locale/sw.ts
var sw_default = {};

// src/lang/locale/ta.ts
var ta_default = {};

// src/lang/locale/te.ts
var te_default = {};

// src/lang/locale/th.ts
var th_default = {};

// src/lang/locale/tr.ts
var tr_default = {
  // flashcard-modal.tsx
  DECKS: "Desteler",
  DUE_CARDS: "G\xFCncel Kartlar",
  NEW_CARDS: "Yeni Kartlar",
  TOTAL_CARDS: "Toplam Kartlar",
  BACK: "Geri",
  SKIP: "Atla",
  EDIT_CARD: "Kart\u0131 D\xFCzenle",
  RESET_CARD_PROGRESS: "Kart\u0131n ilerlemesini s\u0131f\u0131rla",
  HARD: "Zor",
  GOOD: "Orta",
  EASY: "Kolay",
  SHOW_ANSWER: "Cevab\u0131 G\xF6ster",
  CARD_PROGRESS_RESET: "Kart\u0131n ilerlemesi s\u0131f\u0131rland\u0131.",
  SAVE: "Kaydet",
  CANCEL: "\u0130ptal",
  NO_INPUT: "Girdi sa\u011Flanmad\u0131.",
  CURRENT_EASE_HELP_TEXT: "Mevcut Kolayl\u0131k: ",
  CURRENT_INTERVAL_HELP_TEXT: "Mevcut Aral\u0131k: ",
  CARD_GENERATED_FROM: "${notePath} kayna\u011F\u0131ndan olu\u015Fturuldu.",
  // main.ts
  OPEN_NOTE_FOR_REVIEW: "G\xF6zden ge\xE7irmek i\xE7in bir not a\xE7",
  REVIEW_CARDS: "Flash kartlar\u0131 g\xF6zden ge\xE7ir",
  REVIEW_DIFFICULTY_FILE_MENU: "G\xF6zden Ge\xE7ir: ${difficulty}",
  REVIEW_NOTE_DIFFICULTY_CMD: "Notu ${difficulty} derecesiyle g\xF6zden ge\xE7ir",
  CRAM_ALL_CARDS: "T\xFCm destelerden yo\u011Fun tekrar yap",
  REVIEW_ALL_CARDS: "T\xFCm notlardaki flash kartlar\u0131 g\xF6zden ge\xE7ir",
  REVIEW_CARDS_IN_NOTE: "Bu nottaki flash kartlar\u0131 g\xF6zden ge\xE7ir",
  CRAM_CARDS_IN_NOTE: "Bu nottaki flash kartlar\u0131 yo\u011Fun tekrar yap",
  VIEW_STATS: "\u0130statistikleri g\xF6r\xFCnt\xFCle",
  OPEN_REVIEW_QUEUE_VIEW: "Kenar \xE7ubu\u011Funda Not G\xF6zden Ge\xE7irme S\u0131ras\u0131n\u0131 a\xE7",
  STATUS_BAR: "G\xF6zden Ge\xE7ir: ${dueNotesCount} not, ${dueFlashcardsCount} kart g\xFCncel",
  SYNC_TIME_TAKEN: "Senkronizasyon ${t}ms s\xFCrd\xFC",
  NOTE_IN_IGNORED_FOLDER: "Not, d\u0131\u015Flanan klas\xF6rde kay\u0131tl\u0131 (ayarlar\u0131 kontrol edin).",
  PLEASE_TAG_NOTE: "L\xFCtfen g\xF6zden ge\xE7irmek i\xE7in notu uygun \u015Fekilde etiketleyin (ayarlar i\xE7inde).",
  RESPONSE_RECEIVED: "Yan\u0131t al\u0131nd\u0131.",
  NO_DECK_EXISTS: "${deckName} ad\u0131nda bir deste yok",
  ALL_CAUGHT_UP: "\u{1F3C6} \u015Eampiyon gibi bitirdin! \u{1F604}",
  // scheduling.ts
  DAYS_STR_IVL: "${interval} g\xFCn",
  MONTHS_STR_IVL: "${interval} ay",
  YEARS_STR_IVL: "${interval} y\u0131l",
  DAYS_STR_IVL_MOBILE: "${interval}g",
  MONTHS_STR_IVL_MOBILE: "${interval}a",
  YEARS_STR_IVL_MOBILE: "${interval}y",
  // settings.ts
  SETTINGS_HEADER: "Aral\u0131kl\u0131 Tekrar",
  GROUP_TAGS_FOLDERS: "Etiketler ve Klas\xF6rler",
  GROUP_FLASHCARD_REVIEW: "Flash Kartlar\u0131 G\xF6zden Ge\xE7irme",
  GROUP_FLASHCARD_SEPARATORS: "Flash Kart Ay\u0131r\u0131c\u0131lar\u0131",
  GROUP_DATA_STORAGE: "Planlama Verilerinin Saklanmas\u0131",
  GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
  GROUP_FLASHCARDS_NOTES: "Flash Kartlar ve Notlar",
  GROUP_CONTRIBUTING: "Katk\u0131da Bulunma",
  CHECK_WIKI: 'Daha fazla bilgi i\xE7in <a href="${wikiUrl}">wiki</a> sayfas\u0131na g\xF6z at\u0131n.',
  GITHUB_DISCUSSIONS: 'Soru-cevap, geri bildirim ve genel tart\u0131\u015Fmalar i\xE7in <a href="${discussionsUrl}">tart\u0131\u015Fmalar</a> b\xF6l\xFCm\xFCne g\xF6z at\u0131n.',
  GITHUB_ISSUES: 'Bir \xF6zellik iste\u011Finiz ya da hata bildiriminiz varsa <a href="${issuesUrl}">buradan</a> bildirin.',
  GITHUB_SOURCE_CODE: 'Proje kaynak koduna <a href="${githubProjectUrl}">GitHub</a> \xFCzerinden ula\u015Fabilirsiniz.',
  CODE_CONTRIBUTION_INFO: '<a href="${codeContributionUrl}">Kod katk\u0131lar\u0131</a> hakk\u0131nda bilgi al\u0131n.',
  TRANSLATION_CONTRIBUTION_INFO: 'Eklentiyi kendi dilinize \xE7evirmek hakk\u0131nda bilgi i\xE7in <a href="${translationContributionUrl}">\xE7eviri katk\u0131lar\u0131</a> sayfas\u0131n\u0131 ziyaret edin.',
  FOLDERS_TO_IGNORE: "Yoksay\u0131lan Klas\xF6rler",
  FOLDERS_TO_IGNORE_DESC: "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
  OBSIDIAN_INTEGRATION: "Integration into Obsidian",
  FLASHCARDS: "Flash Kartlar",
  FLASHCARD_EASY_LABEL: "Kolay Butonu Metni",
  FLASHCARD_GOOD_LABEL: "Orta Butonu Metni",
  FLASHCARD_HARD_LABEL: "Zor Butonu Metni",
  FLASHCARD_EASY_DESC: '"Kolay" butonunun metnini \xF6zelle\u015Ftirin',
  FLASHCARD_GOOD_DESC: '"Orta" butonunun metnini \xF6zelle\u015Ftirin',
  FLASHCARD_HARD_DESC: '"Zor" butonunun metnini \xF6zelle\u015Ftirin',
  REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
  REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
  FLASHCARD_TAGS: "Flash Kart Etiketleri",
  FLASHCARD_TAGS_DESC: "Etiketleri bo\u015Fluklar veya yeni sat\u0131rlarla ay\u0131rarak girin, \xF6rne\u011Fin: #flashcards #deck2 #deck3.",
  CONVERT_FOLDERS_TO_DECKS: "Klas\xF6rleri destelere ve alt destelere d\xF6n\xFC\u015Ft\xFCr?",
  CONVERT_FOLDERS_TO_DECKS_DESC: "Bu, yukar\u0131daki Flash Kart etiketleri se\xE7ene\u011Fine bir alternatiftir.",
  INLINE_SCHEDULING_COMMENTS: "Planlama yorumunu flash kart\u0131n son sat\u0131r\u0131yla ayn\u0131 sat\u0131ra kaydet?",
  INLINE_SCHEDULING_COMMENTS_DESC: "Bunu a\xE7mak, HTML yorumlar\u0131n\u0131n liste bi\xE7imlendirmesini bozmamas\u0131n\u0131 sa\u011Flar.",
  BURY_SIBLINGS_TILL_NEXT_DAY: "Karde\u015F kartlar\u0131 bir sonraki g\xFCne kadar gizle?",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "Karde\u015F kartlar, ayn\u0131 kart metninden \xFCretilen kartlard\u0131r (\xF6rne\u011Fin gizlemeler).",
  SHOW_CARD_CONTEXT: "Kartlarda ba\u011Flam\u0131 g\xF6ster?",
  SHOW_CARD_CONTEXT_DESC: "\xD6rne\u011Fin: Ba\u015Fl\u0131k > Ba\u015Fl\u0131k 1 > Alt Ba\u015Fl\u0131k > ... > Alt Ba\u015Fl\u0131k",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC: "Useful to know how far in the future your cards are being pushed.",
  CARD_MODAL_HEIGHT_PERCENT: "Flash Kart Y\xFCkseklik Y\xFCzdesi",
  CARD_MODAL_SIZE_PERCENT_DESC: "Mobilde veya \xE7ok b\xFCy\xFCk resimleriniz varsa %100 olarak ayarlay\u0131n.",
  RESET_DEFAULT: "Varsay\u0131lana s\u0131f\u0131rla",
  CARD_MODAL_WIDTH_PERCENT: "Flash Kart Geni\u015Flik Y\xFCzdesi",
  RANDOMIZE_CARD_ORDER: "\u0130nceleme s\u0131ras\u0131nda kart s\u0131ras\u0131n\u0131 rastgele yap?",
  REVIEW_CARD_ORDER_WITHIN_DECK: "\u0130nceleme s\u0131ras\u0131nda bir destede kartlar\u0131n g\xF6r\xFCnt\xFClenme s\u0131ras\u0131",
  REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "S\u0131ral\u0131 olarak (\xF6nce t\xFCm yeni kartlar)",
  REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "S\u0131ral\u0131 olarak (\xF6nce t\xFCm g\xFCncel kartlar)",
  REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "Rastgele olarak (\xF6nce t\xFCm yeni kartlar)",
  REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "Rastgele olarak (\xF6nce t\xFCm g\xFCncel kartlar)",
  REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "Rastgele desteden rastgele kart",
  REVIEW_DECK_ORDER: "\u0130nceleme s\u0131ras\u0131nda destelerin g\xF6r\xFCnt\xFClenme s\u0131ras\u0131",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL: "S\u0131ral\u0131 olarak (\xD6nceki destedeki t\xFCm kartlar g\xF6zden ge\xE7irildikten sonra)",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM: "Rastgele olarak (\xD6nceki destedeki t\xFCm kartlar g\xF6zden ge\xE7irildikten sonra)",
  REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "Rastgele desteden rastgele kart",
  DISABLE_CLOZE_CARDS: "Gizli kartlar\u0131 devre d\u0131\u015F\u0131 b\u0131rak?",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "==Vurgulanan== metni gizli kartlara d\xF6n\xFC\u015Ft\xFCr?",
  CONVERT_HIGHLIGHTS_TO_CLOZES_DESC: '"Cloze Patterns"den <code>${defaultPattern</code> \xF6\u011Fesini ekleyin/kald\u0131r\u0131n',
  CONVERT_BOLD_TEXT_TO_CLOZES: "**Kal\u0131n metni** gizli kartlara d\xF6n\xFC\u015Ft\xFCr?",
  CONVERT_BOLD_TEXT_TO_CLOZES_DESC: '"Cloze Patterns"den <code>${defaultPattern</code> \xF6\u011Fesini ekleyin/kald\u0131r\u0131n',
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "{{K\u0131v\u0131rc\u0131k parantezleri}} gizli kartlara d\xF6n\xFC\u015Ft\xFCr?",
  CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC: '"Cloze Patterns"den <code>${defaultPattern</code> \xF6\u011Fesini ekleyin/kald\u0131r\u0131n',
  CLOZE_PATTERNS: "Cloze Patterns",
  CLOZE_PATTERNS_DESC: 'Enter cloze patterns separated by newlines. Check the <a href="${docsUrl}">wiki</a> for guidance.',
  INLINE_CARDS_SEPARATOR: "Sat\u0131r i\xE7i flash kartlar i\xE7in ay\u0131r\u0131c\u0131",
  FIX_SEPARATORS_MANUALLY_WARNING: "Bunu de\u011Fi\u015Ftirdikten sonra mevcut flash kartlar\u0131n\u0131z\u0131 manuel olarak d\xFCzenlemeniz gerekti\u011Fini unutmay\u0131n.",
  INLINE_REVERSED_CARDS_SEPARATOR: "Sat\u0131r i\xE7i ters flash kartlar i\xE7in ay\u0131r\u0131c\u0131",
  MULTILINE_CARDS_SEPARATOR: "\xC7ok sat\u0131rl\u0131 flash kartlar i\xE7in ay\u0131r\u0131c\u0131",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "\xC7ok sat\u0131rl\u0131 ters flash kartlar i\xE7in ay\u0131r\u0131c\u0131",
  MULTILINE_CARDS_END_MARKER: "Gizli kartlar ve \xE7ok sat\u0131rl\u0131 flash kartlar\u0131n sonunu belirten karakterler",
  NOTES: "Notlar",
  NOTE: "Note",
  REVIEW_PANE_ON_STARTUP: "Ba\u015Flang\u0131\xE7ta not inceleme panelini etkinle\u015Ftir",
  TAGS_TO_REVIEW: "G\xF6zden ge\xE7irilecek etiketler",
  TAGS_TO_REVIEW_DESC: "Etiketleri bo\u015Fluklar veya yeni sat\u0131rlarla ay\u0131rarak girin, \xF6rne\u011Fin: #review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "G\xF6zden ge\xE7irmek i\xE7in rastgele bir not a\xE7",
  OPEN_RANDOM_NOTE_DESC: "Bunu kapatt\u0131\u011F\u0131n\u0131zda, notlar \xF6nem s\u0131ras\u0131na g\xF6re s\u0131ralan\u0131r (PageRank).",
  AUTO_NEXT_NOTE: "Bir incelemeden sonra otomatik olarak bir sonraki notu a\xE7",
  MAX_N_DAYS_REVIEW_QUEUE: "Sa\u011F panelde g\xF6sterilecek maksimum g\xFCn say\u0131s\u0131",
  MIN_ONE_DAY: "G\xFCn say\u0131s\u0131 en az 1 olmal\u0131d\u0131r.",
  VALID_NUMBER_WARNING: "L\xFCtfen ge\xE7erli bir say\u0131 girin.",
  UI: "User Interface",
  OPEN_IN_TAB: "Open in new tab",
  OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
  SHOW_STATUS_BAR: "Show status bar",
  SHOW_STATUS_BAR_DESC: "Turn this off to hide the flashcard's review status in Obsidian's status bar",
  SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
  SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
  ENABLE_FILE_MENU_REVIEW_OPTIONS: "Enable the review options in the file menu (e.g. Review: Easy, Good, Hard)",
  ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "If you disable the review options in the file menu, you can review your notes using the plugin commands and, if you defined them, the associated command hotkeys.",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "Deste a\u011Fa\xE7lar\u0131 ba\u015Flang\u0131\xE7ta geni\u015Fletilmi\u015F olarak g\xF6sterilmeli mi",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "Bunu kapat\u0131n, ayn\u0131 dosyada bir\xE7ok desteye ait kartlar\u0131n\u0131z varsa i\xE7 i\xE7e desteleri daraltmak i\xE7in kullan\u0131\u015Fl\u0131d\u0131r.",
  ALGORITHM: "Algoritma",
  CHECK_ALGORITHM_WIKI: 'Daha fazla bilgi i\xE7in <a href="${algoUrl}">algoritma uygulamas\u0131na</a> g\xF6z at\u0131n.',
  SM2_OSR_VARIANT: "OSR's variant of SM-2",
  BASE_EASE: "Temel kolayl\u0131k",
  BASE_EASE_DESC: "minimum = 130, tercihen yakla\u015F\u0131k 250.",
  BASE_EASE_MIN_WARNING: "Temel kolayl\u0131k en az 130 olmal\u0131d\u0131r.",
  LAPSE_INTERVAL_CHANGE: "Bir flash kart\u0131/notu zor olarak inceledi\u011Finizde aral\u0131k de\u011Fi\u015Fikli\u011Fi",
  LAPSE_INTERVAL_CHANGE_DESC: "yeniAral\u0131k = eskiAral\u0131k * aral\u0131kDe\u011Fi\u015Fikli\u011Fi / 100.",
  EASY_BONUS: "Kolayl\u0131k Bonusu",
  EASY_BONUS_DESC: "Kolayl\u0131k bonusu, bir flash kart\u0131/notu \u0130yi ve Kolay yan\u0131tlad\u0131\u011F\u0131n\u0131zda aral\u0131klardaki fark\u0131 ayarlaman\u0131za olanak tan\u0131r (minimum = %100).",
  EASY_BONUS_MIN_WARNING: "Kolayl\u0131k bonusu en az %100 olmal\u0131d\u0131r.",
  LOAD_BALANCE: "Enable load balancer",
  LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
  MAX_INTERVAL: "Maksimum aral\u0131k (g\xFCn)",
  MAX_INTERVAL_DESC: "Aral\u0131\u011Fa bir \xFCst s\u0131n\u0131r koyman\u0131za olanak tan\u0131r (varsay\u0131lan = 100 y\u0131l).",
  MAX_INTERVAL_MIN_WARNING: "Maksimum aral\u0131k en az 1 g\xFCn olmal\u0131d\u0131r.",
  MAX_LINK_CONTRIB: "Maksimum ba\u011Flant\u0131 katk\u0131s\u0131",
  MAX_LINK_CONTRIB_DESC: "Ba\u011Flant\u0131l\u0131 notlar\u0131n a\u011F\u0131rl\u0131kl\u0131 kolayl\u0131k de\u011Ferinin ba\u015Flang\u0131\xE7 kolayl\u0131\u011F\u0131na maksimum katk\u0131s\u0131.",
  LOGGING: "Kay\u0131t tutma",
  DISPLAY_SCHEDULING_DEBUG_INFO: "Geli\u015Ftirici konsolunda hata ay\u0131klama bilgilerini g\xF6ster",
  DISPLAY_PARSER_DEBUG_INFO: "Ayr\u0131\u015Ft\u0131r\u0131c\u0131 i\xE7in hata ay\u0131klama bilgilerini geli\u015Ftirici konsolunda g\xF6ster",
  SCHEDULING: "Scheduling",
  EXPERIMENTAL: "Experimental",
  HELP: "Help",
  STORE_IN_NOTES: "In the notes",
  // sidebar.ts
  NOTES_REVIEW_QUEUE: "Not \u0130nceleme S\u0131ras\u0131",
  CLOSE: "Kapat",
  NEW: "Yeni",
  YESTERDAY: "D\xFCn",
  TODAY: "Bug\xFCn",
  TOMORROW: "Yar\u0131n",
  // stats-modal.tsx
  STATS_TITLE: "\u0130statistikler",
  MONTH: "Ay",
  QUARTER: "\xC7eyrek",
  YEAR: "Y\u0131l",
  LIFETIME: "\xD6m\xFCr Boyu",
  FORECAST: "Tahmin",
  FORECAST_DESC: "Gelecekte incelemeye al\u0131nacak kartlar\u0131n say\u0131s\u0131",
  SCHEDULED: "Planlanm\u0131\u015F",
  DAYS: "G\xFCnler",
  NUMBER_OF_CARDS: "Kart Say\u0131s\u0131",
  REVIEWS_PER_DAY: "Ortalama: ${avg} inceleme/g\xFCn",
  INTERVALS: "Aral\u0131klar",
  INTERVALS_DESC: "\u0130ncelemelerin tekrar g\xF6sterilme gecikmeleri",
  COUNT: "Say\u0131",
  INTERVALS_SUMMARY: "Ortalama aral\u0131k: ${avg}, En uzun aral\u0131k: ${longest}",
  EASES: "Kolayl\u0131klar",
  EASES_SUMMARY: "Ortalama kolayl\u0131k: ${avgEase}",
  EASE: "Ease",
  CARD_TYPES: "Kart T\xFCrleri",
  CARD_TYPES_DESC: "Bu, g\xF6m\xFCl\xFC kartlar\u0131 da i\xE7erir (varsa)",
  CARD_TYPE_NEW: "Yeni",
  CARD_TYPE_YOUNG: "Gen\xE7",
  CARD_TYPE_MATURE: "Olgun",
  CARD_TYPES_SUMMARY: "Toplam kart: ${totalCardsCount}",
  SEARCH: "Search",
  PREVIOUS: "Previous",
  NEXT: "Next"
};

// src/lang/locale/uk.ts
var uk_default = {};

// src/lang/locale/ur.ts
var ur_default = {};

// src/lang/locale/vi.ts
var vi_default = {};

// src/lang/locale/zh-cn.ts
var zh_cn_default = {
  // flashcard-modal.tsx
  DECKS: "\u5361\u7EC4",
  DUE_CARDS: "\u5230\u671F\u5361\u7247",
  NEW_CARDS: "\u65B0\u5361\u7247",
  TOTAL_CARDS: "\u5168\u90E8\u5361\u7247",
  BACK: "\u8FD4\u56DE",
  SKIP: "\u7565\u8FC7",
  EDIT_CARD: "\u7F16\u8F91\u5361\u7247",
  RESET_CARD_PROGRESS: "\u91CD\u7F6E\u5361\u7247",
  HARD: "\u8F83\u96BE",
  GOOD: "\u8BB0\u5F97",
  EASY: "\u7B80\u5355",
  SHOW_ANSWER: "\u663E\u793A\u7B54\u6848",
  CARD_PROGRESS_RESET: "\u5361\u7247\u5DF2\u88AB\u91CD\u7F6E\u3002",
  SAVE: "\u4FDD\u5B58",
  CANCEL: "\u53D6\u6D88",
  NO_INPUT: "\u6CA1\u6709\u63D0\u4F9B\u8F93\u5165\u3002",
  CURRENT_EASE_HELP_TEXT: "\u76EE\u524D\u638C\u63E1\u7A0B\u5EA6\uFF1A",
  CURRENT_INTERVAL_HELP_TEXT: "\u76EE\u524D\u95F4\u9694\uFF1A",
  CARD_GENERATED_FROM: "\u751F\u6210\u81EA\uFF1A${notePath}",
  // main.ts
  OPEN_NOTE_FOR_REVIEW: "\u6253\u5F00\u4E00\u4E2A\u7B14\u8BB0\u5F00\u59CB\u590D\u4E60",
  REVIEW_CARDS: "\u590D\u4E60\u5361\u7247",
  REVIEW_DIFFICULTY_FILE_MENU: "\u590D\u4E60\uFF1A${difficulty}",
  REVIEW_NOTE_DIFFICULTY_CMD: "\u6807\u8BB0\u4E3A\u201C${difficulty}\u201D",
  REVIEW_ALL_CARDS: "\u590D\u4E60\u6240\u6709\u7B14\u8BB0\u4E2D\u7684\u5361\u7247",
  CRAM_ALL_CARDS: "\u9009\u62E9\u8981\u96C6\u4E2D\u590D\u4E60\u7684\u5361\u7EC4",
  REVIEW_CARDS_IN_NOTE: "\u590D\u4E60\u6B64\u7B14\u8BB0\u4E2D\u7684\u5361\u7247",
  CRAM_CARDS_IN_NOTE: "\u96C6\u4E2D\u590D\u4E60\u6B64\u7B14\u8BB0\u4E2D\u7684\u5361\u7247",
  VIEW_STATS: "\u67E5\u770B\u6570\u636E",
  OPEN_REVIEW_QUEUE_VIEW: "\u5728\u4FA7\u8FB9\u680F\u4E2D\u6253\u5F00\u7B14\u8BB0\u590D\u4E60\u961F\u5217",
  STATUS_BAR: "\u590D\u4E60: ${dueNotesCount} \u7B14\u8BB0, ${dueFlashcardsCount} \u5361\u7247\u5DF2\u5230\u671F",
  SYNC_TIME_TAKEN: "\u540C\u6B65\u65F6\u95F4 ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "\u7B14\u8BB0\u4FDD\u5B58\u5728\u5DF2\u88AB\u5FFD\u7565\u7684\u8DEF\u5F84\u4E2D\uFF08\u68C0\u67E5\u8BBE\u7F6E\u9009\u9879\uFF09\u3002",
  PLEASE_TAG_NOTE: "\u8BF7\u5C06\u9700\u8981\u590D\u4E60\u7684\u7B14\u8BB0\u4E2D\u52A0\u5165\u6B63\u786E\u7684\u6807\u7B7E\uFF08\u68C0\u67E5\u8BBE\u7F6E\u9009\u9879\uFF09\u3002",
  RESPONSE_RECEIVED: "\u53CD\u9988\u5DF2\u6536\u5230",
  NO_DECK_EXISTS: "\u6CA1\u6709 ${deckName} \u5361\u7EC4",
  ALL_CAUGHT_UP: "\u90FD\u590D\u4E60\u5B8C\u5566\uFF0C\u4F60\u771F\u68D2\uFF01",
  // scheduling.ts
  DAYS_STR_IVL: "${interval}\u5929",
  MONTHS_STR_IVL: "${interval}\u6708",
  YEARS_STR_IVL: "${interval}\u5E74",
  DAYS_STR_IVL_MOBILE: "${interval}\u5929",
  MONTHS_STR_IVL_MOBILE: "${interval}\u6708",
  YEARS_STR_IVL_MOBILE: "${interval}\u5E74",
  // settings.ts
  SETTINGS_HEADER: "\u95F4\u9694\u91CD\u590D\u63D2\u4EF6",
  GROUP_TAGS_FOLDERS: "\u6807\u7B7E\u548C\u6587\u4EF6\u5939",
  GROUP_FLASHCARD_REVIEW: "\u95EA\u5361\u590D\u4E60",
  GROUP_FLASHCARD_SEPARATORS: "\u95EA\u5B58\u5361\u5206\u9694\u7B26",
  GROUP_DATA_STORAGE: "\u5B58\u50A8\u8BA1\u5212\u6570\u636E",
  GROUP_DATA_STORAGE_DESC: "\u9009\u62E9\u5B58\u50A8\u8BA1\u5212\u6570\u636E\u4F4D\u7F6E",
  GROUP_FLASHCARDS_NOTES: "\u95EA\u5361\u548C\u7B14\u8BB0",
  GROUP_CONTRIBUTING: "Contributing",
  CHECK_WIKI: '\u4E86\u89E3\u66F4\u591A, \u8BF7\u70B9\u51FB<a href="${wikiUrl}">wiki</a>.',
  GITHUB_DISCUSSIONS: 'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
  GITHUB_ISSUES: 'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
  GITHUB_SOURCE_CODE: 'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
  CODE_CONTRIBUTION_INFO: '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
  TRANSLATION_CONTRIBUTION_INFO: '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
  FOLDERS_TO_IGNORE: "\u5FFD\u7565\u6B64\u6587\u4EF6\u5939",
  FOLDERS_TO_IGNORE_DESC: "\u5728\u5355\u72EC\u4E00\u884C\u4E2D\u8F93\u5165\u6587\u4EF6\u5939\u8DEF\u5F84\u6216\u5168\u5C40\u6A21\u5F0F\uFF0C\u4F8B\u5982 Templates/Scripts \u6216 .excalidraw.md\u3002\u6B64\u8BBE\u7F6E\u5BF9\u95EA\u5B58\u5361\u548C\u7B14\u8BB0\u90FD\u901A\u7528\u3002",
  OBSIDIAN_INTEGRATION: "Integration into Obsidian",
  FLASHCARDS: "\u5361\u7247",
  FLASHCARD_EASY_LABEL: "\u201C\u7B80\u5355\u201D\u6309\u94AE\u6587\u672C",
  FLASHCARD_GOOD_LABEL: "\u201C\u8BB0\u5F97\u201D\u6309\u94AE\u6587\u672C",
  FLASHCARD_HARD_LABEL: "\u201C\u8F83\u96BE\u201D\u6309\u94AE\u6587\u672C",
  FLASHCARD_EASY_DESC: "\u81EA\u5B9A\u4E49\u201C\u7B80\u5355\u201D\u6309\u94AE\u7684\u6807\u7B7E",
  FLASHCARD_GOOD_DESC: "\u81EA\u5B9A\u4E49\u201C\u8BB0\u5F97\u201D\u6309\u94AE\u7684\u6807\u7B7E",
  FLASHCARD_HARD_DESC: "\u81EA\u5B9A\u4E49\u201C\u8F83\u96BE\u201D\u6309\u94AE\u7684\u6807\u7B7E",
  REVIEW_BUTTON_DELAY: "\u6309\u94AE\u6309\u4E0B\u5EF6\u8FDF\uFF08\u6BEB\u79D2\uFF09",
  REVIEW_BUTTON_DELAY_DESC: "\u5728\u518D\u6B21\u6309\u4E0B\u590D\u4E60\u6309\u94AE\u524D\u589E\u52A0\u5EF6\u8FDF\u3002",
  FLASHCARD_TAGS: "\u5361\u7247\u6807\u7B7E",
  FLASHCARD_TAGS_DESC: "\u8F93\u5165\u6807\u7B7E\uFF0C\u7528\u7A7A\u683C\u6216\u65B0\u5EFA\u884C\u5206\u9694\uFF0C\u4F8B\u5982\uFF1A#flashcards #deck2 #deck3.",
  CONVERT_FOLDERS_TO_DECKS: "\u5C06\u6587\u4EF6\u5939\u5185\u5BB9\u8F6C\u6362\u4E3A\u5361\u7247\u7EC4\u548C\u5B50\u5361\u7247\u7EC4",
  CONVERT_FOLDERS_TO_DECKS_DESC: "\u6B64\u9009\u9879\u4E3A\u5361\u7247\u6807\u7B7E\u9009\u9879\u7684\u66FF\u4EE3\u9009\u9879\u3002",
  INLINE_SCHEDULING_COMMENTS: "\u5C06\u8BA1\u5212\u91CD\u590D\u65E5\u671F\u4FDD\u5B58\u5728\u5361\u7247\u6700\u540E\u4E00\u884C\u7684\u540C\u4E00\u884C",
  INLINE_SCHEDULING_COMMENTS_DESC: "HTML\u6CE8\u91CA\u4E0D\u518D\u7834\u574F\u5217\u8868\u683C\u5F0F",
  BURY_SIBLINGS_TILL_NEXT_DAY: "\u5C06\u5173\u8054\u5361\u7247\u9690\u85CF\u81F3\u4E0B\u4E00\u5929",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "\u5173\u8054\u5361\u7247\u662F\u6765\u81EA\u540C\u4E00\u5361\u7247\u7684\u4E0D\u540C\u5F62\u5F0F\uFF0C \u4F8B\u5982\uFF1A\u5B8C\u5F62\u586B\u7A7A\u5361\u7247",
  SHOW_CARD_CONTEXT: "\u5728\u5361\u7247\u4E2D\u663E\u793A\u4E0A\u4E0B\u6587",
  SHOW_CARD_CONTEXT_DESC: "\u4F8B\u5982\uFF1A\u6807\u9898 > \u526F\u6807\u9898 > \u5C0F\u6807\u9898 > ... > \u5C0F\u6807\u9898",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS: "\u5C06\u4E0B\u6B21\u590D\u4E60\u65F6\u95F4\u663E\u793A\u5728\u590D\u4E60\u6309\u94AE",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC: "\u4E86\u89E3\u4F60\u7684\u5361\u7247\u88AB\u63A8\u8FDF\u4E86\u591A\u4E45\u5BF9\u4F60\u5F88\u6709\u7528",
  CARD_MODAL_HEIGHT_PERCENT: "\u5361\u7247\u9AD8\u5EA6\u767E\u5206\u6BD4",
  CARD_MODAL_SIZE_PERCENT_DESC: "\u8BF7\u5728\u79FB\u52A8\u7AEF\u4F7F\u7528\u5E76\u9700\u8981\u6D4F\u89C8\u8F83\u5927\u56FE\u7247\u65F6\u8BBE\u4E3A100%",
  RESET_DEFAULT: "\u91CD\u7F6E\u4E3A\u9ED8\u8BA4",
  CARD_MODAL_WIDTH_PERCENT: "\u5361\u7247\u5BBD\u5EA6\u767E\u5206\u6BD4",
  RANDOMIZE_CARD_ORDER: "\u590D\u4E60\u65F6\u968F\u673A\u663E\u793A\u5361\u7247\uFF1F",
  REVIEW_CARD_ORDER_WITHIN_DECK: "\u590D\u4E60\u65F6\u5361\u7247\u7EC4\u5185\u7684\u5361\u7247\u6392\u5E8F",
  REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "\u5361\u7247\u7EC4\u5185\u987A\u5E8F (\u5168\u90E8\u65B0\u5361\u7247\u4F18\u5148)",
  REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "\u5361\u7247\u7EC4\u5185\u987A\u5E8F (\u5168\u90E8\u5230\u671F\u5361\u7247\u4F18\u5148)",
  REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "\u5361\u7247\u7EC4\u5185\u4E71\u5E8F (\u5168\u90E8\u65B0\u5361\u7247\u4F18\u5148)",
  REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "\u5361\u7247\u7EC4\u5185\u4E71\u5E8F (\u5168\u90E8\u5230\u671F\u5361\u7247\u4F18\u5148)",
  REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "\u5361\u7247\u7EC4\u53CA\u5361\u7247\u90FD\u4E71\u5E8F",
  REVIEW_DECK_ORDER: "\u590D\u4E60\u65F6\u5361\u7247\u7EC4\u7684\u6392\u5E8F",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL: "\u987A\u5E8F (\u5728\u524D\u4E00\u5361\u7247\u7EC4\u5185\u5361\u7247\u90FD\u590D\u4E60\u5B8C\u540E)",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM: "\u4E71\u5E8F (\u5728\u524D\u4E00\u5361\u7247\u7EC4\u5185\u5361\u7247\u90FD\u590D\u4E60\u5B8C\u540E)",
  REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "\u5361\u7247\u7EC4\u53CA\u5361\u7247\u90FD\u4E71\u5E8F",
  DISABLE_CLOZE_CARDS: "\u4E0D\u8FDB\u884C\u5B8C\u5F62\u586B\u7A7A",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "\u5C06 ==\u9AD8\u4EAE== \u8F6C\u6362\u4E3A\u5B8C\u5F62\u586B\u7A7A",
  CONVERT_HIGHLIGHTS_TO_CLOZES_DESC: '\u6DFB\u52A0/\u5220\u9664 "\u5B8C\u5F62\u586B\u7A7A\u6A21\u5F0F" \u4E2D\u7684 <code>${defaultPattern}</code>',
  CONVERT_BOLD_TEXT_TO_CLOZES: "\u5C06 **\u7C97\u4F53** \u8F6C\u6362\u4E3A\u5B8C\u5F62\u586B\u7A7A",
  CONVERT_BOLD_TEXT_TO_CLOZES_DESC: '\u6DFB\u52A0/\u5220\u9664 "\u5B8C\u5F62\u586B\u7A7A\u6A21\u5F0F" \u4E2D\u7684 <code>${defaultPattern}</code>',
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "\u5C06 {{\u5927\u62EC\u53F7}} \u8F6C\u6362\u4E3A\u5B8C\u5F62\u586B\u7A7A",
  CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC: '\u6DFB\u52A0/\u5220\u9664 "\u5B8C\u5F62\u586B\u7A7A\u6A21\u5F0F" \u4E2D\u7684 <code>${defaultPattern}</code>',
  CLOZE_PATTERNS: "\u5B8C\u5F62\u586B\u7A7A\u6A21\u5F0F",
  CLOZE_PATTERNS_DESC: '\u8F93\u5165\u4EE5\u6362\u884C\u7B26\u5206\u9694\u7684\u5B8C\u5F62\u586B\u7A7A\u6A21\u5F0F. Check the <a href="${docsUrl}">wiki</a> for guidance.',
  INLINE_CARDS_SEPARATOR: "\u5355\u884C\u5361\u7247\u7684\u5206\u9694\u7B26",
  FIX_SEPARATORS_MANUALLY_WARNING: "\u6CE8\u610F\uFF1A\u66F4\u6539\u6B64\u9009\u9879\u540E\u4F60\u5C06\u9700\u8981\u81EA\u884C\u66F4\u6539\u5DF2\u5B58\u5728\u5361\u7247\u7684\u5206\u9694\u7B26\u3002",
  INLINE_REVERSED_CARDS_SEPARATOR: "\u5355\u884C\u7FFB\u8F6C\u5361\u7247\u7684\u5206\u9694\u7B26",
  MULTILINE_CARDS_SEPARATOR: "\u591A\u884C\u5361\u7247\u7684\u5206\u9694\u7B26",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "\u591A\u884C\u7FFB\u8F6C\u5361\u7247\u7684\u5206\u9694\u7B26",
  MULTILINE_CARDS_END_MARKER: "\u8868\u793A\u586B\u7A7A\u548C\u591A\u884C\u95EA\u5361\u7ED3\u675F\u7684\u5B57\u7B26",
  NOTES: "\u7B14\u8BB0",
  NOTE: "Note",
  REVIEW_PANE_ON_STARTUP: "\u542F\u52A8\u65F6\u5F00\u542F\u7B14\u8BB0\u590D\u4E60\u7A97\u683C",
  TAGS_TO_REVIEW: "\u590D\u4E60\u6807\u7B7E",
  TAGS_TO_REVIEW_DESC: "\u8F93\u5165\u6807\u7B7E\uFF0C\u7528\u7A7A\u683C\u6216\u65B0\u5EFA\u884C\u5206\u9694\uFF0C\u4F8B\u5982\uFF1A#review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "\u590D\u4E60\u968F\u673A\u7B14\u8BB0",
  OPEN_RANDOM_NOTE_DESC: "\u5173\u95ED\u6B64\u9009\u9879\uFF0C\u7B14\u8BB0\u5C06\u4EE5\u91CD\u8981\u5EA6(PageRank)\u6392\u5E8F\u3002",
  AUTO_NEXT_NOTE: "\u590D\u4E60\u540E\u81EA\u52A8\u6253\u5F00\u4E0B\u4E00\u4E2A\u7B14\u8BB0",
  ENABLE_FILE_MENU_REVIEW_OPTIONS: "\u8BF7\u5728\u6587\u4EF6\u83DC\u5355\u4E2D\u542F\u7528\u590D\u4E60\u9009\u9879\uFF08\u4F8B\u5982\uFF1A\u590D\u4E60\uFF1A\u7B80\u5355\u3001\u826F\u597D\u3001\u56F0\u96BE",
  ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "\u5982\u679C\u60A8\u5728\u6587\u4EF6\u83DC\u5355\u4E2D\u7981\u7528\u590D\u4E60\u9009\u9879\uFF0C\u60A8\u53EF\u4EE5\u4F7F\u7528\u63D2\u4EF6\u547D\u4EE4\u6765\u590D\u4E60\u7B14\u8BB0\uFF0C\u5982\u679C\u60A8\u5B9A\u4E49\u4E86\u76F8\u5173\u5FEB\u6377\u952E\uFF0C\u4E5F\u53EF\u4EE5\u4F7F\u7528\u5B83\u4EEC\u3002",
  MAX_N_DAYS_REVIEW_QUEUE: "\u53F3\u8FB9\u680F\u4E2D\u663E\u793A\u7684\u6700\u5927\u5929\u6570",
  MIN_ONE_DAY: "\u5929\u6570\u6700\u5C0F\u503C\u4E3A1",
  VALID_NUMBER_WARNING: "\u8BF7\u8F93\u5165\u6709\u6548\u7684\u6570\u5B57\u3002",
  UI: "User Interface",
  OPEN_IN_TAB: "\u5728\u65B0\u6807\u7B7E\u6253\u5F00",
  OPEN_IN_TAB_DESC: "\u5173\u95ED\u6B64\u9009\u9879\u53EF\u5728\u6A21\u5F0F\u7A97\u53E3\u4E2D\u6253\u5F00\u63D2\u4EF6",
  SHOW_STATUS_BAR: "\u663E\u793A\u5728\u72B6\u6001\u680F",
  SHOW_STATUS_BAR_DESC: "\u5C06\u6B64\u5173\u95ED\u4EE5\u9690\u85CF Obsidian \u72B6\u6001\u680F\u4E2D\u7684\u5361\u7247\u590D\u4E60\u72B6\u6001\u3002",
  SHOW_RIBBON_ICON: "\u5728\u529F\u80FD\u533A\u4E2D\u663E\u793A\u56FE\u6807",
  SHOW_RIBBON_ICON_DESC: "\u5173\u95ED\u6B64\u9009\u9879\u53EF\u9690\u85CF Obsidian \u529F\u80FD\u533A\u680F\u4E2D\u7684\u63D2\u4EF6\u56FE\u6807",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "\u9ED8\u8BA4\u5728\u5217\u8868\u4E2D\u5C55\u5F00\u5D4C\u5957\u5B50\u724C\u7EC4",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "\u5173\u95ED\u6B64\u9009\u9879\u53EF\u6298\u53E0\u540C\u4E00\u5F20\u5361\u7247\u4E2D\u7684\u5D4C\u5957\u724C\u7EC4\u3002\u5982\u679C\u60A8\u7684\u5361\u7247\u5C5E\u4E8E\u540C\u4E00\u6587\u4EF6\u4E2D\u7684\u8BB8\u591A\u5957\u724C\uFF0C\u5219\u5F88\u6709\u7528\u3002",
  ALGORITHM: "\u7B97\u6CD5",
  CHECK_ALGORITHM_WIKI: '\u4E86\u89E3\u66F4\u591A, \u8BF7\u70B9\u51FB<a href="${algoUrl}">\u7B97\u6CD5\u5B9E\u73B0</a>.',
  SM2_OSR_VARIANT: "OSR's variant of SM-2",
  BASE_EASE: "\u57FA\u7840\u638C\u63E1\u7A0B\u5EA6",
  BASE_EASE_DESC: "\u6700\u5C0F\u503C130\uFF0C\u63A8\u8350\u503C\u7EA6250.",
  BASE_EASE_MIN_WARNING: "\u57FA\u7840\u638C\u63E1\u7A0B\u5EA6\u7684\u6700\u5C0F\u503C\u4E3A130\u3002",
  LAPSE_INTERVAL_CHANGE: "\u5C06\u590D\u4E60\u65F6\u6807\u6CE8\u4E3A\u201C\u8F83\u96BE\u201D\u7684\u5361\u7247\u6216\u7B14\u8BB0\u590D\u4E60\u95F4\u9694\u7F29\u77ED",
  LAPSE_INTERVAL_CHANGE_DESC: "\u65B0\u590D\u4E60\u95F4\u9694 = \u539F\u590D\u4E60\u95F4\u9694 * \u95F4\u9694\u6539\u53D8\u7CFB\u6570 / 100.",
  EASY_BONUS: "\u7B80\u5355\u5956\u52B1",
  EASY_BONUS_DESC: "\u7B80\u5355\u5956\u52B1\u8BBE\u5B9A\u201C\u8BB0\u5F97\u201D\u548C\u201C\u7B80\u5355\u201D\u5361\u7247\u6216\u7B14\u8BB0\u7684\u590D\u4E60\u95F4\u9694\u5DEE\u8DDD\uFF08\u6700\u5C0F\u503C100%\uFF09\u3002",
  EASY_BONUS_MIN_WARNING: "\u7B80\u5355\u5956\u52B1\u81F3\u5C11\u4E3A100\u3002",
  LOAD_BALANCE: "Enable load balancer",
  LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
  MAX_INTERVAL: "\u6700\u5927\u95F4\u9694\uFF08\u5929\uFF09",
  MAX_INTERVAL_DESC: "\u8BBE\u5B9A\u590D\u4E60\u7684\u6700\u5927\u95F4\u9694\u65F6\u95F4\uFF08\u9ED8\u8BA4\u503C100\u5E74\uFF09\u3002",
  MAX_INTERVAL_MIN_WARNING: "\u6700\u5927\u95F4\u9694\u81F3\u5C11\u4E3A1\u5929",
  MAX_LINK_CONTRIB: "\u6700\u5927\u94FE\u63A5\u6536\u76CA",
  MAX_LINK_CONTRIB_DESC: "\u94FE\u63A5\u7B14\u8BB0\u7684\u52A0\u6743\u638C\u63E1\u7A0B\u5EA6\u5BF9\u539F\u59CB\u638C\u63E1\u7A0B\u5EA6\u7684\u6700\u5927\u8D21\u732E\u3002",
  LOGGING: "\u8BB0\u5F55\u4E2D",
  DISPLAY_SCHEDULING_DEBUG_INFO: "\u5728\u5F00\u53D1\u8005\u63A7\u5236\u53F0\u4E2D\u663E\u793A\u8C03\u8BD5\u4FE1\u606F",
  DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
  SCHEDULING: "Scheduling",
  EXPERIMENTAL: "Experimental",
  HELP: "Help",
  STORE_IN_NOTES: "In the notes",
  // sidebar.ts
  NOTES_REVIEW_QUEUE: "\u7B14\u8BB0\u590D\u4E60\u5E8F\u5217",
  CLOSE: "\u4E34\u8FD1",
  NEW: "\u65B0",
  YESTERDAY: "\u6628\u5929",
  TODAY: "\u4ECA\u5929",
  TOMORROW: "\u660E\u5929",
  // stats-modal.tsx
  STATS_TITLE: "\u6570\u636E",
  MONTH: "\u6708",
  QUARTER: "\u5B63",
  YEAR: "\u5E74",
  LIFETIME: "\u5168\u90E8",
  FORECAST: "\u9884\u671F",
  FORECAST_DESC: "\u5C06\u8981\u5230\u671F\u7684\u5361\u7247\u6570\u91CF",
  SCHEDULED: "\u5DF2\u6392\u671F",
  DAYS: "\u5929",
  NUMBER_OF_CARDS: "\u5361\u7247\u6570\u91CF",
  REVIEWS_PER_DAY: "\u5E73\u5747: \u590D\u4E60${avg} /\u5929",
  INTERVALS: "\u95F4\u9694",
  INTERVALS_DESC: "\u5230\u4E0B\u4E00\u6B21\u590D\u4E60\u7684\u65F6\u95F4\u95F4\u9694",
  COUNT: "\u8BA1\u6570",
  INTERVALS_SUMMARY: "\u5E73\u5747\u95F4\u9694\u65F6\u95F4: ${avg}, \u6700\u957F\u95F4\u9694\u65F6\u95F4: ${longest}",
  EASES: "\u638C\u63E1\u7A0B\u5EA6",
  EASES_SUMMARY: "\u5E73\u5747\u638C\u63E1\u7A0B\u5EA6: ${avgEase}",
  EASE: "Ease",
  CARD_TYPES: "\u5361\u7247\u7C7B\u578B",
  CARD_TYPES_DESC: "\u5982\u6709\uFF0C\u5C06\u663E\u793A\u9690\u85CF\u7684\u5361\u7247",
  CARD_TYPE_NEW: "\u65B0",
  CARD_TYPE_YOUNG: "\u8F83\u65B0",
  CARD_TYPE_MATURE: "\u719F\u6089",
  CARD_TYPES_SUMMARY: "\u603B\u5361\u7247\u6570: ${totalCardsCount}",
  SEARCH: "Search",
  PREVIOUS: "Previous",
  NEXT: "Next"
};

// src/lang/locale/zh-tw.ts
var zh_tw_default = {
  // flashcard-modal.tsx
  DECKS: "\u724C\u7D44",
  DUE_CARDS: "\u5230\u671F\u5361\u7247",
  NEW_CARDS: "\u65B0\u5361\u7247",
  TOTAL_CARDS: "\u5168\u90E8\u5361\u7247",
  BACK: "\u8FD4\u56DE",
  SKIP: "\u7565\u904E",
  EDIT_CARD: "\u7DE8\u8F2F\u5361\u7247",
  RESET_CARD_PROGRESS: "\u91CD\u7F6E\u5361\u7247",
  HARD: "\u8F03\u96E3",
  GOOD: "\u8A18\u5F97",
  EASY: "\u7C21\u55AE",
  SHOW_ANSWER: "\u986F\u793A\u7B54\u6848",
  CARD_PROGRESS_RESET: "\u5361\u7247\u5DF2\u88AB\u91CD\u7F6E\u3002",
  SAVE: "\u5132\u5B58",
  CANCEL: "\u53D6\u6D88",
  NO_INPUT: "\u6C92\u6709\u63D0\u4F9B\u8F38\u5165\u3002",
  CURRENT_EASE_HELP_TEXT: "\u76EE\u524D\u638C\u63E1\u7A0B\u5EA6\uFF1A",
  CURRENT_INTERVAL_HELP_TEXT: "\u76EE\u524D\u9593\u9694\u6642\u9593\uFF1A",
  CARD_GENERATED_FROM: "\u751F\u6210\u81EA\uFF1A${notePath}",
  // main.ts
  OPEN_NOTE_FOR_REVIEW: "\u6253\u958B\u4E00\u500B\u7B46\u8A18\u958B\u59CB\u5FA9\u7FD2",
  REVIEW_CARDS: "\u5FA9\u7FD2\u5361\u7247",
  REVIEW_DIFFICULTY_FILE_MENU: "\u5FA9\u7FD2\uFF1A${difficulty}",
  REVIEW_NOTE_DIFFICULTY_CMD: "\u6A19\u8A18\u70BA\u300C${difficulty}\u300D",
  REVIEW_CARDS_IN_NOTE: "\u5FA9\u7FD2\u6B64\u7B46\u8A18\u4E2D\u7684\u5361\u7247",
  CRAM_ALL_CARDS: "\u9078\u64C7\u8981\u4E0D\u8A08\u96E3\u6613\u5EA6\u5FA9\u7FD2\u7684\u724C\u7D44",
  REVIEW_ALL_CARDS: "\u5FA9\u7FD2\u6240\u6709\u7B46\u8A18\u4E2D\u7684\u5361\u7247",
  CRAM_CARDS_IN_NOTE: "\u4E0D\u8A08\u96E3\u6613\u5EA6\u5FA9\u7FD2\u6B64\u7B46\u8A18\u4E2D\u7684\u5361\u7247",
  VIEW_STATS: "\u6AA2\u8996\u6578\u64DA",
  OPEN_REVIEW_QUEUE_VIEW: "Open Notes Review Queue in sidebar",
  STATUS_BAR: "\u5FA9\u7FD2: ${dueNotesCount} \u7B46\u8A18, ${dueFlashcardsCount} \u5361\u7247\u5DF2\u5230\u671F",
  SYNC_TIME_TAKEN: "\u540C\u6B65\u6642\u9593 ${t}ms",
  NOTE_IN_IGNORED_FOLDER: "\u7B46\u8A18\u5132\u5B58\u5728\u5DF2\u88AB\u5FFD\u7565\u7684\u8DEF\u5F91\u4E2D\uFF08\u6AA2\u67E5\u8A2D\u5B9A\u9078\u9805\uFF09\u3002",
  PLEASE_TAG_NOTE: "\u8ACB\u5C07\u9700\u8981\u5FA9\u7FD2\u7684\u7B46\u8A18\u4E2D\u52A0\u5165\u6B63\u78BA\u7684\u6A19\u7C64\uFF08\u6AA2\u67E5\u8A2D\u5B9A\u9078\u9805\uFF09\u3002",
  RESPONSE_RECEIVED: "\u56DE\u994B\u5DF2\u6536\u5230",
  NO_DECK_EXISTS: "\u6C92\u6709 ${deckName} \u724C\u7D44",
  ALL_CAUGHT_UP: "\u90FD\u5FA9\u7FD2\u5B8C\u5566\uFF0C\u4F60\u771F\u68D2\uFF01",
  // scheduling.ts
  DAYS_STR_IVL: "${interval}\u5929",
  MONTHS_STR_IVL: "${interval}\u6708",
  YEARS_STR_IVL: "${interval}\u5E74",
  DAYS_STR_IVL_MOBILE: "${interval}\u5929",
  MONTHS_STR_IVL_MOBILE: "${interval}\u6708",
  YEARS_STR_IVL_MOBILE: "${interval}\u5E74",
  // settings.ts
  SETTINGS_HEADER: "\u9593\u9694\u91CD\u8907\u5916\u639B",
  GROUP_TAGS_FOLDERS: "Tags & Folders",
  GROUP_FLASHCARD_REVIEW: "Flashcard Review",
  GROUP_FLASHCARD_SEPARATORS: "Flashcard Separators",
  GROUP_DATA_STORAGE: "Storage of Scheduling Data",
  GROUP_DATA_STORAGE_DESC: "Choose where to store the scheduling data",
  GROUP_FLASHCARDS_NOTES: "Flashcards & Notes",
  GROUP_CONTRIBUTING: "Contributing",
  CHECK_WIKI: '\u77AD\u89E3\u66F4\u591A, \u8ACB\u9EDE\u9078<a href="${wikiUrl}">wiki</a>.',
  GITHUB_DISCUSSIONS: 'Visit the <a href="${discussionsUrl}">discussions</a> section for Q&A help, feedback, and general discussion.',
  GITHUB_ISSUES: 'Raise an issue <a href="${issuesUrl}">here</a> if you have a feature request or a bug report.',
  GITHUB_SOURCE_CODE: 'The project\'s source code is available on <a href="${githubProjectUrl}">GitHub</a>.',
  CODE_CONTRIBUTION_INFO: '<a href="${codeContributionUrl}">Here\'s</a> how to contribute code to the plugin.',
  TRANSLATION_CONTRIBUTION_INFO: '<a href="${translationContributionUrl}">Here\'s</a> how to translate the plugin to another language.',
  FOLDERS_TO_IGNORE: "\u5FFD\u7565\u6B64\u8CC7\u6599\u593E",
  FOLDERS_TO_IGNORE_DESC: "Enter folder paths or glob patterns on separate lines e.g. Templates/Scripts or **/*.excalidraw.md. This setting is common to both flashcards and notes.",
  OBSIDIAN_INTEGRATION: "Integration into Obsidian",
  FLASHCARDS: "\u5361\u7247",
  FLASHCARD_EASY_LABEL: "\u7C21\u55AE\u6309\u9215\u6587\u5B57",
  FLASHCARD_GOOD_LABEL: "\u8A18\u5F97\u6309\u9215\u6587\u5B57",
  FLASHCARD_HARD_LABEL: "\u8F03\u96E3\u6309\u9215\u6587\u5B57",
  FLASHCARD_EASY_DESC: "\u81EA\u8A02\u300C\u7C21\u55AE\u300D\u6309\u9215\u7684\u6A19\u7C64",
  FLASHCARD_GOOD_DESC: "\u81EA\u8A02\u300C\u8A18\u5F97\u300D\u6309\u9215\u7684\u6A19\u7C64",
  FLASHCARD_HARD_DESC: "\u81EA\u8A02\u300C\u8F03\u96E3\u300D\u6309\u9215\u7684\u6A19\u7C64",
  REVIEW_BUTTON_DELAY: "Button Press Delay (ms)",
  REVIEW_BUTTON_DELAY_DESC: "Add a delay to the review buttons before they can be pressed again.",
  FLASHCARD_TAGS: "\u5361\u7247\u6A19\u7C64",
  FLASHCARD_TAGS_DESC: "\u8F38\u5165\u6A19\u7C64\uFF08\u7528\u7A7A\u767D\u6216\u63DB\u884C\u5B57\u5143\u5206\u9694\uFF09\uFF0C\u4F8B\u5982\uFF1A#flashcards #deck2 #deck3.",
  CONVERT_FOLDERS_TO_DECKS: "\u662F\u5426\u5C07\u8CC7\u6599\u593E\u5167\u5BB9\u8F49\u63DB\u70BA\u724C\u7D44\u548C\u5B50\u724C\u7D44\uFF1F",
  CONVERT_FOLDERS_TO_DECKS_DESC: "\u6B64\u9078\u9805\u70BA\u5361\u7247\u6A19\u7C64\u9078\u9805\u7684\u66FF\u4EE3\u9078\u9805\u3002",
  INLINE_SCHEDULING_COMMENTS: "\u662F\u5426\u5C07\u8A08\u5283\u91CD\u8907\u6642\u9593\u5132\u5B58\u5728\u5361\u7247\u6700\u5F8C\u4E00\u884C\u7684\u540C\u4E00\u884C\uFF1F",
  INLINE_SCHEDULING_COMMENTS_DESC: "\u52FE\u9078\u5F8CHTML\u8A3B\u89E3\u4E0D\u6703\u7834\u58DE\u5217\u8868\u683C\u5F0F\u554F\u984C\u3002",
  BURY_SIBLINGS_TILL_NEXT_DAY: "\u5C07\u53CD\u8F49\u5361\u7247\u96B1\u85CF\u81F3\u4E0B\u4E00\u5929\uFF1F",
  BURY_SIBLINGS_TILL_NEXT_DAY_DESC: "\u53CD\u8F49\u5361\u7247\u7531\u540C\u4E00\u5361\u7247\u6587\u5B57\u7522\u751F\uFF0C\u4F8B\u5982\uFF1A\u586B\u7A7A\u514B\u6F0F\u5B57",
  SHOW_CARD_CONTEXT: "\u5728\u5361\u7247\u4E2D\u986F\u793A\u4E0A\u4E0B\u6587\uFF1F",
  SHOW_CARD_CONTEXT_DESC: "\u4F8B\u5982\uFF1A\u6A19\u984C > \u526F\u6A19\u984C > \u5C0F\u6A19\u984C > ... > \u5C0F\u6A19\u984C",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS: "Show next review time in the review buttons",
  SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC: "Useful to know how far in the future your cards are being pushed.",
  CARD_MODAL_HEIGHT_PERCENT: "\u5361\u7247\u9AD8\u5EA6\u767E\u5206\u6BD4",
  CARD_MODAL_SIZE_PERCENT_DESC: "\u5728\u79FB\u52D5\u7AEF\u6216\u9700\u8981\u8F03\u5927\u5716\u7247\u6642\u61C9\u8A2D\u5B9A\u70BA100%",
  RESET_DEFAULT: "\u91CD\u7F6E\u70BA\u9810\u8A2D\u503C",
  CARD_MODAL_WIDTH_PERCENT: "\u5361\u7247\u5BEC\u5EA6\u767E\u5206\u6BD4",
  RANDOMIZE_CARD_ORDER: "\u5FA9\u7FD2\u6642\u96A8\u6A5F\u986F\u793A\u5361\u7247\uFF1F",
  REVIEW_CARD_ORDER_WITHIN_DECK: "\u5FA9\u7FD2\u6642\u724C\u7D44\u5167\u7684\u5361\u7247\u6392\u5E8F",
  REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL: "\u724C\u7D44\u5167\u9806\u5E8F (\u5168\u90E8\u65B0\u5361\u7247\u512A\u5148)",
  REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL: "\u724C\u7D44\u5167\u9806\u5E8F (\u5168\u90E8\u5230\u671F\u5361\u7247\u512A\u5148)",
  REVIEW_CARD_ORDER_NEW_FIRST_RANDOM: "\u724C\u7D44\u5167\u4E82\u5E8F (\u5168\u90E8\u65B0\u5361\u7247\u512A\u5148)",
  REVIEW_CARD_ORDER_DUE_FIRST_RANDOM: "\u724C\u7D44\u5167\u4E82\u5E8F (\u5168\u90E8\u5230\u671F\u5361\u7247\u512A\u5148)",
  REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD: "\u724C\u7D44\u53CA\u5361\u7247\u90FD\u4E82\u5E8F",
  REVIEW_DECK_ORDER: "\u5FA9\u7FD2\u6642\u724C\u7D44\u7684\u6392\u5E8F",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL: "\u9806\u5E8F (\u5728\u524D\u4E00\u724C\u7D44\u5167\u5361\u7247\u90FD\u5FA9\u7FD2\u5B8C\u5F8C)",
  REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM: "\u4E82\u5E8F (\u5728\u524D\u4E00\u724C\u7D44\u5167\u5361\u7247\u90FD\u5FA9\u7FD2\u5B8C\u5F8C)",
  REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD: "\u724C\u7D44\u53CA\u5361\u7247\u90FD\u4E82\u5E8F",
  DISABLE_CLOZE_CARDS: "\u505C\u7528\u586B\u7A7A\u514B\u6F0F\u5B57\u5361\u7247\uFF1F",
  CONVERT_HIGHLIGHTS_TO_CLOZES: "\u5C07 ==\u9AD8\u4EAE== \u8F49\u63DB\u70BA\u586B\u7A7A\u514B\u6F0F\u5B57\uFF1F",
  CONVERT_HIGHLIGHTS_TO_CLOZES_DESC: '\u5728 "\u586B\u7A7A\u514B\u6F0F\u5B57\u6A21\u5F0F" \u4E2D\u52A0\u5165/\u79FB\u9664 <code>${defaultPattern}</code>',
  CONVERT_BOLD_TEXT_TO_CLOZES: "\u5C07 **\u7C97\u9AD4** \u8F49\u63DB\u70BA\u586B\u7A7A\u514B\u6F0F\u5B57\uFF1F",
  CONVERT_BOLD_TEXT_TO_CLOZES_DESC: '\u5728 "\u586B\u7A7A\u514B\u6F0F\u5B57\u6A21\u5F0F" \u4E2D\u52A0\u5165/\u79FB\u9664 <code>${defaultPattern}</code>',
  CONVERT_CURLY_BRACKETS_TO_CLOZES: "\u5C07 {{\u5927\u62EC\u865F}} \u8F49\u63DB\u70BA\u586B\u7A7A\u514B\u6F0F\u5B57\uFF1F",
  CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC: '\u5728 "\u586B\u7A7A\u514B\u6F0F\u5B57\u6A21\u5F0F" \u4E2D\u52A0\u5165/\u79FB\u9664 <code>${defaultPattern}</code>',
  CLOZE_PATTERNS: "\u586B\u7A7A\u514B\u6F0F\u5B57\u6A21\u5F0F",
  CLOZE_PATTERNS_DESC: '\u8F38\u5165\u4EE5\u63DB\u884C\u7B26\u5206\u9694\u7684\u586B\u7A7A\u514B\u6F0F\u5B57\u6A21\u5F0F. Check the <a href="${docsUrl}">wiki</a> for guidance.',
  INLINE_CARDS_SEPARATOR: "\u55AE\u884C\u5361\u7247\u7684\u5206\u9694\u5B57\u5143",
  FIX_SEPARATORS_MANUALLY_WARNING: "\u6CE8\u610F\uFF1A\u66F4\u6539\u6B64\u9078\u9805\u5F8C\u4F60\u5C07\u9700\u8981\u81EA\u884C\u66F4\u6539\u5DF2\u5B58\u5728\u5361\u7247\u7684\u5206\u9694\u5B57\u5143\u3002",
  INLINE_REVERSED_CARDS_SEPARATOR: "\u55AE\u884C\u53CD\u8F49\u5361\u7247\u7684\u5206\u9694\u5B57\u5143",
  MULTILINE_CARDS_SEPARATOR: "\u591A\u884C\u5361\u7247\u7684\u5206\u9694\u5B57\u5143",
  MULTILINE_REVERSED_CARDS_SEPARATOR: "\u591A\u884C\u7FFB\u8F49\u5361\u7247\u7684\u5206\u9694\u5B57\u5143",
  MULTILINE_CARDS_END_MARKER: "\u8868\u793A\u586B\u7A7A\u548C\u591A\u884C\u95EA\u5361\u7ED3\u675F\u7684\u5B57\u7B26",
  NOTES: "\u7B46\u8A18",
  NOTE: "Note",
  REVIEW_PANE_ON_STARTUP: "\u555F\u52D5\u6642\u958B\u555F\u7B46\u8A18\u5FA9\u7FD2\u7A97\u683C",
  TAGS_TO_REVIEW: "\u5FA9\u7FD2\u6A19\u7C64",
  TAGS_TO_REVIEW_DESC: "\u8F38\u5165\u6A19\u7C64\uFF0C\u7528\u7A7A\u683C\u6216\u63DB\u884C\u5B57\u5143\u5206\u9694\uFF0C\u4F8B\u5982\uFF1A#review #tag2 #tag3.",
  OPEN_RANDOM_NOTE: "\u5FA9\u7FD2\u96A8\u6A5F\u7B46\u8A18",
  OPEN_RANDOM_NOTE_DESC: "\u95DC\u9589\u6B64\u9078\u9805\uFF0C\u7B46\u8A18\u5C07\u4EE5\u91CD\u8981\u5EA6(PageRank)\u6392\u5E8F\u3002",
  AUTO_NEXT_NOTE: "\u5FA9\u7FD2\u5F8C\u81EA\u52D5\u6253\u958B\u4E0B\u4E00\u500B\u7B46\u8A18",
  ENABLE_FILE_MENU_REVIEW_OPTIONS: "\u8ACB\u5728\u6A94\u6848\u9078\u55AE\u4E2D\u555F\u7528\u6AA2\u8996\u9078\u9805\uFF08\u4F8B\u5982\uFF1A\u6AA2\u8996\uFF1A\u7C21\u55AE\u3001\u8A18\u5F97\u3001\u8F03\u96E3\uFF09",
  ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC: "\u5982\u679C\u60A8\u5728\u6A94\u6848\u9078\u55AE\u4E2D\u505C\u7528\u6AA2\u8996\u9078\u9805\uFF0C\u60A8\u53EF\u4EE5\u4F7F\u7528\u63D2\u4EF6\u6307\u4EE4\u6AA2\u8996\u7B46\u8A18\uFF0C\u5982\u679C\u6709\u8A2D\u5B9A\uFF0C\u4E5F\u53EF\u4EE5\u4F7F\u7528\u76F8\u95DC\u7684\u5FEB\u6377\u9375\u3002",
  MAX_N_DAYS_REVIEW_QUEUE: "\u53F3\u908A\u9762\u677F\u986F\u793A\u7684\u6700\u5927\u5929\u6578",
  MIN_ONE_DAY: "\u5929\u6578\u6700\u5C0F\u503C\u70BA1",
  VALID_NUMBER_WARNING: "\u8ACB\u8F38\u5165\u6709\u6548\u7684\u6578\u5B57\u3002",
  UI: "User Interface",
  OPEN_IN_TAB: "Open in new tab",
  OPEN_IN_TAB_DESC: "Turn this off to open the plugin in a modal window",
  SHOW_STATUS_BAR: "Show status bar",
  SHOW_STATUS_BAR_DESC: "Turn this off to hide the flashcard's review status in Obsidian's status bar",
  SHOW_RIBBON_ICON: "Show icon in the ribbon bar",
  SHOW_RIBBON_ICON_DESC: "Turn this off to hide the plugin icon from Obsidian's ribbon bar",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE: "\u724C\u7D44\u6A39\u6700\u521D\u61C9\u986F\u793A\u70BA\u5C55\u958B",
  INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC: "\u95DC\u9589\u6B64\u9078\u9805\u53EF\u647A\u758A\u540C\u4E00\u5F35\u5361\u7247\u4E2D\u7684\u5DE2\u72C0\u724C\u7D44\u3002\u5982\u679C\u60A8\u7684\u5361\u7247\u5C6C\u65BC\u540C\u4E00\u6A94\u6848\u4E2D\u7684\u8A31\u591A\u5957\u724C\uFF0C\u5247\u5F88\u6709\u7528\u3002",
  ALGORITHM: "\u6F14\u7B97\u6CD5",
  CHECK_ALGORITHM_WIKI: '\u77AD\u89E3\u66F4\u591A, \u8ACB\u9EDE\u9078<a href="${algoUrl}">\u7B97\u6CD5\u5BE6\u73FE</a>.',
  SM2_OSR_VARIANT: "OSR's variant of SM-2",
  BASE_EASE: "\u57FA\u790E\u638C\u63E1\u7A0B\u5EA6",
  BASE_EASE_DESC: "\u6700\u5C0F\u503C130\uFF0C\u63A8\u85A6\u503C\u7D04250.",
  BASE_EASE_MIN_WARNING: "\u57FA\u790E\u638C\u63E1\u7A0B\u5EA6\u7684\u6700\u5C0F\u503C\u70BA130\u3002",
  LAPSE_INTERVAL_CHANGE: "\u5C07\u5FA9\u7FD2\u6642\u6A19\u8A3B\u70BA\u300C\u8F03\u96E3\u300D\u7684\u5361\u7247\u6216\u7B46\u8A18\u5FA9\u7FD2\u9593\u9694\u7E2E\u77ED",
  LAPSE_INTERVAL_CHANGE_DESC: "\u65B0\u5FA9\u7FD2\u9593\u9694 = \u539F\u5FA9\u7FD2\u9593\u9694 * \u9593\u9694\u6539\u8B8A\u4FC2\u6578 / 100.",
  EASY_BONUS: "\u7C21\u55AE\u734E\u52F5",
  EASY_BONUS_DESC: "\u7C21\u55AE\u734E\u52F5\u8A2D\u5B9A\u300C\u8A18\u5F97\u300D\u548C\u300C\u7C21\u55AE\u300D\u5361\u7247\u6216\u7B46\u8A18\u7684\u5FA9\u7FD2\u9593\u9694\u5DEE\u8DDD\uFF08\u6700\u5C0F\u503C100%\uFF09\u3002",
  EASY_BONUS_MIN_WARNING: "\u7C21\u55AE\u734E\u52F5\u81F3\u5C11\u70BA100\u3002",
  LOAD_BALANCE: "Enable load balancer",
  LOAD_BALANCE_DESC: `Slightly tweaks the interval so that the number of reviews per day is more consistent.
        It's like Anki's fuzz but instead of being random, it picks the day with the least amount of reviews.
        It's turned off for small intervals.`,
  MAX_INTERVAL: "\u6700\u5927\u9593\u9694\uFF08\u5929\uFF09",
  MAX_INTERVAL_DESC: "\u8A2D\u5B9A\u5FA9\u7FD2\u7684\u6700\u5927\u9593\u9694\u6642\u9593\uFF08\u9810\u8A2D\u503C100\u5E74\uFF09\u3002",
  MAX_INTERVAL_MIN_WARNING: "\u6700\u5927\u9593\u9694\u81F3\u5C11\u70BA1\u5929",
  MAX_LINK_CONTRIB: "\u6700\u5927\u93C8\u63A5\u8CA2\u737B",
  MAX_LINK_CONTRIB_DESC: "\u93C8\u63A5\u7B46\u8A18\u7684\u52A0\u6B0A\u638C\u63E1\u7A0B\u5EA6\u5C0D\u539F\u59CB\u638C\u63E1\u7A0B\u5EA6\u7684\u6700\u5927\u8CA2\u737B\u3002",
  LOGGING: "\u8A18\u9304\u4E2D",
  DISPLAY_SCHEDULING_DEBUG_INFO: "\u5728\u958B\u767C\u8005\u63A7\u5236\u53F0\u4E2D\u986F\u793A\u9664\u932F\u8CC7\u8A0A",
  DISPLAY_PARSER_DEBUG_INFO: "Show the parser's debugging information on the developer console",
  SCHEDULING: "Scheduling",
  EXPERIMENTAL: "Experimental",
  HELP: "Help",
  STORE_IN_NOTES: "In the notes",
  // sidebar.ts
  NOTES_REVIEW_QUEUE: "\u7B46\u8A18\u5FA9\u7FD2\u5E8F\u5217",
  CLOSE: "\u81E8\u8FD1",
  NEW: "\u65B0",
  YESTERDAY: "\u6628\u5929",
  TODAY: "\u4ECA\u5929",
  TOMORROW: "\u660E\u5929",
  // stats-modal.tsx
  STATS_TITLE: "\u7D71\u8A08",
  MONTH: "\u6708",
  QUARTER: "\u5B63",
  YEAR: "\u5E74",
  LIFETIME: "\u5168\u90E8",
  FORECAST: "\u9810\u6E2C",
  FORECAST_DESC: "\u5C07\u8981\u5230\u671F\u7684\u5361\u7247\u6578\u91CF",
  SCHEDULED: "\u5DF2\u6392\u7A0B",
  DAYS: "\u5929",
  NUMBER_OF_CARDS: "\u5361\u7247\u6578\u91CF",
  REVIEWS_PER_DAY: "\u5E73\u5747: \u5FA9\u7FD2${avg} /\u5929",
  INTERVALS: "\u9593\u9694",
  INTERVALS_DESC: "\u5230\u4E0B\u4E00\u6B21\u5FA9\u7FD2\u7684\u6642\u9593\u9593\u9694",
  COUNT: "\u8A08\u6578",
  INTERVALS_SUMMARY: "\u5E73\u5747\u9593\u9694\u6642\u9593: ${avg}, \u6700\u9577\u9593\u9694\u6642\u9593: ${longest}",
  EASES: "\u638C\u63E1\u7A0B\u5EA6",
  EASES_SUMMARY: "\u5E73\u5747\u638C\u63E1\u7A0B\u5EA6: ${avgEase}",
  EASE: "Ease",
  CARD_TYPES: "\u5361\u7247\u578B\u5225",
  CARD_TYPES_DESC: "\u5982\u6709\uFF0C\u5C07\u986F\u793A\u96B1\u85CF\u7684\u5361\u7247",
  CARD_TYPE_NEW: "\u65B0",
  CARD_TYPE_YOUNG: "\u8F03\u65B0",
  CARD_TYPE_MATURE: "\u719F\u6089",
  CARD_TYPES_SUMMARY: "\u7E3D\u5361\u7247\u6578: ${totalCardsCount}",
  SEARCH: "Search",
  PREVIOUS: "Previous",
  NEXT: "Next"
};

// src/lang/helpers.ts
var localeMap = {
  af: af_default,
  ar: ar_default,
  bn: bn_default,
  cs: cz_default,
  da: da_default,
  de: de_default,
  en: en_default,
  "en-gb": en_gb_default,
  es: es_default,
  fr: fr_default,
  hi: hi_default,
  id: id_default,
  it: it_default,
  ja: ja_default,
  ko: ko_default,
  mr: mr_default,
  nl: nl_default,
  nn: no_default,
  pl: pl_default,
  pt: pt_default,
  "pt-br": pt_br_default,
  ro: ro_default,
  ru: ru_default,
  sw: sw_default,
  ta: ta_default,
  te: te_default,
  th: th_default,
  tr: tr_default,
  uk: uk_default,
  ur: ur_default,
  vi: vi_default,
  "zh-cn": zh_cn_default,
  "zh-tw": zh_tw_default
};
var locale = localeMap[import_obsidian.moment.locale()];
function interpolate(str, params) {
  const names2 = Object.keys(params);
  const vals = Object.values(params);
  return new Function(...names2, `return \`${str}\`;`)(...vals);
}
function t(str, params) {
  if (!locale) {
    console.error(`SRS error: Locale ${import_obsidian.moment.locale()} not found.`);
  }
  const result = locale && locale[str] || en_default[str];
  if (params) {
    return interpolate(result, params);
  }
  return result;
}

// src/algorithms/osr/note-scheduling.ts
function osrSchedule(response, originalInterval, ease, delayedBeforeReview, settings, dueDateHistogram) {
  const delayedBeforeReviewDays = Math.max(0, Math.floor(delayedBeforeReview / TICKS_PER_DAY));
  let interval = originalInterval;
  if (response === 0 /* Easy */) {
    ease += 20;
    interval = (interval + delayedBeforeReviewDays) * ease / 100;
    interval *= settings.easyBonus;
  } else if (response === 1 /* Good */) {
    interval = (interval + delayedBeforeReviewDays / 2) * ease / 100;
  } else if (response === 2 /* Hard */) {
    ease = Math.max(130, ease - 20);
    interval = Math.max(
      1,
      (interval + delayedBeforeReviewDays / 4) * settings.lapsesIntervalChange
    );
  }
  if (settings.loadBalance && dueDateHistogram !== void 0) {
    interval = Math.round(interval);
    if (interval > 7) {
      let fuzz;
      if (interval <= 21) fuzz = 1;
      else if (interval <= 180) fuzz = Math.min(3, Math.floor(interval * 0.05));
      else fuzz = Math.min(7, Math.floor(interval * 0.025));
      interval = dueDateHistogram.findLeastUsedIntervalOverRange(interval, fuzz);
    }
  }
  interval = Math.min(interval, settings.maximumInterval);
  interval = Math.round(interval * 10) / 10;
  return { interval, ease };
}
function textInterval(interval, isMobile) {
  if (interval === void 0) {
    return t("NEW");
  }
  const m2 = Math.round(interval / 3.04375) / 10, y2 = Math.round(interval / 36.525) / 10;
  if (isMobile) {
    if (m2 < 1) return t("DAYS_STR_IVL_MOBILE", { interval });
    else if (y2 < 1) return t("MONTHS_STR_IVL_MOBILE", { interval: m2 });
    else return t("YEARS_STR_IVL_MOBILE", { interval: y2 });
  } else {
    if (m2 < 1) return t("DAYS_STR_IVL", { interval });
    else if (y2 < 1) return t("MONTHS_STR_IVL", { interval: m2 });
    else return t("YEARS_STR_IVL", { interval: y2 });
  }
}

// src/utils/dates.ts
var import_moment = __toESM(require_moment());
function formatDateYYYYMMDD(ticks) {
  return ticks.format(PREFERRED_DATE_FORMAT);
}
var LiveDateProvider = class {
  get now() {
    return (0, import_moment.default)();
  }
  get today() {
    return (0, import_moment.default)().startOf("day");
  }
};
var DateUtil = class {
  static dateStrToMoment(str) {
    return (0, import_moment.default)(str, ALLOWED_DATE_FORMATS);
  }
};
var globalDateProvider = new LiveDateProvider();

// src/algorithms/base/rep-item-schedule-info.ts
var RepItemScheduleInfo = class {
  get dueDateAsUnix() {
    return this.dueDate.valueOf();
  }
  isDue() {
    return this.dueDate && this.dueDate.isSameOrBefore(globalDateProvider.today);
  }
  formatDueDate() {
    return formatDateYYYYMMDD(this.dueDate);
  }
  delayedBeforeReviewDaysInt() {
    return Math.max(0, Math.floor(this.delayedBeforeReviewTicks / TICKS_PER_DAY));
  }
};

// src/algorithms/osr/rep-item-schedule-info-osr.ts
var _RepItemScheduleInfoOsr = class _RepItemScheduleInfoOsr extends RepItemScheduleInfo {
  constructor(dueDate, interval, latestEase, delayedBeforeReviewTicks = null) {
    super();
    this.dueDate = dueDate;
    this.interval = Math.round(interval);
    this.latestEase = latestEase;
    this.delayedBeforeReviewTicks = delayedBeforeReviewTicks;
    if (dueDate && delayedBeforeReviewTicks == null) {
      this.delayedBeforeReviewTicks = globalDateProvider.today.valueOf() - dueDate.valueOf();
    }
  }
  formatCardScheduleForHtmlComment() {
    const dateStr = this.dueDate ? this.formatDueDate() : _RepItemScheduleInfoOsr.dummyDueDateForNewCard;
    return `!${dateStr},${this.interval},${this.latestEase}`;
  }
  static get initialInterval() {
    return 1;
  }
  static getDummyScheduleForNewCard(settings) {
    return _RepItemScheduleInfoOsr.fromDueDateStr(
      _RepItemScheduleInfoOsr.dummyDueDateForNewCard,
      _RepItemScheduleInfoOsr.initialInterval,
      settings.baseEase
    );
  }
  static fromDueDateStr(dueDateStr, interval, ease, delayedBeforeReviewTicks = null) {
    const dueDate = DateUtil.dateStrToMoment(dueDateStr);
    return new _RepItemScheduleInfoOsr(dueDate, interval, ease, delayedBeforeReviewTicks);
  }
};
// A question can have multiple cards. The schedule info for all sibling cards are formatted together
// in a single <!--SR: --> comment, such as:
// <!--SR:!2023-09-02,4,270!2023-09-02,5,270!2023-09-02,6,270!2023-09-02,7,270-->
//
// However, not all sibling cards may have been reviewed. Therefore we need a method of indicating that a particular card
// has not been reviewed, and should be considered "new"
// This is done by using this magic value for the date
_RepItemScheduleInfoOsr.dummyDueDateForNewCard = "2000-01-01";
var RepItemScheduleInfoOsr = _RepItemScheduleInfoOsr;

// src/note-ease-list.ts
var NoteEaseList = class {
  constructor(settings) {
    this.dict = {};
    this.settings = settings;
  }
  get baseEase() {
    return this.settings.baseEase;
  }
  hasEaseForPath(path3) {
    return Object.prototype.hasOwnProperty.call(this.dict, path3);
  }
  getEaseByPath(path3) {
    let ease = null;
    if (this.hasEaseForPath(path3)) {
      ease = Math.round(this.dict[path3]);
    }
    return ease;
  }
  setEaseForPath(path3, ease) {
    this.dict[path3] = ease;
  }
};

// src/algorithms/osr/srs-algorithm-osr.ts
var SrsAlgorithmOsr = class _SrsAlgorithmOsr {
  constructor(settings) {
    this.settings = settings;
    this.noteEaseList = new NoteEaseList(settings);
  }
  static get initialInterval() {
    return 1;
  }
  noteCalcNewSchedule(notePath, osrNoteGraph, response, dueDateNoteHistogram) {
    const noteLinkStat = osrNoteGraph.calcNoteLinkStat(
      notePath,
      this.noteEaseList
    );
    const linkContribution = this.settings.maxLinkFactor * Math.min(1, Math.log(noteLinkStat.totalLinkCount + 0.5) / Math.log(64));
    let ease = (1 - linkContribution) * this.settings.baseEase + (noteLinkStat.totalLinkCount > 0 ? linkContribution * noteLinkStat.linkTotal / noteLinkStat.linkPGTotal : linkContribution * this.settings.baseEase);
    if (this.noteEaseList.hasEaseForPath(notePath)) {
      ease = (ease + this.noteEaseList.getEaseByPath(notePath)) / 2;
    }
    const dueDate = null;
    const interval = _SrsAlgorithmOsr.initialInterval;
    ease = Math.round(ease);
    const temp = new RepItemScheduleInfoOsr(dueDate, interval, ease);
    const result = this.calcSchedule(
      temp,
      response,
      dueDateNoteHistogram
    );
    result.dueDate = (0, import_moment2.default)(globalDateProvider.today.add(result.interval, "d"));
    return result;
  }
  noteOnLoadedNote(path3, note, noteEase) {
    let flashcardsInNoteAvgEase = null;
    if (note) {
      flashcardsInNoteAvgEase = _SrsAlgorithmOsr.calculateFlashcardAvgEase(
        note.questionList,
        this.settings
      );
    }
    let ease = null;
    if (flashcardsInNoteAvgEase && noteEase) {
      ease = (flashcardsInNoteAvgEase + noteEase) / 2;
    } else {
      ease = flashcardsInNoteAvgEase ? flashcardsInNoteAvgEase : noteEase;
    }
    if (ease) {
      this.noteEaseList.setEaseForPath(path3, ease);
    }
  }
  static calculateFlashcardAvgEase(questionList, settings) {
    let totalEase = 0;
    let scheduledCount = 0;
    questionList.forEach((question) => {
      question.cards.filter((card) => card.hasSchedule).forEach((card) => {
        totalEase += card.scheduleInfo.latestEase;
        scheduledCount++;
      });
    });
    let result = 0;
    if (scheduledCount > 0) {
      const flashcardsInNoteAvgEase = totalEase / scheduledCount;
      const flashcardContribution = Math.min(
        1,
        Math.log(scheduledCount + 0.5) / Math.log(64)
      );
      result = flashcardsInNoteAvgEase * flashcardContribution + settings.baseEase * (1 - flashcardContribution);
    }
    return result;
  }
  noteCalcUpdatedSchedule(notePath, noteSchedule, response, dueDateNoteHistogram) {
    const noteScheduleOsr = noteSchedule;
    const temp = this.calcSchedule(
      noteScheduleOsr,
      response,
      dueDateNoteHistogram
    );
    const interval = temp.interval;
    const ease = temp.latestEase;
    const dueDate = (0, import_moment2.default)(globalDateProvider.today.add(interval, "d"));
    this.noteEaseList.setEaseForPath(notePath, ease);
    return new RepItemScheduleInfoOsr(dueDate, interval, ease);
  }
  calcSchedule(schedule, response, dueDateHistogram) {
    const temp = osrSchedule(
      response,
      schedule.interval,
      schedule.latestEase,
      schedule.delayedBeforeReviewTicks,
      this.settings,
      dueDateHistogram
    );
    return new RepItemScheduleInfoOsr(globalDateProvider.today, temp.interval, temp.ease);
  }
  cardGetResetSchedule() {
    const interval = _SrsAlgorithmOsr.initialInterval;
    const ease = this.settings.baseEase;
    const dueDate = globalDateProvider.today.add(interval, "d");
    return new RepItemScheduleInfoOsr(dueDate, interval, ease);
  }
  cardGetNewSchedule(response, notePath, dueDateFlashcardHistogram) {
    let initialEase = this.settings.baseEase;
    if (this.noteEaseList.hasEaseForPath(notePath)) {
      initialEase = Math.round(this.noteEaseList.getEaseByPath(notePath));
    }
    const delayBeforeReview = 0;
    const schedObj = osrSchedule(
      response,
      _SrsAlgorithmOsr.initialInterval,
      initialEase,
      delayBeforeReview,
      this.settings,
      dueDateFlashcardHistogram
    );
    const interval = schedObj.interval;
    const ease = schedObj.ease;
    const dueDate = globalDateProvider.today.add(interval, "d");
    return new RepItemScheduleInfoOsr(dueDate, interval, ease, delayBeforeReview);
  }
  cardCalcUpdatedSchedule(response, cardSchedule, dueDateFlashcardHistogram) {
    const cardScheduleOsr = cardSchedule;
    const schedObj = osrSchedule(
      response,
      cardScheduleOsr.interval,
      cardSchedule.latestEase,
      cardSchedule.delayedBeforeReviewTicks,
      this.settings,
      dueDateFlashcardHistogram
    );
    const interval = schedObj.interval;
    const ease = schedObj.ease;
    const dueDate = globalDateProvider.today.add(interval, "d");
    const delayBeforeReview = 0;
    return new RepItemScheduleInfoOsr(dueDate, interval, ease, delayBeforeReview);
  }
  noteStats() {
    return this.noteEaseList;
  }
};

// src/algorithms/osr/osr-note-graph.ts
var graph = __toESM(require_lib());

// node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/index.js
var import_brace_expansion = __toESM(require_brace_expansion(), 1);

// node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s2) => s2.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob, position) => {
  const pos = position;
  if (glob.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i2 = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE: while (i2 < glob.length) {
    const c2 = glob.charAt(i2);
    if ((c2 === "!" || c2 === "^") && i2 === pos + 1) {
      negate = true;
      i2++;
      continue;
    }
    if (c2 === "]" && sawStart && !escaping) {
      endPos = i2 + 1;
      break;
    }
    sawStart = true;
    if (c2 === "\\") {
      if (!escaping) {
        escaping = true;
        i2++;
        continue;
      }
    }
    if (c2 === "[" && !escaping) {
      for (const [cls, [unip, u2, neg]] of Object.entries(posixClasses)) {
        if (glob.startsWith(cls, i2)) {
          if (rangeStart) {
            return ["$.", false, glob.length - pos, true];
          }
          i2 += cls.length;
          if (neg)
            negs.push(unip);
          else
            ranges.push(unip);
          uflag = uflag || u2;
          continue WHILE;
        }
      }
    }
    escaping = false;
    if (rangeStart) {
      if (c2 > rangeStart) {
        ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c2));
      } else if (c2 === rangeStart) {
        ranges.push(braceEscape(c2));
      }
      rangeStart = "";
      i2++;
      continue;
    }
    if (glob.startsWith("-]", i2 + 1)) {
      ranges.push(braceEscape(c2 + "-"));
      i2 += 2;
      continue;
    }
    if (glob.startsWith("-", i2 + 1)) {
      rangeStart = c2;
      i2 += 2;
      continue;
    }
    ranges.push(braceEscape(c2));
    i2++;
  }
  if (endPos < i2) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r2 = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r2), false, endPos - pos, false];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/unescape.js
var unescape = (s2, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s2.replace(/\[([^\/\\])\]/g, "$1") : s2.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c2) => types.has(c2);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var _root, _hasMagic, _uflag, _parts, _parent, _parentIndex, _negs, _filledNegs, _options, _toString, _emptyExt, _AST_instances, fillNegs_fn, _AST_static, parseAST_fn, partsToRegExp_fn, parseGlob_fn;
var _AST = class _AST {
  constructor(type, parent, options = {}) {
    __privateAdd(this, _AST_instances);
    __publicField(this, "type");
    __privateAdd(this, _root);
    __privateAdd(this, _hasMagic);
    __privateAdd(this, _uflag, false);
    __privateAdd(this, _parts, []);
    __privateAdd(this, _parent);
    __privateAdd(this, _parentIndex);
    __privateAdd(this, _negs);
    __privateAdd(this, _filledNegs, false);
    __privateAdd(this, _options);
    __privateAdd(this, _toString);
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    __privateAdd(this, _emptyExt, false);
    this.type = type;
    if (type)
      __privateSet(this, _hasMagic, true);
    __privateSet(this, _parent, parent);
    __privateSet(this, _root, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _root) : this);
    __privateSet(this, _options, __privateGet(this, _root) === this ? options : __privateGet(__privateGet(this, _root), _options));
    __privateSet(this, _negs, __privateGet(this, _root) === this ? [] : __privateGet(__privateGet(this, _root), _negs));
    if (type === "!" && !__privateGet(__privateGet(this, _root), _filledNegs))
      __privateGet(this, _negs).push(this);
    __privateSet(this, _parentIndex, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0);
  }
  get hasMagic() {
    if (__privateGet(this, _hasMagic) !== void 0)
      return __privateGet(this, _hasMagic);
    for (const p2 of __privateGet(this, _parts)) {
      if (typeof p2 === "string")
        continue;
      if (p2.type || p2.hasMagic)
        return __privateSet(this, _hasMagic, true);
    }
    return __privateGet(this, _hasMagic);
  }
  // reconstructs the pattern
  toString() {
    if (__privateGet(this, _toString) !== void 0)
      return __privateGet(this, _toString);
    if (!this.type) {
      return __privateSet(this, _toString, __privateGet(this, _parts).map((p2) => String(p2)).join(""));
    } else {
      return __privateSet(this, _toString, this.type + "(" + __privateGet(this, _parts).map((p2) => String(p2)).join("|") + ")");
    }
  }
  push(...parts) {
    for (const p2 of parts) {
      if (p2 === "")
        continue;
      if (typeof p2 !== "string" && !(p2 instanceof _AST && __privateGet(p2, _parent) === this)) {
        throw new Error("invalid part: " + p2);
      }
      __privateGet(this, _parts).push(p2);
    }
  }
  toJSON() {
    var _a;
    const ret = this.type === null ? __privateGet(this, _parts).slice().map((p2) => typeof p2 === "string" ? p2 : p2.toJSON()) : [this.type, ...__privateGet(this, _parts).map((p2) => p2.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === __privateGet(this, _root) || __privateGet(__privateGet(this, _root), _filledNegs) && ((_a = __privateGet(this, _parent)) == null ? void 0 : _a.type) === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    var _a;
    if (__privateGet(this, _root) === this)
      return true;
    if (!((_a = __privateGet(this, _parent)) == null ? void 0 : _a.isStart()))
      return false;
    if (__privateGet(this, _parentIndex) === 0)
      return true;
    const p2 = __privateGet(this, _parent);
    for (let i2 = 0; i2 < __privateGet(this, _parentIndex); i2++) {
      const pp = __privateGet(p2, _parts)[i2];
      if (!(pp instanceof _AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    var _a, _b, _c;
    if (__privateGet(this, _root) === this)
      return true;
    if (((_a = __privateGet(this, _parent)) == null ? void 0 : _a.type) === "!")
      return true;
    if (!((_b = __privateGet(this, _parent)) == null ? void 0 : _b.isEnd()))
      return false;
    if (!this.type)
      return (_c = __privateGet(this, _parent)) == null ? void 0 : _c.isEnd();
    const pl = __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0;
    return __privateGet(this, _parentIndex) === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c2 = new _AST(this.type, parent);
    for (const p2 of __privateGet(this, _parts)) {
      c2.copyIn(p2);
    }
    return c2;
  }
  static fromGlob(pattern, options = {}) {
    var _a;
    const ast = new _AST(null, void 0, options);
    __privateMethod(_a = _AST, _AST_static, parseAST_fn).call(_a, pattern, ast, 0, options);
    return ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== __privateGet(this, _root))
      return __privateGet(this, _root).toMMPattern();
    const glob = this.toString();
    const [re, body, hasMagic, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic || __privateGet(this, _hasMagic) || __privateGet(this, _options).nocase && !__privateGet(this, _options).nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (__privateGet(this, _options).nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob
    });
  }
  get options() {
    return __privateGet(this, _options);
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    var _a;
    const dot = allowDot != null ? allowDot : !!__privateGet(this, _options).dot;
    if (__privateGet(this, _root) === this)
      __privateMethod(this, _AST_instances, fillNegs_fn).call(this);
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd();
      const src = __privateGet(this, _parts).map((p2) => {
        var _a2;
        const [re, _2, hasMagic, uflag] = typeof p2 === "string" ? __privateMethod(_a2 = _AST, _AST_static, parseGlob_fn).call(_a2, p2, __privateGet(this, _hasMagic), noEmpty) : p2.toRegExpSource(allowDot);
        __privateSet(this, _hasMagic, __privateGet(this, _hasMagic) || hasMagic);
        __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
        return re;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof __privateGet(this, _parts)[0] === "string") {
          const dotTravAllowed = __privateGet(this, _parts).length === 1 && justDots.has(__privateGet(this, _parts)[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = (
              // dots are allowed, and the pattern starts with [ or .
              dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
              src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
              src.startsWith("\\.\\.") && aps.has(src.charAt(4))
            );
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && __privateGet(__privateGet(this, _root), _filledNegs) && ((_a = __privateGet(this, _parent)) == null ? void 0 : _a.type) === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape(src),
        __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
        __privateGet(this, _uflag)
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = __privateMethod(this, _AST_instances, partsToRegExp_fn).call(this, dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s2 = this.toString();
      __privateSet(this, _parts, [s2]);
      this.type = null;
      __privateSet(this, _hasMagic, void 0);
      return [s2, unescape(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : __privateMethod(this, _AST_instances, partsToRegExp_fn).call(this, true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && __privateGet(this, _emptyExt)) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape(body),
      __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
      __privateGet(this, _uflag)
    ];
  }
};
_root = new WeakMap();
_hasMagic = new WeakMap();
_uflag = new WeakMap();
_parts = new WeakMap();
_parent = new WeakMap();
_parentIndex = new WeakMap();
_negs = new WeakMap();
_filledNegs = new WeakMap();
_options = new WeakMap();
_toString = new WeakMap();
_emptyExt = new WeakMap();
_AST_instances = new WeakSet();
fillNegs_fn = function() {
  if (this !== __privateGet(this, _root))
    throw new Error("should only call on root");
  if (__privateGet(this, _filledNegs))
    return this;
  this.toString();
  __privateSet(this, _filledNegs, true);
  let n2;
  while (n2 = __privateGet(this, _negs).pop()) {
    if (n2.type !== "!")
      continue;
    let p2 = n2;
    let pp = __privateGet(p2, _parent);
    while (pp) {
      for (let i2 = __privateGet(p2, _parentIndex) + 1; !pp.type && i2 < __privateGet(pp, _parts).length; i2++) {
        for (const part of __privateGet(n2, _parts)) {
          if (typeof part === "string") {
            throw new Error("string part in extglob AST??");
          }
          part.copyIn(__privateGet(pp, _parts)[i2]);
        }
      }
      p2 = pp;
      pp = __privateGet(p2, _parent);
    }
  }
  return this;
};
_AST_static = new WeakSet();
parseAST_fn = function(str, ast, pos, opt) {
  var _a, _b;
  let escaping = false;
  let inBrace = false;
  let braceStart = -1;
  let braceNeg = false;
  if (ast.type === null) {
    let i3 = pos;
    let acc2 = "";
    while (i3 < str.length) {
      const c2 = str.charAt(i3++);
      if (escaping || c2 === "\\") {
        escaping = !escaping;
        acc2 += c2;
        continue;
      }
      if (inBrace) {
        if (i3 === braceStart + 1) {
          if (c2 === "^" || c2 === "!") {
            braceNeg = true;
          }
        } else if (c2 === "]" && !(i3 === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc2 += c2;
        continue;
      } else if (c2 === "[") {
        inBrace = true;
        braceStart = i3;
        braceNeg = false;
        acc2 += c2;
        continue;
      }
      if (!opt.noext && isExtglobType(c2) && str.charAt(i3) === "(") {
        ast.push(acc2);
        acc2 = "";
        const ext2 = new _AST(c2, ast);
        i3 = __privateMethod(_a = _AST, _AST_static, parseAST_fn).call(_a, str, ext2, i3, opt);
        ast.push(ext2);
        continue;
      }
      acc2 += c2;
    }
    ast.push(acc2);
    return i3;
  }
  let i2 = pos + 1;
  let part = new _AST(null, ast);
  const parts = [];
  let acc = "";
  while (i2 < str.length) {
    const c2 = str.charAt(i2++);
    if (escaping || c2 === "\\") {
      escaping = !escaping;
      acc += c2;
      continue;
    }
    if (inBrace) {
      if (i2 === braceStart + 1) {
        if (c2 === "^" || c2 === "!") {
          braceNeg = true;
        }
      } else if (c2 === "]" && !(i2 === braceStart + 2 && braceNeg)) {
        inBrace = false;
      }
      acc += c2;
      continue;
    } else if (c2 === "[") {
      inBrace = true;
      braceStart = i2;
      braceNeg = false;
      acc += c2;
      continue;
    }
    if (isExtglobType(c2) && str.charAt(i2) === "(") {
      part.push(acc);
      acc = "";
      const ext2 = new _AST(c2, part);
      part.push(ext2);
      i2 = __privateMethod(_b = _AST, _AST_static, parseAST_fn).call(_b, str, ext2, i2, opt);
      continue;
    }
    if (c2 === "|") {
      part.push(acc);
      acc = "";
      parts.push(part);
      part = new _AST(null, ast);
      continue;
    }
    if (c2 === ")") {
      if (acc === "" && __privateGet(ast, _parts).length === 0) {
        __privateSet(ast, _emptyExt, true);
      }
      part.push(acc);
      acc = "";
      ast.push(...parts, part);
      return i2;
    }
    acc += c2;
  }
  ast.type = null;
  __privateSet(ast, _hasMagic, void 0);
  __privateSet(ast, _parts, [str.substring(pos - 1)]);
  return i2;
};
partsToRegExp_fn = function(dot) {
  return __privateGet(this, _parts).map((p2) => {
    if (typeof p2 === "string") {
      throw new Error("string type in extglob ast??");
    }
    const [re, _2, _hasMagic2, uflag] = p2.toRegExpSource(dot);
    __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
    return re;
  }).filter((p2) => !(this.isStart() && this.isEnd()) || !!p2).join("|");
};
parseGlob_fn = function(glob, hasMagic, noEmpty = false) {
  let escaping = false;
  let re = "";
  let uflag = false;
  for (let i2 = 0; i2 < glob.length; i2++) {
    const c2 = glob.charAt(i2);
    if (escaping) {
      escaping = false;
      re += (reSpecials.has(c2) ? "\\" : "") + c2;
      continue;
    }
    if (c2 === "\\") {
      if (i2 === glob.length - 1) {
        re += "\\\\";
      } else {
        escaping = true;
      }
      continue;
    }
    if (c2 === "[") {
      const [src, needUflag, consumed, magic] = parseClass(glob, i2);
      if (consumed) {
        re += src;
        uflag = uflag || needUflag;
        i2 += consumed - 1;
        hasMagic = hasMagic || magic;
        continue;
      }
    }
    if (c2 === "*") {
      if (noEmpty && glob === "*")
        re += starNoEmpty;
      else
        re += star;
      hasMagic = true;
      continue;
    }
    if (c2 === "?") {
      re += qmark;
      hasMagic = true;
      continue;
    }
    re += regExpEscape(c2);
  }
  return [re, unescape(glob), !!hasMagic, uflag];
};
__privateAdd(_AST, _AST_static);
var AST = _AST;

// node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/escape.js
var escape = (s2, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s2.replace(/[?*()[\]]/g, "[$&]") : s2.replace(/[?*()[\]\\]/g, "\\$&");
};

// node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/index.js
var minimatch = (p2, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p2);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f2) => !f2.startsWith(".") && f2.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f2) => f2.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f2) => !f2.startsWith(".") && f2.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f2) => f2.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f2) => !f2.startsWith(".") && f2.includes(".");
var starDotStarTestDot = (f2) => f2 !== "." && f2 !== ".." && f2.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f2) => f2 !== "." && f2 !== ".." && f2.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f2) => f2.length !== 0 && !f2.startsWith(".");
var starTestDot = (f2) => f2.length !== 0 && f2 !== "." && f2 !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f2) => noext(f2) && f2.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f2) => noext(f2) && f2.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f2) => noext(f2) && f2.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f2) => noext(f2) && f2.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f2) => f2.length === len && !f2.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f2) => f2.length === len && f2 !== "." && f2 !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter = (pattern, options = {}) => (p2) => minimatch(p2, pattern, options);
minimatch.filter = filter;
var ext = (a2, b2 = {}) => Object.assign({}, a2, b2);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m2 = (p2, pattern, options = {}) => orig(p2, pattern, ext(def, options));
  return Object.assign(m2, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      /* c8 ignore start */
      constructor(type, parent, options = {}) {
        super(type, parent, ext(def, options));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s2, options = {}) => orig.unescape(s2, ext(def, options)),
    escape: (s2, options = {}) => orig.escape(s2, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return (0, import_brace_expansion.default)(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match = (list, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list = list.filter((f2) => mm.match(f2));
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  constructor(pattern, options = {}) {
    __publicField(this, "options");
    __publicField(this, "set");
    __publicField(this, "pattern");
    __publicField(this, "windowsPathsNoEscape");
    __publicField(this, "nonegate");
    __publicField(this, "negate");
    __publicField(this, "comment");
    __publicField(this, "empty");
    __publicField(this, "preserveMultipleSlashes");
    __publicField(this, "partial");
    __publicField(this, "globSet");
    __publicField(this, "globParts");
    __publicField(this, "nocase");
    __publicField(this, "isWindows");
    __publicField(this, "platform");
    __publicField(this, "windowsNoMagicRoot");
    __publicField(this, "regexp");
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._2) {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s2) => this.slashSplit(s2));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set2 = this.globParts.map((s2, _2, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s2[0] === "" && s2[1] === "" && (s2[2] === "?" || !globMagic.test(s2[2])) && !globMagic.test(s2[3]);
        const isDrive = /^[a-z]:/i.test(s2[0]);
        if (isUNC) {
          return [...s2.slice(0, 4), ...s2.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s2[0], ...s2.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s2.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set2);
    this.set = set2.filter((s2) => s2.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i2 = 0; i2 < this.set.length; i2++) {
        const p2 = this.set[i2];
        if (p2[0] === "" && p2[1] === "" && this.globParts[i2][2] === "?" && typeof p2[3] === "string" && /^[a-z]:$/i.test(p2[3])) {
          p2[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i2 = 0; i2 < globParts.length; i2++) {
        for (let j2 = 0; j2 < globParts[i2].length; j2++) {
          if (globParts[i2][j2] === "**") {
            globParts[i2][j2] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
        let i2 = gs;
        while (parts[i2 + 1] === "**") {
          i2++;
        }
        if (i2 !== gs) {
          parts.splice(gs, i2 - gs);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set2, part) => {
        const prev = set2[set2.length - 1];
        if (part === "**" && prev === "**") {
          return set2;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set2.pop();
            return set2;
          }
        }
        set2.push(part);
        return set2;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i2 = 1; i2 < parts.length - 1; i2++) {
          const p2 = parts[i2];
          if (i2 === 1 && p2 === "" && parts[0] === "")
            continue;
          if (p2 === "." || p2 === "") {
            didSomething = true;
            parts.splice(i2, 1);
            i2--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
        const p2 = parts[dd - 1];
        if (p2 && p2 !== "." && p2 !== ".." && p2 !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next = parts[gs + 1];
          const p2 = parts[gs + 2];
          const p22 = parts[gs + 3];
          if (next !== "..")
            continue;
          if (!p2 || p2 === "." || p2 === ".." || !p22 || p22 === "." || p22 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i2 = 1; i2 < parts.length - 1; i2++) {
            const p2 = parts[i2];
            if (i2 === 1 && p2 === "" && parts[0] === "")
              continue;
            if (p2 === "." || p2 === "") {
              didSomething = true;
              parts.splice(i2, 1);
              i2--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p2 = parts[dd - 1];
          if (p2 && p2 !== "." && p2 !== ".." && p2 !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i2 = 0; i2 < globParts.length - 1; i2++) {
      for (let j2 = i2 + 1; j2 < globParts.length; j2++) {
        const matched = this.partsMatch(globParts[i2], globParts[j2], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i2] = [];
          globParts[j2] = matched;
          break;
        }
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a2, b2, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which = "";
    while (ai < a2.length && bi < b2.length) {
      if (a2[ai] === b2[bi]) {
        result.push(which === "b" ? b2[bi] : a2[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a2[ai] === "**" && b2[bi] === a2[ai + 1]) {
        result.push(a2[ai]);
        ai++;
      } else if (emptyGSMatch && b2[bi] === "**" && a2[ai] === b2[bi + 1]) {
        result.push(b2[bi]);
        bi++;
      } else if (a2[ai] === "*" && b2[bi] && (this.options.dot || !b2[bi].startsWith(".")) && b2[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a2[ai]);
        ai++;
        bi++;
      } else if (b2[bi] === "*" && a2[ai] && (this.options.dot || !a2[ai].startsWith(".")) && a2[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b2[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a2.length === b2.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i2 = 0; i2 < pattern.length && pattern.charAt(i2) === "!"; i2++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p2 = pattern[pi];
      var f2 = file[fi];
      this.debug(pattern, p2, f2);
      if (p2 === false) {
        return false;
      }
      if (p2 === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p2, f2]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p2 === "string") {
        hit = f2 === p2;
        this.debug("string match", p2, f2, hit);
      } else {
        hit = p2.test(f2);
        this.debug("pattern match", p2, f2, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m2;
    let fastTest = null;
    if (m2 = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m2 = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m2[1]);
    } else if (m2 = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m2);
    } else if (m2 = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m2 = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    if (fastTest && typeof re === "object") {
      Reflect.defineProperty(re, "test", { value: fastTest });
    }
    return re;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set2 = this.set;
    if (!set2.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options.nocase ? ["i"] : []);
    let re = set2.map((pattern) => {
      const pp = pattern.map((p2) => {
        if (p2 instanceof RegExp) {
          for (const f2 of p2.flags.split(""))
            flags.add(f2);
        }
        return typeof p2 === "string" ? regExpEscape2(p2) : p2 === GLOBSTAR ? GLOBSTAR : p2._src;
      });
      pp.forEach((p2, i2) => {
        const next = pp[i2 + 1];
        const prev = pp[i2 - 1];
        if (p2 !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next !== void 0 && next !== GLOBSTAR) {
            pp[i2 + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
          } else {
            pp[i2] = twoStar;
          }
        } else if (next === void 0) {
          pp[i2 - 1] = prev + "(?:\\/|" + twoStar + ")?";
        } else if (next !== GLOBSTAR) {
          pp[i2 - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
          pp[i2 + 1] = GLOBSTAR;
        }
      });
      return pp.filter((p2) => p2 !== GLOBSTAR).join("/");
    }).join("|");
    const [open, close] = set2.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open + re + close + "$";
    if (this.negate)
      re = "^(?!" + re + ").+$";
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p2) {
    if (this.preserveMultipleSlashes) {
      return p2.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p2)) {
      return ["", ...p2.split(/\/+/)];
    } else {
      return p2.split(/\/+/);
    }
  }
  match(f2, partial = this.partial) {
    this.debug("match", f2, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f2 === "";
    }
    if (f2 === "/" && partial) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f2 = f2.split("\\").join("/");
    }
    const ff = this.slashSplit(f2);
    this.debug(this.pattern, "split", ff);
    const set2 = this.set;
    this.debug(this.pattern, "set", set2);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i2 = ff.length - 2; !filename && i2 >= 0; i2--) {
        filename = ff[i2];
      }
    }
    for (let i2 = 0; i2 < set2.length; i2++) {
      const pattern = set2[i2];
      let file = ff;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

// src/utils/fs.ts
function isSupportedFileType(path3) {
  return path3.split(".").pop().toLowerCase() === "md";
}
function pathMatchesPattern(path3, pattern) {
  return path3.startsWith(pattern) || minimatch(path3, pattern);
}

// src/algorithms/osr/osr-note-graph.ts
var OsrNoteGraph = class {
  constructor(vaultNoteLinkInfoFinder) {
    // Key: targetFilename
    // Value: Map<sourceFilename, linkCount>
    // This is the number of links from sourceFilename to targetFilename
    // For simplicity, we just store the filename without the directory or filename extension
    this.incomingLinks = {};
    this.pageranks = {};
    this.vaultNoteLinkInfoFinder = vaultNoteLinkInfoFinder;
    this.reset();
  }
  reset() {
    this.incomingLinks = {};
    this.pageranks = {};
    graph.reset();
  }
  processLinks(path3) {
    if (this.incomingLinks[path3] === void 0) {
      this.incomingLinks[path3] = [];
    }
    const targetLinks = this.vaultNoteLinkInfoFinder.getResolvedTargetLinksForNotePath(path3) || {};
    for (const targetPath in targetLinks) {
      if (this.incomingLinks[targetPath] === void 0) this.incomingLinks[targetPath] = [];
      if (isSupportedFileType(targetPath)) {
        const linkCount = targetLinks[targetPath];
        this.incomingLinks[targetPath].push({
          sourcePath: path3,
          linkCount
        });
        graph.link(path3, targetPath, linkCount);
      }
    }
  }
  calcNoteLinkStat(notePath, noteEaseList) {
    let linkTotal = 0, linkPGTotal = 0, totalLinkCount = 0;
    for (const statObj of this.incomingLinks[notePath] || []) {
      const ease = noteEaseList.getEaseByPath(statObj.sourcePath);
      if (ease) {
        linkTotal += statObj.linkCount * this.pageranks[statObj.sourcePath] * ease;
        linkPGTotal += this.pageranks[statObj.sourcePath] * statObj.linkCount;
        totalLinkCount += statObj.linkCount;
      }
    }
    const outgoingLinks = this.vaultNoteLinkInfoFinder.getResolvedTargetLinksForNotePath(notePath) || {};
    for (const outgoingLink in outgoingLinks) {
      const ease = noteEaseList.getEaseByPath(outgoingLink);
      const linkCount = outgoingLinks[outgoingLink];
      const pageRank = this.pageranks[outgoingLink];
      if (ease) {
        linkTotal += linkCount * pageRank * ease;
        linkPGTotal += pageRank * linkCount;
        totalLinkCount += linkCount;
      }
    }
    return { linkTotal, linkPGTotal, totalLinkCount };
  }
  generatePageRanks() {
    graph.rank(0.85, 1e-6, (node, rank2) => {
      this.pageranks[node] = rank2 * 1e4;
    });
  }
};

// src/data-store-algorithm/data-store-algorithm.ts
var DataStoreAlgorithm = class _DataStoreAlgorithm {
  static getInstance() {
    if (!_DataStoreAlgorithm.instance) {
      throw new Error("there is no DataStoreAlgorithm instance.");
    }
    return _DataStoreAlgorithm.instance;
  }
};

// src/data-stores/base/data-store.ts
var DataStore = class _DataStore {
  static getInstance() {
    if (!_DataStore.instance) {
      throw new Error("there is no DataStore instance.");
    }
    return _DataStore.instance;
  }
};

// src/topic-path.ts
var TopicPath = class _TopicPath {
  constructor(path3) {
    if (path3 == null) throw "null path";
    if (path3.some((str) => str.includes("/"))) throw "path entries must not contain '/'";
    this.path = path3;
  }
  get hasPath() {
    return this.path.length > 0;
  }
  get isEmptyPath() {
    return !this.hasPath;
  }
  static get emptyPath() {
    return new _TopicPath([]);
  }
  shift() {
    if (this.isEmptyPath) throw "can't shift an empty path";
    return this.path.shift();
  }
  clone() {
    return new _TopicPath([...this.path]);
  }
  formatAsTag() {
    if (this.isEmptyPath) throw "Empty path";
    const result = "#" + this.path.join("/");
    return result;
  }
  static getTopicPathOfFile(noteFile, settings) {
    let deckPath = [];
    let result = _TopicPath.emptyPath;
    if (settings.convertFoldersToDecks) {
      deckPath = noteFile.path.split("/");
      deckPath.pop();
      if (deckPath.length != 0) {
        result = new _TopicPath(deckPath);
      }
    } else {
      const tagList = this.getTopicPathsFromTagList(
        noteFile.getAllTagsFromCache()
      );
      outer: for (const tagToReview of this.getTopicPathsFromTagList(
        settings.flashcardTags
      )) {
        for (const tag of tagList) {
          if (tagToReview.isSameOrAncestorOf(tag)) {
            result = tag;
            break outer;
          }
        }
      }
    }
    return result;
  }
  isSameOrAncestorOf(topicPath) {
    if (this.isEmptyPath) return topicPath.isEmptyPath;
    if (this.path.length > topicPath.path.length) return false;
    for (let i2 = 0; i2 < this.path.length; i2++) {
      if (this.path[i2] != topicPath.path[i2]) return false;
    }
    return true;
  }
  static getTopicPathFromCardText(cardText) {
    var _a;
    const path3 = (_a = cardText.trimStart().match(OBSIDIAN_TAG_AT_STARTOFLINE_REGEX)) == null ? void 0 : _a.slice(-1)[0];
    return (path3 == null ? void 0 : path3.length) > 0 ? _TopicPath.getTopicPathFromTag(path3) : null;
  }
  static getTopicPathsFromTagList(tagList) {
    const result = [];
    for (const tag of tagList) {
      if (this.isValidTag(tag)) result.push(_TopicPath.getTopicPathFromTag(tag));
    }
    return result;
  }
  static isValidTag(tag) {
    if (tag == null || tag.length == 0) return false;
    if (tag[0] != "#") return false;
    if (tag.length == 1) return false;
    return true;
  }
  static getTopicPathFromTag(tag) {
    if (tag == null || tag.length == 0) throw "Null/empty tag";
    if (tag[0] != "#") throw "Tag must start with #";
    if (tag.length == 1) throw "Invalid tag";
    const path3 = tag.replace("#", "").split("/").filter((str) => str);
    return new _TopicPath(path3);
  }
  static getFolderPathFromFilename(noteFile, settings) {
    let result = _TopicPath.emptyPath;
    if (settings.convertFoldersToDecks) {
      const deckPath = noteFile.path.split("/");
      deckPath.pop();
      if (deckPath.length != 0) {
        result = new _TopicPath(deckPath);
      }
    }
    return result;
  }
};
var TopicPathList = class _TopicPathList {
  constructor(list, lineNum = null) {
    if (list == null) throw "TopicPathList null";
    this.list = list;
    this.lineNum = lineNum;
  }
  get length() {
    return this.list.length;
  }
  isAnyElementSameOrAncestorOf(topicPath) {
    return this.list.some((item) => item.isSameOrAncestorOf(topicPath));
  }
  formatPsv() {
    return this.format("|");
  }
  format(sep2) {
    return this.list.map((topicPath) => topicPath.formatAsTag()).join(sep2);
  }
  static empty() {
    return new _TopicPathList([]);
  }
  static fromPsv(str, lineNum) {
    const result = _TopicPathList.convertTagListToTopicPathList(str.split("|"));
    result.lineNum = lineNum;
    return result;
  }
  //
  // tagList is a list of tags such as:
  //      ["#flashcards/computing", "#boring-stuff", "#news-worthy"]
  // validTopicPathList is a list of valid tags, such as those from settings.flashcardTags,E.g.
  //      ["#flashcards"]
  //
  // This returns a filtered version of tagList, containing only topic paths that are considered valid.
  // Validity is defined as "isAnyElementSameOrAncestorOf", and "#flashcards" is considered the ancestor of
  // "#flashcards/computing".
  //
  // Therefore this would return:
  //      "#flashcards/computing" (but not "#boring-stuff" or "#news-worthy")
  //
  static filterValidTopicPathsFromTagList(list, validTopicPathList, lineNum = null) {
    const result = [];
    for (const tag of list.list) {
      if (validTopicPathList.isAnyElementSameOrAncestorOf(tag)) result.push(tag);
    }
    return new _TopicPathList(result, lineNum);
  }
  static convertTagListToTopicPathList(tagList) {
    const result = [];
    for (const tag of tagList) {
      if (TopicPath.isValidTag(tag)) result.push(TopicPath.getTopicPathFromTag(tag));
    }
    return new _TopicPathList(result);
  }
};
var TopicPathWithWs = class {
  constructor(topicPath, preWhitespace, postWhitespace) {
    if (!topicPath || topicPath.isEmptyPath) throw "topicPath null";
    this.topicPath = topicPath;
    this.preWhitespace = preWhitespace;
    this.postWhitespace = postWhitespace;
  }
  formatWithWs() {
    return `${this.preWhitespace}${this.topicPath.formatAsTag()}${this.postWhitespace}`;
  }
};

// src/flashcard-review-sequencer.ts
var DeckStats = class {
  constructor(totalCount, dueCount, newCount, cardsInQueueCount, dueCardsInQueueOfThisDeckCount, newCardsInQueueOfThisDeckCount, cardsInQueueOfThisDeckCount, subDecksInQueueOfThisDeckCount, decksInQueueOfThisDeckCount) {
    this.dueCount = dueCount;
    this.newCount = newCount;
    this.totalCount = totalCount;
    this.cardsInQueueCount = cardsInQueueCount;
    this.dueCardsInQueueOfThisDeckCount = dueCardsInQueueOfThisDeckCount;
    this.newCardsInQueueOfThisDeckCount = newCardsInQueueOfThisDeckCount;
    this.cardsInQueueOfThisDeckCount = cardsInQueueOfThisDeckCount;
    this.subDecksInQueueOfThisDeckCount = subDecksInQueueOfThisDeckCount;
    this.decksInQueueOfThisDeckCount = decksInQueueOfThisDeckCount;
  }
};
var FlashcardReviewSequencer = class {
  constructor(reviewMode, cardSequencer, settings, srsAlgorithm, questionPostponementList, dueDateFlashcardHistogram) {
    this.reviewMode = reviewMode;
    this.cardSequencer = cardSequencer;
    this.settings = settings;
    this.srsAlgorithm = srsAlgorithm;
    this.questionPostponementList = questionPostponementList;
    this.dueDateFlashcardHistogram = dueDateFlashcardHistogram;
  }
  get hasCurrentCard() {
    return this.cardSequencer.currentCard != null;
  }
  get currentCard() {
    return this.cardSequencer.currentCard;
  }
  get currentQuestion() {
    var _a;
    return (_a = this.currentCard) == null ? void 0 : _a.question;
  }
  get currentDeck() {
    return this.cardSequencer.currentDeck;
  }
  get currentNote() {
    return this.currentQuestion.note;
  }
  // originalDeckTree isn't modified by the review process
  // Only remainingDeckTree
  setDeckTree(originalDeckTree, remainingDeckTree) {
    this.cardSequencer.setBaseDeck(remainingDeckTree);
    this._originalDeckTree = originalDeckTree;
    this.remainingDeckTree = remainingDeckTree;
    this.setCurrentDeck(TopicPath.emptyPath);
  }
  setCurrentDeck(topicPath) {
    this.cardSequencer.setIteratorTopicPath(topicPath);
    this.cardSequencer.nextCard();
  }
  get originalDeckTree() {
    return this._originalDeckTree;
  }
  getDeckStats(topicPath) {
    const totalCount = this._originalDeckTree.getDeck(topicPath).getDistinctCardCount(2 /* All */, true);
    const remainingDeck = this.remainingDeckTree.getDeck(topicPath);
    const newCount = remainingDeck.getDistinctCardCount(0 /* NewCard */, true);
    const dueCount = remainingDeck.getDistinctCardCount(1 /* DueCard */, true);
    const newCardsInQueueOfThisDeckCount = remainingDeck.getDistinctCardCount(
      0 /* NewCard */,
      false
    );
    const dueCardsInQueueOfThisDeckCount = remainingDeck.getDistinctCardCount(
      1 /* DueCard */,
      false
    );
    const cardsInQueueOfThisDeckCount = newCardsInQueueOfThisDeckCount + dueCardsInQueueOfThisDeckCount;
    const subDecksInQueueOfThisDeckCount = this.getSubDecksWithCardsInQueue(remainingDeck).length;
    const decksInQueueOfThisDeckCount = cardsInQueueOfThisDeckCount > 0 ? subDecksInQueueOfThisDeckCount + 1 : subDecksInQueueOfThisDeckCount;
    return new DeckStats(
      totalCount,
      dueCount,
      newCount,
      dueCount + newCount,
      dueCardsInQueueOfThisDeckCount,
      newCardsInQueueOfThisDeckCount,
      cardsInQueueOfThisDeckCount,
      subDecksInQueueOfThisDeckCount,
      decksInQueueOfThisDeckCount
    );
  }
  getSubDecksWithCardsInQueue(deck) {
    let subDecksWithCardsInQueue = [];
    deck.subdecks.forEach((subDeck) => {
      subDecksWithCardsInQueue = subDecksWithCardsInQueue.concat(
        this.getSubDecksWithCardsInQueue(subDeck)
      );
      const newCount = subDeck.getDistinctCardCount(0 /* NewCard */, false);
      const dueCount = subDeck.getDistinctCardCount(1 /* DueCard */, false);
      if (newCount + dueCount > 0) subDecksWithCardsInQueue.push(subDeck);
    });
    return subDecksWithCardsInQueue;
  }
  skipCurrentCard() {
    this.cardSequencer.deleteCurrentQuestionFromAllDecks();
  }
  deleteCurrentCard() {
    this.cardSequencer.deleteCurrentCardFromAllDecks();
  }
  async processReview(response) {
    switch (this.reviewMode) {
      case 1 /* Review */:
        await this.processReviewReviewMode(response);
        break;
      case 0 /* Cram */:
        await this.processReviewCramMode(response);
        break;
    }
  }
  async processReviewReviewMode(response) {
    if (response != 3 /* Reset */ || this.currentCard.hasSchedule) {
      const oldSchedule = this.currentCard.scheduleInfo;
      this.currentCard.scheduleInfo = this.determineCardSchedule(response, this.currentCard);
      await DataStore.getInstance().questionWriteSchedule(this.currentQuestion);
      if (oldSchedule) {
        const today = globalDateProvider.today.valueOf();
        const nDays = Math.ceil(
          (oldSchedule.dueDateAsUnix - today) / TICKS_PER_DAY
        );
        this.dueDateFlashcardHistogram.decrement(nDays);
      }
      this.dueDateFlashcardHistogram.increment(this.currentCard.scheduleInfo.interval);
    }
    if (response == 3 /* Reset */) {
      this.cardSequencer.moveCurrentCardToEndOfList();
      this.cardSequencer.nextCard();
    } else {
      if (this.settings.burySiblingCards) {
        await this.burySiblingCards();
        this.cardSequencer.deleteCurrentQuestionFromAllDecks();
      } else {
        this.deleteCurrentCard();
      }
    }
  }
  async burySiblingCards() {
    const remaining = this.currentDeck.getQuestionCardCount(this.currentQuestion);
    if (remaining > 1) {
      this.questionPostponementList.add(this.currentQuestion);
      await this.questionPostponementList.write();
    }
  }
  async processReviewCramMode(response) {
    if (response == 0 /* Easy */) this.deleteCurrentCard();
    else {
      this.cardSequencer.moveCurrentCardToEndOfList();
      this.cardSequencer.nextCard();
    }
  }
  determineCardSchedule(response, card) {
    let result;
    if (response == 3 /* Reset */) {
      result = this.srsAlgorithm.cardGetResetSchedule();
    } else {
      if (card.hasSchedule) {
        result = this.srsAlgorithm.cardCalcUpdatedSchedule(
          response,
          card.scheduleInfo,
          this.dueDateFlashcardHistogram
        );
      } else {
        const currentNote = card.question.note;
        result = this.srsAlgorithm.cardGetNewSchedule(
          response,
          currentNote.filePath,
          this.dueDateFlashcardHistogram
        );
      }
    }
    return result;
  }
  async updateCurrentQuestionText(text) {
    const q2 = this.currentQuestion.questionText;
    q2.actualQuestion = text;
    await DataStore.getInstance().questionWrite(this.currentQuestion);
  }
};

// src/deck.ts
var Deck2 = class _Deck {
  constructor(deckName, parent) {
    this.deckName = deckName;
    this.newFlashcards = [];
    this.dueFlashcards = [];
    this.subdecks = [];
    this.parent = parent;
  }
  getCardCount(cardListType, includeSubdeckCounts) {
    let result = 0;
    if (cardListType == 0 /* NewCard */ || cardListType == 2 /* All */)
      result += this.newFlashcards.length;
    if (cardListType == 1 /* DueCard */ || cardListType == 2 /* All */)
      result += this.dueFlashcards.length;
    if (includeSubdeckCounts) {
      for (const deck of this.subdecks) {
        result += deck.getCardCount(cardListType, includeSubdeckCounts);
      }
    }
    return result;
  }
  getDistinctCardCount(cardListType, includeSubdeckCounts) {
    const cardList = this.getFlattenedCardArray(cardListType, includeSubdeckCounts);
    const distinctCardSet = new Set(cardList);
    return distinctCardSet.size;
  }
  getFlattenedCardArray(cardListType, includeSubdeckCounts) {
    let result = [];
    switch (cardListType) {
      case 0 /* NewCard */:
        result = this.newFlashcards;
        break;
      case 1 /* DueCard */:
        result = this.dueFlashcards;
        break;
      case 2 /* All */:
        result = this.newFlashcards.concat(this.dueFlashcards);
    }
    if (includeSubdeckCounts) {
      for (const subdeck of this.subdecks) {
        result = result.concat(
          subdeck.getFlattenedCardArray(cardListType, includeSubdeckCounts)
        );
      }
    }
    return result;
  }
  // Returns a count of the number of this question's cards are present in this deck.
  // (The returned value would be <= question.cards.length)
  getQuestionCardCount(question) {
    let result = 0;
    result += this.getQuestionCardCountForCardListType(question, this.newFlashcards);
    result += this.getQuestionCardCountForCardListType(question, this.dueFlashcards);
    return result;
  }
  getQuestionCardCountForCardListType(question, cards) {
    let result = 0;
    for (let i2 = 0; i2 < cards.length; i2++) {
      if (Object.is(question, cards[i2].question)) result++;
    }
    return result;
  }
  static get emptyDeck() {
    return new _Deck("Root", null);
  }
  get isRootDeck() {
    return this.parent == null;
  }
  getDeckByTopicTag(tag) {
    return this.getDeck(TopicPath.getTopicPathFromTag(tag));
  }
  getDeck(topicPath) {
    return this._getOrCreateDeck(topicPath, false);
  }
  getOrCreateDeck(topicPath) {
    return this._getOrCreateDeck(topicPath, true);
  }
  _getOrCreateDeck(topicPath, createAllowed) {
    if (!topicPath.hasPath) {
      return this;
    }
    const t3 = topicPath.clone();
    const deckName = t3.shift();
    for (const subdeck of this.subdecks) {
      if (deckName === subdeck.deckName) {
        return subdeck._getOrCreateDeck(t3, createAllowed);
      }
    }
    let result = null;
    if (createAllowed) {
      const subdeck = new _Deck(
        deckName,
        this
        /* parent */
      );
      this.subdecks.push(subdeck);
      result = subdeck._getOrCreateDeck(t3, createAllowed);
    }
    return result;
  }
  getTopicPath() {
    const list = [];
    let deck = this;
    while (!deck.isRootDeck) {
      list.push(deck.deckName);
      deck = deck.parent;
    }
    return new TopicPath(list.reverse());
  }
  getRootDeck() {
    let deck = this;
    while (!deck.isRootDeck) {
      deck = deck.parent;
    }
    return deck;
  }
  getCard(index, cardListType) {
    const cardList = this.getCardListForCardType(cardListType);
    return cardList[index];
  }
  getCardListForCardType(cardListType) {
    return cardListType == 1 /* DueCard */ ? this.dueFlashcards : this.newFlashcards;
  }
  appendCard(topicPathList, cardObj) {
    if (topicPathList.list.length == 0) {
      this.appendCardToRootDeck(cardObj);
    } else {
      for (const topicPath of topicPathList.list) {
        this.appendCardSingleTopic(topicPath, cardObj);
      }
    }
  }
  appendCardToRootDeck(cardObj) {
    this.appendCardSingleTopic(TopicPath.emptyPath, cardObj);
  }
  appendCardSingleTopic(topicPath, cardObj) {
    const deck = this.getOrCreateDeck(topicPath);
    const cardList = deck.getCardListForCardType(cardObj.cardListType);
    cardList.push(cardObj);
  }
  // The question lists all the topics in which this card is included.
  // The topics are relative to the base deck, and this method must be called on that deck
  deleteQuestionFromAllDecks(question, exceptionIfMissing) {
    for (const card of question.cards) {
      this.deleteCardFromAllDecks(card, exceptionIfMissing);
    }
  }
  deleteQuestion(question, exceptionIfMissing) {
    for (const card of question.cards) {
      this.deleteCardFromThisDeck(card, exceptionIfMissing);
    }
  }
  // The card's question lists all the topics in which this card is included.
  // The topics are relative to the base deck, and this method must be called on that deck
  deleteCardFromAllDecks(card, exceptionIfMissing) {
    for (const topicPath of card.question.topicPathList.list) {
      const deck = this.getDeck(topicPath);
      deck.deleteCardFromThisDeck(card, exceptionIfMissing);
    }
  }
  deleteCardFromThisDeck(card, exceptionIfMissing) {
    const newIdx = this.newFlashcards.indexOf(card);
    if (newIdx != -1) this.newFlashcards.splice(newIdx, 1);
    const dueIdx = this.dueFlashcards.indexOf(card);
    if (dueIdx != -1) this.dueFlashcards.splice(dueIdx, 1);
    if (newIdx == -1 && dueIdx == -1 && exceptionIfMissing) {
      throw `deleteCardFromThisDeck: Card: ${card.front} not found in deck: ${this.deckName}`;
    }
  }
  deleteCardAtIndex(index, cardListType) {
    const cardList = this.getCardListForCardType(cardListType);
    cardList.splice(index, 1);
  }
  toDeckArray() {
    const result = [];
    result.push(this);
    for (const subdeck of this.subdecks) {
      result.push(...subdeck.toDeckArray());
    }
    return result;
  }
  sortSubdecksList() {
    this.subdecks.sort((a2, b2) => {
      if (a2.deckName < b2.deckName) {
        return -1;
      } else if (a2.deckName > b2.deckName) {
        return 1;
      }
      return 0;
    });
    for (const deck of this.subdecks) {
      deck.sortSubdecksList();
    }
  }
  debugLogToConsole(desc = null, indent = 0) {
    let str = desc != null ? `${desc}: ` : "";
    console.log(str += this.toString(indent));
  }
  toString(indent = 0) {
    let result = "";
    let indentStr = " ".repeat(indent * 4);
    result += `${indentStr}${this.deckName}\r
`;
    indentStr += "  ";
    for (let i2 = 0; i2 < this.newFlashcards.length; i2++) {
      const card = this.newFlashcards[i2];
      result += `${indentStr}New: ${i2}: ${card.front}::${card.back}\r
`;
    }
    for (let i2 = 0; i2 < this.dueFlashcards.length; i2++) {
      const card = this.dueFlashcards[i2];
      const s2 = card.isDue ? "Due" : "Not due";
      result += `${indentStr}${s2}: ${i2}: ${card.front}::${card.back}\r
`;
    }
    for (const subdeck of this.subdecks) {
      result += subdeck.toString(indent + 1);
    }
    return result;
  }
  clone() {
    return this.copyWithCardFilter(() => true);
  }
  copyWithCardFilter(predicate, parent = null) {
    const result = new _Deck(this.deckName, parent);
    result.newFlashcards = [...this.newFlashcards.filter((card) => predicate(card))];
    result.dueFlashcards = [...this.dueFlashcards.filter((card) => predicate(card))];
    for (const s2 of this.subdecks) {
      const newParent = result;
      const newDeck = s2.copyWithCardFilter(predicate, newParent);
      result.subdecks.push(newDeck);
    }
    return result;
  }
  static otherListType(cardListType) {
    let result;
    if (cardListType == 0 /* NewCard */) result = 1 /* DueCard */;
    else if (cardListType == 1 /* DueCard */) result = 0 /* NewCard */;
    else throw "Invalid cardListType";
    return result;
  }
};
var DeckTreeFilter = class {
  static filterForReviewableCards(reviewableDeckTree) {
    return reviewableDeckTree.copyWithCardFilter((card) => !card.question.hasEditLaterTag);
  }
  static filterForRemainingCards(questionPostponementList, deckTree, reviewMode) {
    return deckTree.copyWithCardFilter(
      (card) => (reviewMode == 0 /* Cram */ || card.isNew || card.isDue) && !questionPostponementList.includes(card.question)
    );
  }
};

// src/utils/types.ts
function getTypedObjectEntries(obj) {
  return Object.entries(obj);
}
var getKeysPreserveType = Object.keys;
function mapRecord(record, transform) {
  return Object.fromEntries(
    Object.entries(record).map(([key, value]) => transform(key, value))
  );
}

// src/utils/numbers.ts
var ValueCountDict = class {
  constructor() {
    this.dict = {};
  }
  // Record<value, count>
  clearCountIfMissing(value) {
    if (!this.hasValue(value)) this.dict[value] = 0;
  }
  hasValue(value) {
    return Object.prototype.hasOwnProperty.call(this.dict, value);
  }
  incrementCount(value) {
    this.clearCountIfMissing(value);
    this.dict[value]++;
  }
  getMaxValue() {
    return Math.max(...getKeysPreserveType(this.dict)) || 0;
  }
  getTotalOfValueMultiplyCount() {
    const v2 = getTypedObjectEntries(this.dict).map(([value, count]) => value * count).reduce((a2, b2) => a2 + b2, 0) || 0;
    return v2;
  }
};
var RandomNumberProvider = class {
  getInteger(lowerBound, upperBound) {
    const range = upperBound - lowerBound + 1;
    return Math.floor(Math.random() * range) + lowerBound;
  }
};
var StaticRandomNumberProvider = class {
  getInteger(lowerBound, upperBound) {
    if (lowerBound != this.expectedLowerBound || upperBound != this.expectedUpperBound)
      throw `lowerBound: A${lowerBound}/E${this.expectedLowerBound}, upperBound: A${upperBound}/E${this.expectedUpperBound}`;
    return this.next;
  }
};
var WeightedRandomNumber = class _WeightedRandomNumber {
  constructor(provider) {
    this.provider = provider;
  }
  static create() {
    return new _WeightedRandomNumber(globalRandomNumberProvider);
  }
  // weights is a dictionary:
  //      first number - a key that can be returned
  //      second number - the "bucket size" - this is a weight that influences the probability of the
  //          first number being returned
  //
  // returns:
  //      first number - one of the keys from the weights parameter
  //      second number - an "index" value; 0 <= index < bucketSize
  getRandomValues(weights) {
    const total = _WeightedRandomNumber.calcTotalOfCount(weights);
    if (Object.values(weights).some((i2) => !Number.isInteger(i2) || i2 < 0))
      throw "All weights must be positive integers";
    const v2 = this.provider.getInteger(0, total - 1);
    let x2 = 0;
    for (const kvp in weights) {
      const [value, count] = [Number(kvp), weights[kvp]];
      if (v2 < x2 + count) {
        const index = v2 - x2;
        return [value, index];
      }
      x2 += count;
    }
    throw "";
  }
  static calcTotalOfCount(weights) {
    const total = getTypedObjectEntries(weights).map(([_2, count]) => count).reduce((a2, b2) => a2 + b2, 0) || 0;
    return total;
  }
};
var globalRandomNumberProvider = new RandomNumberProvider();
var staticRandomNumberProvider = new StaticRandomNumberProvider();

// src/deck-tree-iterator.ts
var CardOrder = /* @__PURE__ */ ((CardOrder2) => {
  CardOrder2[CardOrder2["NewFirstSequential"] = 0] = "NewFirstSequential";
  CardOrder2[CardOrder2["NewFirstRandom"] = 1] = "NewFirstRandom";
  CardOrder2[CardOrder2["DueFirstSequential"] = 2] = "DueFirstSequential";
  CardOrder2[CardOrder2["DueFirstRandom"] = 3] = "DueFirstRandom";
  CardOrder2[CardOrder2["EveryCardRandomDeckAndCard"] = 4] = "EveryCardRandomDeckAndCard";
  return CardOrder2;
})(CardOrder || {});
var DeckOrder = /* @__PURE__ */ ((DeckOrder2) => {
  DeckOrder2[DeckOrder2["PrevDeckComplete_Sequential"] = 0] = "PrevDeckComplete_Sequential";
  DeckOrder2[DeckOrder2["PrevDeckComplete_Random"] = 1] = "PrevDeckComplete_Random";
  return DeckOrder2;
})(DeckOrder || {});
var SingleDeckIterator = class _SingleDeckIterator {
  get hasCurrentCard() {
    return this.cardIdx != null;
  }
  get currentCard() {
    let result = null;
    if (this.cardIdx != null) result = this.deck.getCard(this.cardIdx, this.cardListType);
    return result;
  }
  constructor(iteratorOrder) {
    this.iteratorOrder = iteratorOrder;
    this.preferredCardListType = _SingleDeckIterator.getCardListTypeForIterator(
      this.iteratorOrder
    );
    this.weightedRandomNumber = WeightedRandomNumber.create();
  }
  setDeck(deck) {
    this.deck = deck;
    this.setCardListType(null);
  }
  //
  // 0 <= cardIndex < newFlashcards.length + dueFlashcards.length
  //
  setNewOrDueCardIdx(cardIndex) {
    let cardListType = 0 /* NewCard */;
    let index = cardIndex;
    if (cardIndex >= this.deck.newFlashcards.length) {
      cardListType = 1 /* DueCard */;
      index = cardIndex - this.deck.newFlashcards.length;
    }
    this.setCardListType(cardListType, index);
  }
  setCardListType(cardListType, cardIdx = null) {
    this.cardListType = cardListType;
    this.cardIdx = cardIdx;
  }
  nextCard() {
    if (this.iteratorOrder.cardOrder == 4 /* EveryCardRandomDeckAndCard */) {
      this.nextRandomCard();
    } else {
      if (this.cardListType == null) {
        this.setCardListType(this.preferredCardListType);
      }
      if (!this.nextCardWithinCurrentList()) {
        if (this.cardListType == this.preferredCardListType) {
          this.setCardListType(Deck2.otherListType(this.cardListType));
          if (!this.nextCardWithinCurrentList()) {
            this.setCardListType(null);
          }
        } else {
          this.cardIdx = null;
        }
      }
    }
    return this.cardIdx != null;
  }
  nextRandomCard() {
    const newCount = this.deck.newFlashcards.length;
    const dueCount = this.deck.dueFlashcards.length;
    if (newCount + dueCount > 0) {
      const weights = {};
      if (newCount > 0) weights[0 /* NewCard */] = newCount;
      if (dueCount > 0) weights[1 /* DueCard */] = dueCount;
      const [cardListType, index] = this.weightedRandomNumber.getRandomValues(weights);
      this.setCardListType(cardListType, index);
    } else {
      this.setCardListType(null);
    }
  }
  nextCardWithinCurrentList() {
    const cardList = this.deck.getCardListForCardType(this.cardListType);
    const result = cardList.length > 0;
    if (result) {
      switch (this.iteratorOrder.cardOrder) {
        case 2 /* DueFirstSequential */:
        case 0 /* NewFirstSequential */:
          this.cardIdx = 0;
          break;
        case 3 /* DueFirstRandom */:
        case 1 /* NewFirstRandom */:
          this.cardIdx = globalRandomNumberProvider.getInteger(0, cardList.length - 1);
          break;
      }
    }
    return result;
  }
  moveCurrentCardToEndOfList() {
    this.ensureCurrentCard();
    const cardList = this.deck.getCardListForCardType(this.cardListType);
    if (cardList.length <= 1) return;
    const card = this.currentCard;
    this.deck.deleteCardAtIndex(this.cardIdx, this.cardListType);
    this.deck.appendCardToRootDeck(card);
    this.setNoCurrentCard();
  }
  setNoCurrentCard() {
    this.cardIdx = null;
  }
  ensureCurrentCard() {
    if (this.cardIdx == null || this.cardListType == null) throw "no current card";
  }
  static getCardListTypeForIterator(iteratorOrder) {
    let result = null;
    switch (iteratorOrder.cardOrder) {
      case 3 /* DueFirstRandom */:
      case 2 /* DueFirstSequential */:
        result = 1 /* DueCard */;
        break;
      case 1 /* NewFirstRandom */:
      case 0 /* NewFirstSequential */:
        result = 0 /* NewCard */;
        break;
    }
    return result;
  }
};
var DeckTreeIterator = class _DeckTreeIterator {
  get hasCurrentCard() {
    return this.deckIdx != null && this.singleDeckIterator.hasCurrentCard;
  }
  get currentTopicPath() {
    var _a;
    return (_a = this.currentDeck) == null ? void 0 : _a.getTopicPath();
  }
  get currentDeck() {
    if (this.deckIdx == null) return null;
    return this.deckArray[this.deckIdx];
  }
  get currentCard() {
    let result = null;
    if (this.deckIdx != null && this.singleDeckIterator.hasCurrentCard)
      result = this.singleDeckIterator.currentCard;
    return result;
  }
  get currentQuestion() {
    var _a;
    return (_a = this.currentCard) == null ? void 0 : _a.question;
  }
  constructor(iteratorOrder, baseDeckTree) {
    this.singleDeckIterator = new SingleDeckIterator(iteratorOrder);
    this.iteratorOrder = iteratorOrder;
    this.weightedRandomNumber = WeightedRandomNumber.create();
    this.setBaseDeck(baseDeckTree);
  }
  setBaseDeck(baseDeck) {
    this.baseDeckTree = baseDeck;
    this.singleDeckIterator.setNoCurrentCard();
  }
  setIteratorTopicPath(topicPath) {
    const iteratorDeck = this.baseDeckTree.getDeck(topicPath);
    this.deckArray = _DeckTreeIterator.filterForDecksWithCards(iteratorDeck.toDeckArray());
    this.setDeckIdx(null);
  }
  static filterForDecksWithCards(sourceArray) {
    const result = [];
    for (let idx = 0; idx < sourceArray.length; idx++) {
      const deck = sourceArray[idx];
      const hasAnyCards = deck.getCardCount(2 /* All */, false) > 0;
      if (hasAnyCards) {
        result.push(deck);
      }
    }
    return result;
  }
  setDeckIdx(deckIdx) {
    this.deckIdx = deckIdx;
    if (deckIdx != null) this.singleDeckIterator.setDeck(this.deckArray[deckIdx]);
  }
  nextCard() {
    let result = false;
    if (this.hasCurrentCard) {
      this.baseDeckTree.deleteCardFromAllDecks(this.currentCard, true);
    }
    if (this.iteratorOrder.cardOrder == 4 /* EveryCardRandomDeckAndCard */) {
      result = this.nextCardEveryCardRandomDeck();
    } else {
      if (this.deckIdx == null) {
        this.chooseNextDeck(true);
      }
      while (this.deckIdx < this.deckArray.length) {
        if (this.singleDeckIterator.nextCard()) {
          result = true;
          break;
        }
        this.chooseNextDeck(false);
      }
    }
    if (!result) this.deckIdx = null;
    return result;
  }
  chooseNextDeck(firstTime) {
    switch (this.iteratorOrder.deckOrder) {
      case 0 /* PrevDeckComplete_Sequential */:
        this.deckIdx = firstTime ? 0 : this.deckIdx + 1;
        break;
      case 1 /* PrevDeckComplete_Random */: {
        const weights = {};
        let hasDeck = false;
        for (let i2 = 0; i2 < this.deckArray.length; i2++) {
          if (this.deckArray[i2].getCardCount(2 /* All */, false)) {
            weights[i2] = 1;
            hasDeck = true;
          }
        }
        if (hasDeck) {
          const [deckIdx, _2] = this.weightedRandomNumber.getRandomValues(weights);
          this.deckIdx = deckIdx;
        } else {
          this.deckIdx = this.deckArray.length;
        }
        break;
      }
    }
    if (this.deckIdx < this.deckArray.length) {
      this.singleDeckIterator.setDeck(this.deckArray[this.deckIdx]);
    }
  }
  nextCardEveryCardRandomDeck() {
    const weights = {};
    for (let i2 = 0; i2 < this.deckArray.length; i2++) {
      const cardCount = this.deckArray[i2].getCardCount(2 /* All */, false);
      if (cardCount) {
        weights[i2] = cardCount;
      }
    }
    if (Object.keys(weights).length == 0) return false;
    const [deckIdx, cardIdx] = this.weightedRandomNumber.getRandomValues(weights);
    this.setDeckIdx(deckIdx);
    this.singleDeckIterator.setNewOrDueCardIdx(cardIdx);
    return true;
  }
  deleteCurrentQuestionFromAllDecks() {
    this.singleDeckIterator.ensureCurrentCard();
    this.baseDeckTree.deleteQuestionFromAllDecks(this.currentQuestion, false);
    this.singleDeckIterator.setNoCurrentCard();
    return this.nextCard();
  }
  deleteCurrentCardFromAllDecks() {
    this.singleDeckIterator.ensureCurrentCard();
    this.baseDeckTree.deleteCardFromAllDecks(this.currentCard, true);
    this.singleDeckIterator.setNoCurrentCard();
    return this.nextCard();
  }
  moveCurrentCardToEndOfList() {
    this.singleDeckIterator.moveCurrentCardToEndOfList();
  }
  removeCurrentDeckIfEmpty() {
    if (this.currentDeck.getCardCount(2 /* All */, false) == 0) {
      this.deckArray.splice(this.deckIdx, 1);
      if (this.deckIdx < this.deckArray.length) this.setDeckIdx(this.deckIdx);
    }
  }
};

// src/stats.ts
var Stats = class {
  constructor() {
    this.eases = new ValueCountDict();
    this.intervals = new ValueCountDict();
    this.delayedDays = new ValueCountDict();
    this.newCount = 0;
    this.youngCount = 0;
    this.matureCount = 0;
  }
  get totalCount() {
    return this.youngCount + this.matureCount;
  }
  incrementNew() {
    this.newCount++;
  }
  update(delayedDays, interval, ease) {
    this.intervals.incrementCount(interval);
    this.eases.incrementCount(ease);
    this.delayedDays.incrementCount(delayedDays);
    if (interval >= 32) {
      this.matureCount++;
    } else {
      this.youngCount++;
    }
  }
  getMaxInterval() {
    return this.intervals.getMaxValue();
  }
  getAverageInterval() {
    return this.intervals.getTotalOfValueMultiplyCount() / this.totalCount;
  }
  getAverageEases() {
    return this.eases.getTotalOfValueMultiplyCount() / this.totalCount;
  }
};

// src/deck-tree-stats-calculator.ts
var DeckTreeStatsCalculator = class {
  calculate(deckTree) {
    const iteratorOrder = {
      deckOrder: 0 /* PrevDeckComplete_Sequential */,
      cardOrder: 2 /* DueFirstSequential */
    };
    const iterator = new DeckTreeIterator(iteratorOrder, deckTree.clone());
    const result = new Stats();
    iterator.setIteratorTopicPath(TopicPath.emptyPath);
    while (iterator.nextCard()) {
      const card = iterator.currentCard;
      if (card.hasSchedule) {
        const schedule = card.scheduleInfo;
        result.update(
          schedule.delayedBeforeReviewDaysInt(),
          schedule.interval,
          schedule.latestEase
        );
      } else {
        result.incrementNew();
      }
    }
    return result;
  }
};

// src/due-date-histogram.ts
var _DueDateHistogram = class _DueDateHistogram {
  constructor(rec = null) {
    // Key - # of days in future
    // Value - Count of notes due
    this.dueDatesMap = /* @__PURE__ */ new Map();
    this.dueDatesMap = /* @__PURE__ */ new Map();
    if (rec != null) {
      Object.entries(rec).forEach(([key, value]) => {
        this.dueDatesMap.set(Number(key), value);
      });
    }
  }
  get dueNotesCount() {
    let result = 0;
    if (this.dueDatesMap.has(_DueDateHistogram.dueNowNDays))
      result = this.dueDatesMap.get(_DueDateHistogram.dueNowNDays);
    return result;
  }
  hasEntryForDays(days) {
    return this.dueDatesMap.has(days);
  }
  set(days, value) {
    this.dueDatesMap.set(days, value);
  }
  get(days) {
    return this.dueDatesMap.get(days);
  }
  increment(days) {
    let value = 0;
    if (this.dueDatesMap.has(days)) {
      value = this.dueDatesMap.get(days);
    }
    this.dueDatesMap.set(days, value + 1);
  }
  decrement(days) {
    let value = 0;
    if (this.dueDatesMap.has(days)) value = this.dueDatesMap.get(days);
    if (value > 0) {
      this.dueDatesMap.set(days, value - 1);
    }
  }
  findLeastUsedIntervalOverRange(originalInterval, fuzz) {
    if (!this.hasEntryForDays(originalInterval)) {
      return originalInterval;
    }
    let interval = originalInterval;
    outer: for (let i2 = 1; i2 <= fuzz; i2++) {
      for (const ivl of [originalInterval - i2, originalInterval + i2]) {
        if (!this.hasEntryForDays(ivl)) {
          interval = ivl;
          break outer;
        }
        if (this.dueDatesMap.get(ivl) < this.dueDatesMap.get(interval)) interval = ivl;
      }
    }
    return interval;
  }
};
// The key for dueDatesNotes is the number of days after today
// therefore the key to lookup how many cards are due today is 0
_DueDateHistogram.dueNowNDays = 0;
var DueDateHistogram = _DueDateHistogram;
var NoteDueDateHistogram = class extends DueDateHistogram {
  calculateFromReviewDecksAndSort(reviewDecks, osrNoteGraph) {
    this.dueDatesMap = /* @__PURE__ */ new Map();
    const today = globalDateProvider.today.valueOf();
    reviewDecks.forEach((reviewDeck) => {
      reviewDeck.scheduledNotes.forEach((scheduledNote) => {
        const nDays = Math.ceil((scheduledNote.dueUnix - today) / TICKS_PER_DAY);
        this.increment(nDays);
      });
      reviewDeck.sortNotesByDateAndImportance(osrNoteGraph.pageranks);
    });
  }
};
var CardDueDateHistogram = class extends DueDateHistogram {
  calculateFromDeckTree(deckTree) {
    this.dueDatesMap = /* @__PURE__ */ new Map();
    const iteratorOrder = {
      deckOrder: 0 /* PrevDeckComplete_Sequential */,
      cardOrder: 2 /* DueFirstSequential */
    };
    const today = globalDateProvider.today.valueOf();
    const iterator = new DeckTreeIterator(iteratorOrder, deckTree.clone());
    iterator.setIteratorTopicPath(TopicPath.emptyPath);
    while (iterator.nextCard()) {
      const card = iterator.currentCard;
      if (card.hasSchedule) {
        const scheduledCard = card.scheduleInfo;
        const nDays = Math.ceil(
          (scheduledCard.dueDateAsUnix - today) / TICKS_PER_DAY
        );
        this.increment(nDays);
      }
    }
  }
};

// src/file.ts
var import_obsidian2 = require("obsidian");

// src/utils/strings.ts
function literalStringReplace(text, searchStr, replacementStr) {
  let result = text;
  const startIdx = text.indexOf(searchStr);
  if (startIdx >= 0) {
    const startStr = text.substring(0, startIdx);
    const endIdx = startIdx + searchStr.length;
    const endStr = text.substring(endIdx);
    result = startStr + replacementStr + endStr;
  }
  return result;
}
function cyrb53(str, seed = 0) {
  let h12 = 3735928559 ^ seed, h22 = 1103547991 ^ seed;
  for (let i2 = 0, ch; i2 < str.length; i2++) {
    ch = str.charCodeAt(i2);
    h12 = Math.imul(h12 ^ ch, 2654435761);
    h22 = Math.imul(h22 ^ ch, 1597334677);
  }
  h12 = Math.imul(h12 ^ h12 >>> 16, 2246822507) ^ Math.imul(h22 ^ h22 >>> 13, 3266489909);
  h22 = Math.imul(h22 ^ h22 >>> 16, 2246822507) ^ Math.imul(h12 ^ h12 >>> 13, 3266489909);
  return (4294967296 * (2097151 & h22) + (h12 >>> 0)).toString(16);
}
function convertToStringOrEmpty(v2) {
  let result = "";
  if (v2 != null && v2 != void 0) {
    result = v2 + "";
  }
  return result;
}
function splitTextIntoLineArray(text) {
  return text.replaceAll(/\r\n|\r/g, "\n").split("\n");
}
function stringTrimStart(str) {
  if (!str) {
    return ["", ""];
  }
  const trimmed = str.trimStart();
  const wsCount = str.length - trimmed.length;
  const ws = str.substring(0, wsCount);
  return [ws, trimmed];
}
function splitNoteIntoFrontmatterAndContent(str) {
  const lines = splitTextIntoLineArray(str);
  let lineIndex = 0;
  let hasFrontmatter = false;
  do {
    if (lineIndex === 0 && lines[lineIndex] === "---") {
      hasFrontmatter = true;
    } else if (hasFrontmatter && lines[lineIndex] === "---") {
      hasFrontmatter = false;
      lineIndex++;
    }
    if (hasFrontmatter) {
      lineIndex++;
    }
  } while (hasFrontmatter && lineIndex < lines.length);
  if (hasFrontmatter) {
    lineIndex = 0;
  }
  const frontmatter = lines.slice(0, lineIndex).join("\n");
  const emptyLines = lineIndex > 0 ? Array(lineIndex).join(".").split(".") : [];
  const content = emptyLines.concat(lines.slice(lineIndex)).join("\n");
  return [frontmatter, content];
}
function findLineIndexOfSearchStringIgnoringWs(lines, searchString) {
  let result = -1;
  for (let i2 = 0; i2 < lines.length; i2++) {
    if (lines[i2].trim() == searchString) {
      result = i2;
      break;
    }
  }
  return result;
}
function parseObsidianFrontmatterTag(tagStr) {
  const result = [];
  if (tagStr) {
    const tagStrList = tagStr.split(",");
    for (const tag of tagStrList) {
      if (tag !== "") {
        result.push(tag.startsWith("#") ? tag : "#" + tag);
      }
    }
  }
  return result;
}
var MultiLineTextFinder = class _MultiLineTextFinder {
  static findAndReplace(sourceText, searchText, replacementText) {
    let result = null;
    if (sourceText.includes(searchText)) {
      result = literalStringReplace(sourceText, searchText, replacementText);
    } else {
      const sourceTextArray = splitTextIntoLineArray(sourceText);
      const searchTextArray = splitTextIntoLineArray(searchText);
      const lineNo = _MultiLineTextFinder.find(
        sourceTextArray,
        searchTextArray
      );
      if (lineNo !== null) {
        const replacementTextArray = splitTextIntoLineArray(replacementText);
        const linesToRemove = searchTextArray.length;
        sourceTextArray.splice(lineNo, linesToRemove, ...replacementTextArray);
        result = sourceTextArray.join("\n");
      }
    }
    return result;
  }
  static find(sourceText, searchText) {
    let result = null;
    let searchIdx = 0;
    const maxSearchIdx = searchText.length - 1;
    for (let sourceIdx = 0; sourceIdx < sourceText.length; sourceIdx++) {
      const sourceLine = sourceText[sourceIdx].trim();
      const searchLine = searchText[searchIdx].trim();
      if (searchLine == sourceLine) {
        if (searchIdx == maxSearchIdx) {
          result = sourceIdx - searchIdx;
          break;
        }
        searchIdx++;
      } else {
        searchIdx = 0;
      }
    }
    return result;
  }
};

// src/file.ts
var frontmatterTagPseudoLineNum = -1;
var SrTFile = class {
  constructor(vault, metadataCache, file) {
    this.vault = vault;
    this.metadataCache = metadataCache;
    this.file = file;
  }
  get path() {
    return this.file.path;
  }
  get basename() {
    return this.file.basename;
  }
  get tfile() {
    return this.file;
  }
  async getFrontmatter() {
    const fileCachedData = this.metadataCache.getFileCache(this.file) || {};
    const frontmatter = fileCachedData.frontmatter || {};
    const result = /* @__PURE__ */ new Map();
    for (const [key, value] of Object.entries(frontmatter)) {
      const v2 = Array.isArray(value) && value.length > 0 ? value[0] : value;
      const vStr = v2 + "";
      result.set(key, vStr);
    }
    return result;
  }
  getAllTagsFromCache() {
    const fileCachedData = this.metadataCache.getFileCache(this.file) || {};
    const result = (0, import_obsidian2.getAllTags)(fileCachedData) || [];
    return result;
  }
  getAllTagsFromText() {
    var _a;
    const result = [];
    const fileCachedData = this.metadataCache.getFileCache(this.file) || {};
    if (((_a = fileCachedData.tags) == null ? void 0 : _a.length) > 0) {
      result.push(...fileCachedData.tags);
    }
    result.push(...this.getFrontmatterTags(fileCachedData.frontmatter));
    return result;
  }
  getFrontmatterTags(frontmatter) {
    const result = [];
    const frontmatterTags = frontmatter != null ? frontmatter["tags"] + "" : null;
    if (frontmatterTags) {
      const tagStrList = parseObsidianFrontmatterTag(frontmatterTags);
      for (const str of tagStrList) {
        const tag = {
          tag: str,
          position: {
            start: {
              line: frontmatterTagPseudoLineNum,
              col: null,
              offset: null
            },
            end: {
              line: frontmatterTagPseudoLineNum,
              col: null,
              offset: null
            }
          }
        };
        result.push(tag);
      }
    }
    return result;
  }
  getQuestionContext(cardLine) {
    const fileCachedData = this.metadataCache.getFileCache(this.file) || {};
    const headings = fileCachedData.headings || [];
    const stack = [];
    for (const heading of headings) {
      if (heading.position.start.line > cardLine) {
        break;
      }
      while (stack.length > 0 && stack[stack.length - 1].level >= heading.level) {
        stack.pop();
      }
      stack.push(heading);
    }
    const result = [];
    for (const headingObj of stack) {
      headingObj.heading = headingObj.heading.replace(/\[\^\d+\]/gm, "").trim();
      result.push(headingObj.heading);
    }
    return result;
  }
  getTextDirection() {
    let result = 0 /* Unspecified */;
    const fileCache = this.metadataCache.getFileCache(this.file);
    const frontMatter = fileCache == null ? void 0 : fileCache.frontmatter;
    if (frontMatter && (frontMatter == null ? void 0 : frontMatter.direction)) {
      const str = (frontMatter.direction + "").toLowerCase();
      result = str == "rtl" ? 2 /* Rtl */ : 1 /* Ltr */;
    }
    return result;
  }
  async read() {
    return await this.vault.read(this.file);
  }
  async write(content) {
    await this.vault.modify(this.file, content);
  }
};

// src/note.ts
var Note = class {
  get hasChanged() {
    return this.questionList.some((question) => question.hasChanged);
  }
  get filePath() {
    return this.file.path;
  }
  constructor(file, questionList) {
    this.file = file;
    this.questionList = questionList;
    questionList.forEach((question) => question.note = this);
  }
  appendCardsToDeck(deck) {
    for (const question of this.questionList) {
      for (const card of question.cards) {
        deck.appendCard(question.topicPathList, card);
      }
    }
  }
  debugLogToConsole(desc = "") {
    var _a;
    let str = `Note: ${desc}: ${this.questionList.length} questions\r
`;
    for (let i2 = 0; i2 < this.questionList.length; i2++) {
      const q2 = this.questionList[i2];
      str += `[${i2}]: ${q2.questionType}: ${q2.lineNo}: ${(_a = q2.topicPathList) == null ? void 0 : _a.format("|")}: ${q2.questionText.original}\r
`;
    }
    console.debug(str);
  }
  async writeNoteFile(settings) {
    let fileText = await this.file.read();
    for (const question of this.questionList) {
      if (question.hasChanged) {
        fileText = question.updateQuestionWithinNoteText(fileText, settings);
      }
    }
    await this.file.write(fileText);
    this.questionList.forEach((question) => question.hasChanged = false);
  }
};

// src/card.ts
var Card = class extends RepetitionItem {
  constructor(init) {
    super();
    Object.assign(this, init);
  }
  get cardListType() {
    return this.isNew ? 0 /* NewCard */ : 1 /* DueCard */;
  }
  formatSchedule() {
    let result = "";
    if (this.hasSchedule) result = this.scheduleInfo.formatCardScheduleForHtmlComment();
    else result = "New";
    return result;
  }
};

// src/parser.ts
var import_clozecraft = __toESM(require_dist());

// src/question.ts
var QuestionText = class _QuestionText {
  constructor(original, topicPathWithWs, actualQuestion, textDirection, blockId) {
    this.original = original;
    this.topicPathWithWs = topicPathWithWs;
    this.actualQuestion = actualQuestion;
    this.textDirection = textDirection;
    this.obsidianBlockId = blockId;
    this.textHash = cyrb53(this.formatTopicAndQuestion());
  }
  endsWithCodeBlock() {
    return this.actualQuestion.endsWith("```");
  }
  static create(original, textDirection, settings) {
    const [topicPathWithWs, actualQuestion, blockId] = this.splitText(original, settings);
    return new _QuestionText(original, topicPathWithWs, actualQuestion, textDirection, blockId);
  }
  static splitText(original, settings) {
    const originalWithoutSR = DataStore.getInstance().questionRemoveScheduleInfo(original);
    let actualQuestion = originalWithoutSR.trimEnd();
    let topicPathWithWs = null;
    let blockId = null;
    const topicPath = TopicPath.getTopicPathFromCardText(originalWithoutSR);
    if (topicPath == null ? void 0 : topicPath.hasPath) {
      const [preTopicPathWs, cardText2] = stringTrimStart(originalWithoutSR);
      const cardText3 = cardText2.replaceAll(OBSIDIAN_TAG_AT_STARTOFLINE_REGEX, "");
      let postTopicPathWs = null;
      [postTopicPathWs, actualQuestion] = stringTrimStart(cardText3);
      if (!settings.convertFoldersToDecks) {
        topicPathWithWs = new TopicPathWithWs(topicPath, preTopicPathWs, postTopicPathWs);
      }
    }
    [actualQuestion, blockId] = this.extractObsidianBlockId(actualQuestion);
    return [topicPathWithWs, actualQuestion, blockId];
  }
  static extractObsidianBlockId(text) {
    let question = text;
    let blockId = null;
    const match2 = text.match(OBSIDIAN_BLOCK_ID_ENDOFLINE_REGEX);
    if (match2) {
      blockId = match2[0].trim();
      const newLength = question.length - blockId.length;
      question = question.substring(0, newLength).trimEnd();
    }
    return [question, blockId];
  }
  formatTopicAndQuestion() {
    let result = "";
    if (this.topicPathWithWs) {
      result += this.topicPathWithWs.formatWithWs();
    }
    result += this.actualQuestion;
    return result;
  }
};
var Question = class _Question {
  get questionType() {
    return this.parsedQuestionInfo.cardType;
  }
  get lineNo() {
    return this.parsedQuestionInfo.firstLineNum;
  }
  constructor(init) {
    Object.assign(this, init);
  }
  getHtmlCommentSeparator(settings) {
    const sep2 = this.isCardCommentsOnSameLine(settings) ? " " : "\n";
    return sep2;
  }
  isCardCommentsOnSameLine(settings) {
    let result = settings.cardCommentOnSameLine;
    if (this.questionText.endsWithCodeBlock()) {
      result = false;
    }
    return result;
  }
  setCardList(cards) {
    this.cards = cards;
    this.cards.forEach((card) => card.question = this);
  }
  formatForNote(settings) {
    let result = this.questionText.formatTopicAndQuestion();
    const blockId = this.questionText.obsidianBlockId;
    const hasSchedule = this.cards.some((card) => card.hasSchedule);
    if (hasSchedule) {
      result = result.trimEnd();
      const scheduleHtml = DataStoreAlgorithm.getInstance().questionFormatScheduleAsHtmlComment(this);
      if (blockId) {
        if (this.isCardCommentsOnSameLine(settings))
          result += ` ${scheduleHtml} ${blockId}`;
        else result += ` ${blockId}
${scheduleHtml}`;
      } else {
        result += this.getHtmlCommentSeparator(settings) + scheduleHtml;
      }
    } else {
      if (blockId) result += ` ${blockId}`;
    }
    return result;
  }
  updateQuestionWithinNoteText(noteText, settings) {
    const originalText = this.questionText.original;
    const replacementText = this.formatForNote(settings);
    let newText = MultiLineTextFinder.findAndReplace(noteText, originalText, replacementText);
    if (newText) {
      this.questionText = QuestionText.create(
        replacementText,
        this.questionText.textDirection,
        settings
      );
    } else {
      console.error(
        `updateQuestionText: Text not found: ${originalText.substring(
          0,
          100
        )} in note: ${noteText.substring(0, 100)}`
      );
      newText = noteText;
    }
    return newText;
  }
  async writeQuestion(settings) {
    const fileText = await this.note.file.read();
    const newText = this.updateQuestionWithinNoteText(fileText, settings);
    await this.note.file.write(newText);
    this.hasChanged = false;
  }
  formatTopicPathList() {
    return this.topicPathList.format("|");
  }
  static Create(settings, parsedQuestionInfo, noteTopicPathList, textDirection, context) {
    const hasEditLaterTag = parsedQuestionInfo.text.includes(settings.editLaterTag);
    const questionText = QuestionText.create(
      parsedQuestionInfo.text,
      textDirection,
      settings
    );
    let topicPathList = noteTopicPathList;
    if (questionText.topicPathWithWs) {
      topicPathList = new TopicPathList([questionText.topicPathWithWs.topicPath]);
    }
    const result = new _Question({
      parsedQuestionInfo,
      topicPathList,
      questionText,
      hasEditLaterTag,
      questionContext: context,
      cards: null,
      hasChanged: false
    });
    return result;
  }
};

// src/parser.ts
var debugParser = false;
function setDebugParser(value) {
  debugParser = value;
}
var ParsedQuestionInfo = class {
  constructor(cardType, text, firstLineNum, lastLineNum) {
    this.cardType = cardType;
    this.text = text;
    this.firstLineNum = firstLineNum;
    this.lastLineNum = lastLineNum;
  }
  isQuestionLineNum(lineNum) {
    return lineNum >= this.firstLineNum && lineNum <= this.lastLineNum;
  }
};
function markerInsideCodeBlock(text, marker, markerIndex) {
  let goingBack = markerIndex - 1, goingForward = markerIndex + marker.length;
  let backTicksBefore = 0, backTicksAfter = 0;
  while (goingBack >= 0) {
    if (text[goingBack] === "`") backTicksBefore++;
    goingBack--;
  }
  while (goingForward < text.length) {
    if (text[goingForward] === "`") backTicksAfter++;
    goingForward++;
  }
  return backTicksBefore % 2 === 1 && backTicksAfter % 2 === 1;
}
function hasInlineMarker(text, marker) {
  if (marker.length == 0) return false;
  const markerIdx = text.indexOf(marker);
  if (markerIdx === -1) return false;
  return !markerInsideCodeBlock(text, marker, markerIdx);
}
function parse(text, options) {
  if (debugParser) {
    console.log("Text to parse:\n<<<" + text + ">>>");
  }
  const inlineSeparators = [
    { separator: options.singleLineCardSeparator, type: 0 /* SingleLineBasic */ },
    { separator: options.singleLineReversedCardSeparator, type: 1 /* SingleLineReversed */ }
  ];
  inlineSeparators.sort((a2, b2) => b2.separator.length - a2.separator.length);
  const cards = [];
  let cardText = "";
  let cardType = null;
  let firstLineNo = 0, lastLineNo = 0;
  const clozecrafter = new import_clozecraft.ClozeCrafter(options.clozePatterns);
  const lines = text.replaceAll("\r\n", "\n").split("\n");
  for (let i2 = 0; i2 < lines.length; i2++) {
    const currentLine = lines[i2], currentTrimmed = lines[i2].trim();
    if (currentLine.startsWith("<!--") && !currentLine.startsWith("<!--SR:")) {
      while (i2 + 1 < lines.length && !currentLine.includes("-->")) i2++;
      i2++;
      continue;
    }
    const isEmptyLine = currentTrimmed.length == 0;
    const hasMultilineCardEndMarker = options.multilineCardEndMarker && currentTrimmed == options.multilineCardEndMarker;
    if (
      // We've probably reached the end of a card
      isEmptyLine && !options.multilineCardEndMarker || // Empty line & we're not picking up any card
      isEmptyLine && cardType == null || // We've reached the end of a multi line card &
      //  we're using custom end markers
      hasMultilineCardEndMarker
    ) {
      if (cardType) {
        lastLineNo = i2 - 1;
        cards.push(
          new ParsedQuestionInfo(cardType, cardText.trimEnd(), firstLineNo, lastLineNo)
        );
        cardType = null;
      }
      cardText = "";
      firstLineNo = i2 + 1;
      continue;
    }
    if (cardText.length > 0) {
      cardText += "\n";
    }
    cardText += currentLine.trimEnd();
    for (const { separator, type } of inlineSeparators) {
      if (hasInlineMarker(currentLine, separator)) {
        cardType = type;
        break;
      }
    }
    if (cardType == 0 /* SingleLineBasic */ || cardType == 1 /* SingleLineReversed */) {
      cardText = currentLine;
      firstLineNo = i2;
      if (i2 + 1 < lines.length && lines[i2 + 1].startsWith("<!--SR:")) {
        cardText += "\n" + lines[i2 + 1];
        i2++;
      }
      lastLineNo = i2;
      cards.push(new ParsedQuestionInfo(cardType, cardText, firstLineNo, lastLineNo));
      cardType = null;
      cardText = "";
    } else if (currentTrimmed === options.multilineCardSeparator) {
      if (cardText.length > 1) {
        cardType = 2 /* MultiLineBasic */;
      }
    } else if (currentTrimmed === options.multilineReversedCardSeparator) {
      if (cardText.length > 1) {
        cardType = 3 /* MultiLineReversed */;
      }
    } else if (currentLine.startsWith("```") || currentLine.startsWith("~~~")) {
      const codeBlockClose = currentLine.match(/`+|~+/)[0];
      while (i2 + 1 < lines.length && !lines[i2 + 1].startsWith(codeBlockClose)) {
        i2++;
        cardText += "\n" + lines[i2];
      }
      cardText += "\n" + codeBlockClose;
      i2++;
    } else if (cardType === null && clozecrafter.isClozeNote(currentLine)) {
      cardType = 4 /* Cloze */;
    }
  }
  if (cardType && cardText) {
    lastLineNo = lines.length - 1;
    cards.push(new ParsedQuestionInfo(cardType, cardText.trimEnd(), firstLineNo, lastLineNo));
  }
  if (debugParser) {
    console.log("Parsed cards:\n", cards);
  }
  return cards;
}

// src/question-type.ts
var import_clozecraft2 = __toESM(require_dist());
var CardFrontBack = class {
  // The caller is responsible for any required trimming of leading/trailing spaces
  constructor(front, back) {
    this.front = front;
    this.back = back;
  }
};
var CardFrontBackUtil = class {
  static expand(questionType, questionText, settings) {
    const handler = QuestionTypeFactory.create(questionType);
    return handler.expand(questionText, settings);
  }
};
var QuestionTypeSingleLineBasic = class {
  expand(questionText, settings) {
    const idx = questionText.indexOf(settings.singleLineCardSeparator);
    const item = new CardFrontBack(
      questionText.substring(0, idx),
      questionText.substring(idx + settings.singleLineCardSeparator.length)
    );
    const result = [item];
    return result;
  }
};
var QuestionTypeSingleLineReversed = class {
  expand(questionText, settings) {
    const idx = questionText.indexOf(settings.singleLineReversedCardSeparator);
    const side1 = questionText.substring(0, idx), side2 = questionText.substring(
      idx + settings.singleLineReversedCardSeparator.length
    );
    const result = [
      new CardFrontBack(side1, side2),
      new CardFrontBack(side2, side1)
    ];
    return result;
  }
};
var QuestionTypeMultiLineBasic = class {
  expand(questionText, settings) {
    const questionLines = questionText.split("\n");
    const lineIdx = findLineIndexOfSearchStringIgnoringWs(
      questionLines,
      settings.multilineCardSeparator
    );
    const side1 = questionLines.slice(0, lineIdx).join("\n");
    const side2 = questionLines.slice(lineIdx + 1).join("\n");
    const result = [new CardFrontBack(side1, side2)];
    return result;
  }
};
var QuestionTypeMultiLineReversed = class {
  expand(questionText, settings) {
    const questionLines = questionText.split("\n");
    const lineIdx = findLineIndexOfSearchStringIgnoringWs(
      questionLines,
      settings.multilineReversedCardSeparator
    );
    const side1 = questionLines.slice(0, lineIdx).join("\n");
    const side2 = questionLines.slice(lineIdx + 1).join("\n");
    const result = [
      new CardFrontBack(side1, side2),
      new CardFrontBack(side2, side1)
    ];
    return result;
  }
};
var QuestionTypeCloze = class {
  expand(questionText, settings) {
    const clozecrafter = new import_clozecraft2.ClozeCrafter(settings.clozePatterns);
    const clozeNote = clozecrafter.createClozeNote(questionText);
    const clozeFormatter = new QuestionTypeClozeFormatter();
    let front, back;
    const result = [];
    for (let i2 = 0; i2 < clozeNote.numCards; i2++) {
      front = clozeNote.getCardFront(i2, clozeFormatter);
      back = clozeNote.getCardBack(i2, clozeFormatter);
      result.push(new CardFrontBack(front, back));
    }
    return result;
  }
};
var QuestionTypeClozeFormatter = class {
  asking(answer, hint) {
    return `<span style='color:#2196f3'>${!hint ? "[...]" : `[${hint}]`}</span>`;
  }
  showingAnswer(answer, _hint) {
    return `<span style='color:#2196f3'>${answer}</span>`;
  }
  hiding(answer, hint) {
    return `<span style='color:var(--code-comment)'>${!hint ? "[...]" : `[${hint}]`}</span>`;
  }
};
var QuestionTypeFactory = class {
  static create(questionType) {
    let handler;
    switch (questionType) {
      case 0 /* SingleLineBasic */:
        handler = new QuestionTypeSingleLineBasic();
        break;
      case 1 /* SingleLineReversed */:
        handler = new QuestionTypeSingleLineReversed();
        break;
      case 2 /* MultiLineBasic */:
        handler = new QuestionTypeMultiLineBasic();
        break;
      case 3 /* MultiLineReversed */:
        handler = new QuestionTypeMultiLineReversed();
        break;
      case 4 /* Cloze */:
        handler = new QuestionTypeCloze();
        break;
    }
    return handler;
  }
};

// src/settings.ts
var import_obsidian3 = require("obsidian");
var DEFAULT_SETTINGS = {
  // flashcards
  flashcardTags: ["#flashcards"],
  convertFoldersToDecks: false,
  burySiblingCards: false,
  randomizeCardOrder: null,
  flashcardCardOrder: "DueFirstRandom",
  flashcardDeckOrder: "PrevDeckComplete_Sequential",
  convertHighlightsToClozes: true,
  convertBoldTextToClozes: false,
  convertCurlyBracketsToClozes: false,
  clozePatterns: ["==[123;;]answer[;;hint]=="],
  singleLineCardSeparator: "::",
  singleLineReversedCardSeparator: ":::",
  multilineCardSeparator: "?",
  multilineReversedCardSeparator: "??",
  multilineCardEndMarker: "",
  editLaterTag: "#edit-later",
  // notes
  enableNoteReviewPaneOnStartup: true,
  tagsToReview: ["#review"],
  noteFoldersToIgnore: ["**/*.excalidraw.md"],
  openRandomNote: false,
  autoNextNote: false,
  disableFileMenuReviewOptions: false,
  maxNDaysNotesReviewQueue: 365,
  // UI settings
  showRibbonIcon: true,
  showStatusBar: true,
  initiallyExpandAllSubdecksInTree: false,
  showContextInCards: true,
  showIntervalInReviewButtons: true,
  flashcardHeightPercentage: import_obsidian3.Platform.isMobile ? 100 : 80,
  flashcardWidthPercentage: import_obsidian3.Platform.isMobile ? 100 : 40,
  flashcardEasyText: t("EASY"),
  flashcardGoodText: t("GOOD"),
  flashcardHardText: t("HARD"),
  reviewButtonDelay: 0,
  openViewInNewTab: false,
  // algorithm
  algorithm: "SM-2-OSR" /* SM_2_OSR */,
  baseEase: 250,
  lapsesIntervalChange: 0.5,
  easyBonus: 1.3,
  loadBalance: true,
  maximumInterval: 36525,
  maxLinkFactor: 1,
  // storage
  dataStore: "NOTES" /* NOTES */,
  cardCommentOnSameLine: false,
  // logging
  showSchedulingDebugMessages: false,
  showParserDebugMessages: false
};
function upgradeSettings(settings) {
  if (settings.randomizeCardOrder != null && settings.flashcardCardOrder == null && settings.flashcardDeckOrder == null) {
    settings.flashcardCardOrder = settings.randomizeCardOrder ? "DueFirstRandom" : "DueFirstSequential";
    settings.flashcardDeckOrder = "PrevDeckComplete_Sequential";
    settings.randomizeCardOrder = null;
  }
  if (settings.clozePatterns == null) {
    settings.clozePatterns = [];
    if (settings.convertHighlightsToClozes)
      settings.clozePatterns.push("==[123;;]answer[;;hint]==");
    if (settings.convertBoldTextToClozes)
      settings.clozePatterns.push("**[123;;]answer[;;hint]**");
    if (settings.convertCurlyBracketsToClozes)
      settings.clozePatterns.push("{{[123;;]answer[;;hint]}}");
  }
}
var SettingsUtil = class _SettingsUtil {
  static isFlashcardTag(settings, tag) {
    return _SettingsUtil.isTagInList(settings.flashcardTags, tag);
  }
  static isPathInNoteIgnoreFolder(settings, path3) {
    return settings.noteFoldersToIgnore.some((folder) => pathMatchesPattern(path3, folder));
  }
  static isAnyTagANoteReviewTag(settings, tags) {
    for (const tag of tags) {
      if (settings.tagsToReview.some(
        (tagToReview) => tag === tagToReview || tag.startsWith(tagToReview + "/")
      )) {
        return true;
      }
    }
    return false;
  }
  // Given a list of tags, return the subset that is in settings.tagsToReview
  static filterForNoteReviewTag(settings, tags) {
    const result = [];
    for (const tagToReview of settings.tagsToReview) {
      if (tags.some((tag) => tag === tagToReview || tag.startsWith(tagToReview + "/"))) {
        result.push(tagToReview);
      }
    }
    return result;
  }
  static isTagInList(tagList, tag) {
    for (const tagFromList of tagList) {
      if (tag === tagFromList || tag.startsWith(tagFromList + "/")) {
        return true;
      }
    }
    return false;
  }
};

// src/note-question-parser.ts
var NoteQuestionParser = class {
  constructor(settings) {
    this.settings = settings;
  }
  async createQuestionList(noteFile, defaultTextDirection, folderTopicPath, onlyKeepQuestionsWithTopicPath) {
    this.noteFile = noteFile;
    const tagCacheList = noteFile.getAllTagsFromCache();
    const hasTopicPaths = tagCacheList.some((item) => SettingsUtil.isFlashcardTag(this.settings, item)) || folderTopicPath.hasPath;
    if (hasTopicPaths) {
      const noteText = await noteFile.read();
      const tagCompleteList = noteFile.getAllTagsFromText();
      [this.frontmatterText, this.contentText] = splitNoteIntoFrontmatterAndContent(noteText);
      let textDirection = noteFile.getTextDirection();
      if (textDirection == 0 /* Unspecified */) textDirection = defaultTextDirection;
      this.questionList = this.doCreateQuestionList(
        noteText,
        textDirection,
        folderTopicPath,
        this.tagCacheList
      );
      [this.frontmatterTopicPathList, this.contentTopicPathInfo] = this.analyseTagCacheList(tagCompleteList);
      for (const question of this.questionList) {
        question.topicPathList = this.determineQuestionTopicPathList(question);
      }
      if (onlyKeepQuestionsWithTopicPath) {
        this.questionList = this.questionList.filter((q2) => q2.topicPathList);
      }
    } else {
      this.questionList = [];
    }
    return this.questionList;
  }
  doCreateQuestionList(noteText, textDirection, folderTopicPath, tagCacheList) {
    this.noteText = noteText;
    this.noteLines = splitTextIntoLineArray(noteText);
    this.folderTopicPath = folderTopicPath;
    this.tagCacheList = tagCacheList;
    const result = [];
    const parsedQuestionInfoList = this.parseQuestions();
    for (const parsedQuestionInfo of parsedQuestionInfoList) {
      const question = this.createQuestionObject(parsedQuestionInfo, textDirection);
      const cardFrontBackList = CardFrontBackUtil.expand(
        question.questionType,
        question.questionText.actualQuestion,
        this.settings
      );
      let cardScheduleInfoList = DataStore.getInstance().questionCreateSchedule(
        question.questionText.original,
        null
      );
      const correctLength = cardFrontBackList.length;
      if (cardScheduleInfoList.length > correctLength) {
        question.hasChanged = true;
        cardScheduleInfoList = cardScheduleInfoList.slice(0, correctLength);
      }
      const cardList = this.createCardList(cardFrontBackList, cardScheduleInfoList);
      question.setCardList(cardList);
      result.push(question);
    }
    return result;
  }
  parseQuestions() {
    const settings = this.settings;
    const parserOptions = {
      singleLineCardSeparator: settings.singleLineCardSeparator,
      singleLineReversedCardSeparator: settings.singleLineReversedCardSeparator,
      multilineCardSeparator: settings.multilineCardSeparator,
      multilineReversedCardSeparator: settings.multilineReversedCardSeparator,
      multilineCardEndMarker: settings.multilineCardEndMarker,
      clozePatterns: settings.clozePatterns
    };
    return parse(this.contentText, parserOptions);
  }
  createQuestionObject(parsedQuestionInfo, textDirection) {
    const questionContext = this.noteFile.getQuestionContext(
      parsedQuestionInfo.firstLineNum
    );
    const result = Question.Create(
      this.settings,
      parsedQuestionInfo,
      null,
      // We haven't worked out the TopicPathList yet
      textDirection,
      questionContext
    );
    return result;
  }
  createCardList(cardFrontBackList, cardScheduleInfoList) {
    const siblings = [];
    for (let i2 = 0; i2 < cardFrontBackList.length; i2++) {
      const { front, back } = cardFrontBackList[i2];
      const hasScheduleInfo = i2 < cardScheduleInfoList.length;
      const schedule = cardScheduleInfoList[i2];
      const cardObj = new Card({
        front,
        back,
        cardIdx: i2
      });
      cardObj.scheduleInfo = hasScheduleInfo ? schedule : null;
      siblings.push(cardObj);
    }
    return siblings;
  }
  //
  // Given the complete list of tags within a note:
  // 1.   Only keep tags that are specified in the user settings as flashcardTags
  // 2.   Filter out tags that are question specific
  //      (these will be parsed separately by class QuestionText)
  // 3.   Combine all tags present logically grouped together into a single entry
  //      - All tags present on the same line grouped together
  //      - All tags within frontmatter grouped together (note that multiple tags
  //      within frontmatter appear on separate lines)
  //
  analyseTagCacheList(tagCacheList) {
    this.flashcardTagList = tagCacheList.filter(
      (item) => SettingsUtil.isFlashcardTag(this.settings, item.tag)
    );
    if (this.flashcardTagList.length > 0) {
      this.flashcardTagList.sort((a2, b2) => a2.position.start.line - b2.position.start.line);
    }
    let frontmatterLineCount = 0;
    if (this.frontmatterText) {
      frontmatterLineCount = splitTextIntoLineArray(this.frontmatterText).length;
    }
    const frontmatterTopicPathList = this.determineFrontmatterTopicPathList(
      this.flashcardTagList,
      frontmatterLineCount
    );
    const contentTopicPathList = this.determineContentTopicPathList(
      this.flashcardTagList,
      frontmatterLineCount
    );
    return [frontmatterTopicPathList, contentTopicPathList];
  }
  determineFrontmatterTopicPathList(flashcardTagList, frontmatterLineCount) {
    let result = null;
    const noteLevelTagList = flashcardTagList.filter(
      (item) => item.position.start.line == frontmatterTagPseudoLineNum && this.isNoteLevelFlashcardTag(item)
    );
    if (noteLevelTagList.length > 0) {
      if (this.frontmatterText) {
        const frontmatterTagCacheList = noteLevelTagList.filter(
          (item) => item.position.start.line < frontmatterLineCount
        );
        if (frontmatterTagCacheList.length > 0)
          result = this.createTopicPathList(
            frontmatterTagCacheList,
            frontmatterTagPseudoLineNum
          );
      }
    }
    return result;
  }
  determineContentTopicPathList(flashcardTagList, frontmatterLineCount) {
    const result = [];
    const contentStartLineNum = frontmatterLineCount;
    const contentTagCacheList = flashcardTagList.filter(
      (item) => item.position.start.line >= contentStartLineNum && this.isNoteLevelFlashcardTag(item)
    );
    let list = [];
    for (const tag of contentTagCacheList) {
      if (list.length != 0) {
        const startLineNum = list[0].position.start.line;
        if (startLineNum != tag.position.start.line) {
          result.push(this.createTopicPathList(list, startLineNum));
          list = [];
        }
      }
      list.push(tag);
    }
    if (list.length > 0) {
      const startLineNum = list[0].position.start.line;
      result.push(this.createTopicPathList(list, startLineNum));
    }
    return result;
  }
  isNoteLevelFlashcardTag(tagItem) {
    const tagLineNum = tagItem.position.start.line;
    const isQuestionSpecific = this.questionList.some(
      (q2) => q2.parsedQuestionInfo.isQuestionLineNum(tagLineNum)
    );
    return !isQuestionSpecific;
  }
  createTopicPathList(tagCacheList, lineNum) {
    const list = [];
    for (const tagCache of tagCacheList) {
      list.push(TopicPath.getTopicPathFromTag(tagCache.tag));
    }
    return new TopicPathList(list, lineNum);
  }
  createTopicPathListFromSingleTag(tagCache) {
    const list = [TopicPath.getTopicPathFromTag(tagCache.tag)];
    return new TopicPathList(list, tagCache.position.start.line);
  }
  // A question can be associated with multiple topics (hence returning TopicPathList and not just TopicPath).
  //
  // If the question has an associated question specific TopicPath, then that is returned.
  //
  // Else the first TopicPathList prior to the question (in the order present in the file) is returned.
  // That could be either the tags within the note's frontmatter, or tags on lines within the note's content.
  determineQuestionTopicPathList(question) {
    let result;
    if (this.settings.convertFoldersToDecks) {
      result = new TopicPathList([this.folderTopicPath]);
    } else {
      const questionText = question.questionText;
      if (questionText.topicPathWithWs)
        result = new TopicPathList(
          [questionText.topicPathWithWs.topicPath],
          question.parsedQuestionInfo.firstLineNum
        );
      else {
        result = this.frontmatterTopicPathList;
        for (let i2 = this.contentTopicPathInfo.length - 1; i2 >= 0; i2--) {
          const topicPathList = this.contentTopicPathInfo[i2];
          if (topicPathList.lineNum < question.parsedQuestionInfo.firstLineNum) {
            result = topicPathList;
            break;
          }
        }
        if (!result && this.flashcardTagList.length > 0) {
          result = this.createTopicPathListFromSingleTag(this.flashcardTagList[0]);
        }
      }
    }
    return result;
  }
};

// src/note-file-loader.ts
var NoteFileLoader = class {
  constructor(settings) {
    this.settings = settings;
  }
  async load(noteFile, defaultTextDirection, folderTopicPath) {
    this.noteFile = noteFile;
    const questionParser = new NoteQuestionParser(this.settings);
    const onlyKeepQuestionsWithTopicPath = true;
    const questionList = await questionParser.createQuestionList(
      noteFile,
      defaultTextDirection,
      folderTopicPath,
      onlyKeepQuestionsWithTopicPath
    );
    const result = new Note(noteFile, questionList);
    return result;
  }
};

// src/core.ts
var OsrCore = class {
  constructor() {
    this._reviewableDeckTree = new Deck2("root", null);
  }
  get noteReviewQueue() {
    return this._noteReviewQueue;
  }
  get remainingDeckTree() {
    return this._remainingDeckTree;
  }
  get reviewableDeckTree() {
    return this._reviewableDeckTree;
  }
  get questionPostponementList() {
    return this._questionPostponementList;
  }
  get dueDateFlashcardHistogram() {
    return this._dueDateFlashcardHistogram;
  }
  get dueDateNoteHistogram() {
    return this._dueDateNoteHistogram;
  }
  get cardStats() {
    return this._cardStats;
  }
  init(questionPostponementList, osrNoteLinkInfoFinder, settings, dataChangedHandler, noteReviewQueue) {
    this.settings = settings;
    this.osrNoteLinkInfoFinder = osrNoteLinkInfoFinder;
    this.dataChangedHandler = dataChangedHandler;
    this._noteReviewQueue = noteReviewQueue;
    this._questionPostponementList = questionPostponementList;
    this._dueDateFlashcardHistogram = new CardDueDateHistogram();
    this._dueDateNoteHistogram = new NoteDueDateHistogram();
  }
  loadInit() {
    this.osrNoteGraph = new OsrNoteGraph(this.osrNoteLinkInfoFinder);
    this._noteReviewQueue.init();
    this.fullDeckTree = new Deck2("root", null);
  }
  async processFile(noteFile) {
    const schedule = await DataStoreAlgorithm.getInstance().noteGetSchedule(noteFile);
    let note = null;
    this.osrNoteGraph.processLinks(noteFile.path);
    const topicPath = this.findTopicPath(noteFile);
    if (topicPath.hasPath) {
      note = await this.loadNote(noteFile, topicPath);
      note.appendCardsToDeck(this.fullDeckTree);
    }
    SrsAlgorithm.getInstance().noteOnLoadedNote(noteFile.path, note, schedule == null ? void 0 : schedule.latestEase);
    const tags = noteFile.getAllTagsFromCache();
    const matchedNoteTags = SettingsUtil.filterForNoteReviewTag(this.settings, tags);
    if (matchedNoteTags.length == 0) {
      return;
    }
    const noteSchedule = await DataStoreAlgorithm.getInstance().noteGetSchedule(noteFile);
    this._noteReviewQueue.addNoteToQueue(noteFile, noteSchedule, matchedNoteTags);
  }
  finaliseLoad() {
    this.osrNoteGraph.generatePageRanks();
    this._reviewableDeckTree = DeckTreeFilter.filterForReviewableCards(this.fullDeckTree);
    this._reviewableDeckTree.sortSubdecksList();
    this._remainingDeckTree = DeckTreeFilter.filterForRemainingCards(
      this._questionPostponementList,
      this._reviewableDeckTree,
      1 /* Review */
    );
    const calc = new DeckTreeStatsCalculator();
    this._cardStats = calc.calculate(this._reviewableDeckTree);
    this.calculateDerivedInfo();
    this._dueDateFlashcardHistogram.calculateFromDeckTree(this._reviewableDeckTree);
    if (this.dataChangedHandler) this.dataChangedHandler();
  }
  async saveNoteReviewResponse(noteFile, response, settings) {
    const originalNoteSchedule = await DataStoreAlgorithm.getInstance().noteGetSchedule(noteFile);
    let noteSchedule;
    if (originalNoteSchedule == null) {
      noteSchedule = SrsAlgorithm.getInstance().noteCalcNewSchedule(
        noteFile.path,
        this.osrNoteGraph,
        response,
        this._dueDateNoteHistogram
      );
    } else {
      noteSchedule = SrsAlgorithm.getInstance().noteCalcUpdatedSchedule(
        noteFile.path,
        originalNoteSchedule,
        response,
        this._dueDateNoteHistogram
      );
    }
    await DataStoreAlgorithm.getInstance().noteSetSchedule(noteFile, noteSchedule);
    this._noteReviewQueue.updateScheduleInfo(noteFile, noteSchedule);
    this.calculateDerivedInfo();
    await this.buryAllCardsInNote(settings, noteFile);
    if (this.dataChangedHandler) this.dataChangedHandler();
  }
  calculateDerivedInfo() {
    const todayUnix = globalDateProvider.today.valueOf();
    this.noteReviewQueue.calcDueNotesCount(todayUnix);
    this._dueDateNoteHistogram.calculateFromReviewDecksAndSort(
      this.noteReviewQueue.reviewDecks,
      this.osrNoteGraph
    );
  }
  async buryAllCardsInNote(settings, noteFile) {
    if (settings.burySiblingCards) {
      const topicPath = this.findTopicPath(noteFile);
      const noteX = await this.loadNote(noteFile, topicPath);
      if (noteX.questionList.length > 0) {
        for (const question of noteX.questionList) {
          this._questionPostponementList.add(question);
        }
        await this._questionPostponementList.write();
      }
    }
  }
  async loadNote(noteFile, topicPath) {
    const loader = new NoteFileLoader(this.settings);
    const note = await loader.load(noteFile, this.defaultTextDirection, topicPath);
    if (note.hasChanged) {
      await note.writeNoteFile(this.settings);
    }
    return note;
  }
  findTopicPath(note) {
    return TopicPath.getTopicPathOfFile(note, this.settings);
  }
};
var OsrAppCore = class extends OsrCore {
  constructor(app) {
    super();
    this._syncLock = false;
    this.app = app;
  }
  get syncLock() {
    return this._syncLock;
  }
  async loadVault() {
    if (this._syncLock) {
      return;
    }
    this._syncLock = true;
    try {
      this.loadInit();
      const notes = this.app.vault.getMarkdownFiles();
      for (const noteFile of notes) {
        if (SettingsUtil.isPathInNoteIgnoreFolder(this.settings, noteFile.path)) {
          continue;
        }
        const file = this.createSrTFile(noteFile);
        await this.processFile(file);
      }
      this.finaliseLoad();
    } finally {
      this._syncLock = false;
    }
  }
  createSrTFile(note) {
    return new SrTFile(this.app.vault, this.app.metadataCache, note);
  }
};

// src/data-store-algorithm/data-store-in-note-algorithm-osr.ts
var import_moment3 = __toESM(require_moment());
var DataStoreInNoteAlgorithmOsr = class {
  constructor(settings) {
    this.settings = settings;
  }
  async noteGetSchedule(note) {
    let result = null;
    const frontmatter = await note.getFrontmatter();
    if (frontmatter && frontmatter.has("sr-due") && frontmatter.has("sr-interval") && frontmatter.has("sr-ease")) {
      const dueDate = (0, import_moment3.default)(frontmatter.get("sr-due"), ALLOWED_DATE_FORMATS);
      const interval = parseFloat(frontmatter.get("sr-interval"));
      const ease = parseFloat(frontmatter.get("sr-ease"));
      result = new RepItemScheduleInfoOsr(dueDate, interval, ease);
    }
    return result;
  }
  async noteSetSchedule(note, repItemScheduleInfo) {
    let fileText = await note.read();
    const schedInfo = repItemScheduleInfo;
    const dueString = formatDateYYYYMMDD(schedInfo.dueDate);
    const interval = schedInfo.interval;
    const ease = schedInfo.latestEase;
    if (SCHEDULING_INFO_REGEX.test(fileText)) {
      const schedulingInfo = SCHEDULING_INFO_REGEX.exec(fileText);
      fileText = fileText.replace(
        SCHEDULING_INFO_REGEX,
        `---
${schedulingInfo[1]}sr-due: ${dueString}
sr-interval: ${interval}
sr-ease: ${ease}
${schedulingInfo[5]}---`
      );
    } else if (YAML_FRONT_MATTER_REGEX.test(fileText)) {
      const existingYaml = YAML_FRONT_MATTER_REGEX.exec(fileText);
      fileText = fileText.replace(
        YAML_FRONT_MATTER_REGEX,
        `---
${existingYaml[1]}sr-due: ${dueString}
sr-interval: ${interval}
sr-ease: ${ease}
---`
      );
    } else {
      fileText = `---
sr-due: ${dueString}
sr-interval: ${interval}
sr-ease: ${ease}
---

${fileText}`;
    }
    await note.write(fileText);
  }
  questionFormatScheduleAsHtmlComment(question) {
    let result = SR_HTML_COMMENT_BEGIN;
    for (let i2 = 0; i2 < question.cards.length; i2++) {
      const card = question.cards[i2];
      result += this.formatCardSchedule(card);
    }
    result += SR_HTML_COMMENT_END;
    return result;
  }
  formatCardSchedule(card) {
    let result;
    if (card.hasSchedule) {
      const schedule = card.scheduleInfo;
      const dateStr = schedule.dueDate ? formatDateYYYYMMDD(schedule.dueDate) : RepItemScheduleInfoOsr.dummyDueDateForNewCard;
      result = `!${dateStr},${schedule.interval},${schedule.latestEase}`;
    } else {
      result = `!${RepItemScheduleInfoOsr.dummyDueDateForNewCard},${RepItemScheduleInfoOsr.initialInterval},${this.settings.baseEase}`;
    }
    return result;
  }
};

// src/data-stores/notes/notes.ts
var StoreInNotes = class {
  constructor(settings) {
    this.settings = settings;
  }
  questionCreateSchedule(originalQuestionText, _2) {
    let scheduling = [
      ...originalQuestionText.matchAll(MULTI_SCHEDULING_EXTRACTOR)
    ];
    if (scheduling.length === 0)
      scheduling = [...originalQuestionText.matchAll(LEGACY_SCHEDULING_EXTRACTOR)];
    const result = [];
    for (let i2 = 0; i2 < scheduling.length; i2++) {
      const match2 = scheduling[i2];
      const dueDateStr = match2[1];
      const interval = parseInt(match2[2]);
      const ease = parseInt(match2[3]);
      const dueDate = DateUtil.dateStrToMoment(dueDateStr);
      let info;
      if (dueDate == null || formatDateYYYYMMDD(dueDate) == RepItemScheduleInfoOsr.dummyDueDateForNewCard) {
        info = null;
      } else {
        const delayBeforeReviewTicks = dueDate.valueOf() - globalDateProvider.today.valueOf();
        info = new RepItemScheduleInfoOsr(dueDate, interval, ease, delayBeforeReviewTicks);
      }
      result.push(info);
    }
    return result;
  }
  questionRemoveScheduleInfo(questionText) {
    return questionText.replace(/<!--SR:.+-->/gm, "");
  }
  async questionWriteSchedule(question) {
    await this.questionWrite(question);
  }
  async questionWrite(question) {
    const fileText = await question.note.file.read();
    const newText = question.updateQuestionWithinNoteText(fileText, this.settings);
    await question.note.file.write(newText);
    question.hasChanged = false;
  }
};

// src/gui/review-queue-list-view.tsx
var import_obsidian4 = require("obsidian");
var REVIEW_QUEUE_VIEW_TYPE = "review-queue-list-view";
var ReviewQueueListView = class extends import_obsidian4.ItemView {
  get noteReviewQueue() {
    return this.nextNoteReviewHandler.noteReviewQueue;
  }
  constructor(leaf, nextNoteReviewHandler, settings) {
    super(leaf);
    this.nextNoteReviewHandler = nextNoteReviewHandler;
    this.settings = settings;
    if (this.settings.enableNoteReviewPaneOnStartup) {
      this.registerEvent(this.app.workspace.on("file-open", () => this.redraw()));
      this.registerEvent(this.app.vault.on("rename", () => this.redraw()));
    }
  }
  getViewType() {
    return REVIEW_QUEUE_VIEW_TYPE;
  }
  getDisplayText() {
    return t("NOTES_REVIEW_QUEUE");
  }
  getIcon() {
    return "SpacedRepIcon";
  }
  onHeaderMenu(menu) {
    menu.addItem((item) => {
      item.setTitle(t("CLOSE")).setIcon("cross").onClick(() => {
        this.app.workspace.detachLeavesOfType(REVIEW_QUEUE_VIEW_TYPE);
      });
    });
  }
  redraw() {
    if (!this.noteReviewQueue.reviewDecks) return;
    const activeFile = this.app.workspace.getActiveFile();
    const rootEl = createDiv("tree-item nav-folder mod-root");
    const childrenEl = rootEl.createDiv("tree-item-children nav-folder-children");
    for (const [deckKey, deck] of this.noteReviewQueue.reviewDecks) {
      const deckCollapsed = !deck.activeFolders.has(deck.deckName);
      const deckFolderEl = this.createRightPaneFolder(
        childrenEl,
        deckKey,
        deckCollapsed,
        false,
        deck
      ).getElementsByClassName("tree-item-children nav-folder-children")[0];
      if (deck.newNotes.length > 0) {
        const newNotesFolderEl = this.createRightPaneFolder(
          deckFolderEl,
          t("NEW"),
          !deck.activeFolders.has(t("NEW")),
          deckCollapsed,
          deck
        );
        for (const newFile of deck.newNotes) {
          const fileIsOpen = activeFile && newFile.path === activeFile.path;
          if (fileIsOpen) {
            deck.activeFolders.add(deck.deckName);
            deck.activeFolders.add(t("NEW"));
            this.changeFolderFolding(newNotesFolderEl);
            this.changeFolderFolding(deckFolderEl);
          }
          this.createRightPaneFile(
            newNotesFolderEl,
            newFile.tfile,
            fileIsOpen,
            !deck.activeFolders.has(t("NEW")),
            deck
          );
        }
      }
      if (deck.scheduledNotes.length > 0) {
        const now2 = Date.now();
        let currUnix = -1;
        let schedFolderEl = null, folderTitle = "";
        const maxDaysToRender = this.settings.maxNDaysNotesReviewQueue;
        for (const sNote of deck.scheduledNotes) {
          if (sNote.dueUnix != currUnix) {
            const nDays = Math.ceil((sNote.dueUnix - now2) / TICKS_PER_DAY);
            if (nDays > maxDaysToRender) {
              break;
            }
            if (nDays === -1) {
              folderTitle = t("YESTERDAY");
            } else if (nDays === 0) {
              folderTitle = t("TODAY");
            } else if (nDays === 1) {
              folderTitle = t("TOMORROW");
            } else {
              folderTitle = new Date(sNote.dueUnix).toDateString();
            }
            schedFolderEl = this.createRightPaneFolder(
              deckFolderEl,
              folderTitle,
              !deck.activeFolders.has(folderTitle),
              deckCollapsed,
              deck
            );
            currUnix = sNote.dueUnix;
          }
          const fileIsOpen = activeFile && sNote.note.path === activeFile.path;
          if (fileIsOpen) {
            deck.activeFolders.add(deck.deckName);
            deck.activeFolders.add(folderTitle);
            this.changeFolderFolding(schedFolderEl);
            this.changeFolderFolding(deckFolderEl);
          }
          this.createRightPaneFile(
            schedFolderEl,
            sNote.note.tfile,
            fileIsOpen,
            !deck.activeFolders.has(folderTitle),
            deck
          );
        }
      }
    }
    const contentEl = this.containerEl.children[1];
    contentEl.empty();
    contentEl.appendChild(rootEl);
  }
  createRightPaneFolder(parentEl, folderTitle, collapsed, hidden, deck) {
    const folderEl = parentEl.createDiv("tree-item nav-folder");
    const folderTitleEl = folderEl.createDiv("tree-item-self nav-folder-title");
    const childrenEl = folderEl.createDiv(
      "tree-item-children nav-folder-children"
    );
    const collapseIconEl = folderTitleEl.createDiv(
      "tree-item-icon collapse-icon nav-folder-collapse-indicator"
    );
    collapseIconEl.innerHTML = COLLAPSE_ICON;
    this.changeFolderFolding(folderEl, collapsed);
    folderTitleEl.createDiv("tree-item-inner nav-folder-title-content").setText(folderTitle);
    if (hidden) {
      folderEl.style.display = "none";
    }
    folderTitleEl.onClickEvent(() => {
      this.changeFolderFolding(folderEl, !folderEl.hasClass("is-collapsed"));
      childrenEl.style.display = !folderEl.hasClass("is-collapsed") ? "block" : "none";
      if (!folderEl.hasClass("is-collapsed")) {
        deck.activeFolders.delete(folderTitle);
      } else {
        deck.activeFolders.add(folderTitle);
      }
    });
    return folderEl;
  }
  createRightPaneFile(folderEl, file, fileElActive, hidden, deck) {
    const childrenEl = folderEl.getElementsByClassName(
      "tree-item-children nav-folder-children"
    )[0];
    const navFileEl = childrenEl.createDiv("nav-file");
    if (hidden) {
      childrenEl.style.display = "none";
    }
    const navFileTitle = navFileEl.createDiv("tree-item-self nav-file-title");
    if (fileElActive) {
      navFileTitle.addClass("is-active");
    }
    navFileTitle.createDiv("tree-item-inner nav-file-title-content").setText(file.basename);
    navFileTitle.addEventListener(
      "click",
      async (event) => {
        event.preventDefault();
        await this.nextNoteReviewHandler.openNote(deck.deckName, file);
        return false;
      },
      false
    );
    navFileTitle.addEventListener(
      "contextmenu",
      (event) => {
        event.preventDefault();
        const fileMenu = new import_obsidian4.Menu();
        this.app.workspace.trigger("file-menu", fileMenu, file, "my-context-menu", null);
        fileMenu.showAtPosition({
          x: event.pageX,
          y: event.pageY
        });
        return false;
      },
      false
    );
  }
  changeFolderFolding(folderEl, collapsed = false) {
    if (collapsed) {
      folderEl.addClass("is-collapsed");
      const collapseIconEl = folderEl.find("div.nav-folder-collapse-indicator");
      collapseIconEl.addClass("is-collapsed");
    } else {
      folderEl.removeClass("is-collapsed");
      const collapseIconEl = folderEl.find("div.nav-folder-collapse-indicator");
      collapseIconEl.removeClass("is-collapsed");
    }
  }
};

// src/gui/settings.tsx
var import_obsidian6 = require("obsidian");

// node_modules/.pnpm/@kurkle+color@0.3.4/node_modules/@kurkle/color/dist/color.esm.js
function round(v2) {
  return v2 + 0.5 | 0;
}
var lim = (v2, l2, h6) => Math.max(Math.min(v2, h6), l2);
function p2b(v2) {
  return lim(round(v2 * 2.55), 0, 255);
}
function n2b(v2) {
  return lim(round(v2 * 255), 0, 255);
}
function b2n(v2) {
  return lim(round(v2 / 2.55) / 100, 0, 1);
}
function n2p(v2) {
  return lim(round(v2 * 100), 0, 100);
}
var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var hex = [..."0123456789ABCDEF"];
var h1 = (b2) => hex[b2 & 15];
var h2 = (b2) => hex[(b2 & 240) >> 4] + hex[b2 & 15];
var eq = (b2) => (b2 & 240) >> 4 === (b2 & 15);
var isShort = (v2) => eq(v2.r) && eq(v2.g) && eq(v2.b) && eq(v2.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
var alpha = (a2, f2) => a2 < 255 ? f2(a2) : "";
function hexString(v2) {
  var f2 = isShort(v2) ? h1 : h2;
  return v2 ? "#" + f2(v2.r) + f2(v2.g) + f2(v2.b) + alpha(v2.a, f2) : void 0;
}
var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h6, s2, l2) {
  const a2 = s2 * Math.min(l2, 1 - l2);
  const f2 = (n2, k = (n2 + h6 / 30) % 12) => l2 - a2 * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f2(0), f2(8), f2(4)];
}
function hsv2rgbn(h6, s2, v2) {
  const f2 = (n2, k = (n2 + h6 / 60) % 6) => v2 - v2 * s2 * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f2(5), f2(3), f2(1)];
}
function hwb2rgbn(h6, w2, b2) {
  const rgb = hsl2rgbn(h6, 1, 0.5);
  let i2;
  if (w2 + b2 > 1) {
    i2 = 1 / (w2 + b2);
    w2 *= i2;
    b2 *= i2;
  }
  for (i2 = 0; i2 < 3; i2++) {
    rgb[i2] *= 1 - w2 - b2;
    rgb[i2] += w2;
  }
  return rgb;
}
function hueValue(r2, g2, b2, d2, max) {
  if (r2 === max) {
    return (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
  }
  if (g2 === max) {
    return (b2 - r2) / d2 + 2;
  }
  return (r2 - g2) / d2 + 4;
}
function rgb2hsl(v2) {
  const range = 255;
  const r2 = v2.r / range;
  const g2 = v2.g / range;
  const b2 = v2.b / range;
  const max = Math.max(r2, g2, b2);
  const min = Math.min(r2, g2, b2);
  const l2 = (max + min) / 2;
  let h6, s2, d2;
  if (max !== min) {
    d2 = max - min;
    s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
    h6 = hueValue(r2, g2, b2, d2, max);
    h6 = h6 * 60 + 0.5;
  }
  return [h6 | 0, s2 || 0, l2];
}
function calln(f2, a2, b2, c2) {
  return (Array.isArray(a2) ? f2(a2[0], a2[1], a2[2]) : f2(a2, b2, c2)).map(n2b);
}
function hsl2rgb(h6, s2, l2) {
  return calln(hsl2rgbn, h6, s2, l2);
}
function hwb2rgb(h6, w2, b2) {
  return calln(hwb2rgbn, h6, w2, b2);
}
function hsv2rgb(h6, s2, v2) {
  return calln(hsv2rgbn, h6, s2, v2);
}
function hue(h6) {
  return (h6 % 360 + 360) % 360;
}
function hueParse(str) {
  const m2 = HUE_RE.exec(str);
  let a2 = 255;
  let v2;
  if (!m2) {
    return;
  }
  if (m2[5] !== v2) {
    a2 = m2[6] ? p2b(+m2[5]) : n2b(+m2[5]);
  }
  const h6 = hue(+m2[2]);
  const p1 = +m2[3] / 100;
  const p2 = +m2[4] / 100;
  if (m2[1] === "hwb") {
    v2 = hwb2rgb(h6, p1, p2);
  } else if (m2[1] === "hsv") {
    v2 = hsv2rgb(h6, p1, p2);
  } else {
    v2 = hsl2rgb(h6, p1, p2);
  }
  return {
    r: v2[0],
    g: v2[1],
    b: v2[2],
    a: a2
  };
}
function rotate(v2, deg) {
  var h6 = rgb2hsl(v2);
  h6[0] = hue(h6[0] + deg);
  h6 = hsl2rgb(h6);
  v2.r = h6[0];
  v2.g = h6[1];
  v2.b = h6[2];
}
function hslString(v2) {
  if (!v2) {
    return;
  }
  const a2 = rgb2hsl(v2);
  const h6 = a2[0];
  const s2 = n2p(a2[1]);
  const l2 = n2p(a2[2]);
  return v2.a < 255 ? `hsla(${h6}, ${s2}%, ${l2}%, ${b2n(v2.a)})` : `hsl(${h6}, ${s2}%, ${l2}%)`;
}
var map = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map);
  let i2, j2, k, ok, nk;
  for (i2 = 0; i2 < keys.length; i2++) {
    ok = nk = keys[i2];
    for (j2 = 0; j2 < tkeys.length; j2++) {
      k = tkeys[j2];
      nk = nk.replace(k, map[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
var names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a2 = names[str.toLowerCase()];
  return a2 && {
    r: a2[0],
    g: a2[1],
    b: a2[2],
    a: a2.length === 4 ? a2[3] : 255
  };
}
var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m2 = RGB_RE.exec(str);
  let a2 = 255;
  let r2, g2, b2;
  if (!m2) {
    return;
  }
  if (m2[7] !== r2) {
    const v2 = +m2[7];
    a2 = m2[8] ? p2b(v2) : lim(v2 * 255, 0, 255);
  }
  r2 = +m2[1];
  g2 = +m2[3];
  b2 = +m2[5];
  r2 = 255 & (m2[2] ? p2b(r2) : lim(r2, 0, 255));
  g2 = 255 & (m2[4] ? p2b(g2) : lim(g2, 0, 255));
  b2 = 255 & (m2[6] ? p2b(b2) : lim(b2, 0, 255));
  return {
    r: r2,
    g: g2,
    b: b2,
    a: a2
  };
}
function rgbString(v2) {
  return v2 && (v2.a < 255 ? `rgba(${v2.r}, ${v2.g}, ${v2.b}, ${b2n(v2.a)})` : `rgb(${v2.r}, ${v2.g}, ${v2.b})`);
}
var to = (v2) => v2 <= 31308e-7 ? v2 * 12.92 : Math.pow(v2, 1 / 2.4) * 1.055 - 0.055;
var from = (v2) => v2 <= 0.04045 ? v2 / 12.92 : Math.pow((v2 + 0.055) / 1.055, 2.4);
function interpolate2(rgb1, rgb2, t3) {
  const r2 = from(b2n(rgb1.r));
  const g2 = from(b2n(rgb1.g));
  const b2 = from(b2n(rgb1.b));
  return {
    r: n2b(to(r2 + t3 * (from(b2n(rgb2.r)) - r2))),
    g: n2b(to(g2 + t3 * (from(b2n(rgb2.g)) - g2))),
    b: n2b(to(b2 + t3 * (from(b2n(rgb2.b)) - b2))),
    a: rgb1.a + t3 * (rgb2.a - rgb1.a)
  };
}
function modHSL(v2, i2, ratio) {
  if (v2) {
    let tmp = rgb2hsl(v2);
    tmp[i2] = Math.max(0, Math.min(tmp[i2] + tmp[i2] * ratio, i2 === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v2.r = tmp[0];
    v2.g = tmp[1];
    v2.b = tmp[2];
  }
}
function clone(v2, proto) {
  return v2 ? Object.assign(proto || {}, v2) : v2;
}
function fromObject(input) {
  var v2 = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v2 = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v2.a = n2b(input[3]);
      }
    }
  } else {
    v2 = clone(input, { r: 0, g: 0, b: 0, a: 1 });
    v2.a = n2b(v2.a);
  }
  return v2;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
var Color = class _Color {
  constructor(input) {
    if (input instanceof _Color) {
      return input;
    }
    const type = typeof input;
    let v2;
    if (type === "object") {
      v2 = fromObject(input);
    } else if (type === "string") {
      v2 = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v2;
    this._valid = !!v2;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v2 = clone(this._rgb);
    if (v2) {
      v2.a = b2n(v2.a);
    }
    return v2;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color2, weight) {
    if (color2) {
      const c1 = this.rgb;
      const c2 = color2.rgb;
      let w2;
      const p2 = weight === w2 ? 0.5 : weight;
      const w3 = 2 * p2 - 1;
      const a2 = c1.a - c2.a;
      const w1 = ((w3 * a2 === -1 ? w3 : (w3 + a2) / (1 + w3 * a2)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p2 * c1.a + (1 - p2) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color2, t3) {
    if (color2) {
      this._rgb = interpolate2(this._rgb, color2._rgb, t3);
    }
    return this;
  }
  clone() {
    return new _Color(this.rgb);
  }
  alpha(a2) {
    this._rgb.a = n2b(a2);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v2 = this._rgb;
    v2.r = 255 - v2.r;
    v2.g = 255 - v2.g;
    v2.b = 255 - v2.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};

// node_modules/.pnpm/chart.js@4.4.8/node_modules/chart.js/dist/chunks/helpers.segment.js
function noop() {
}
var uid = /* @__PURE__ */ (() => {
  let id = 0;
  return () => id++;
})();
function isNullOrUndef(value) {
  return value === null || value === void 0;
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
function isNumberFinite(value) {
  return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn2, args, thisArg) {
  if (fn2 && typeof fn2.call === "function") {
    return fn2.apply(thisArg, args);
  }
}
function each(loopable, fn2, thisArg, reverse) {
  let i2, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i2 = len - 1; i2 >= 0; i2--) {
        fn2.call(thisArg, loopable[i2], i2);
      }
    } else {
      for (i2 = 0; i2 < len; i2++) {
        fn2.call(thisArg, loopable[i2], i2);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i2 = 0; i2 < len; i2++) {
      fn2.call(thisArg, loopable[keys[i2]], keys[i2]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i2, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i2 = 0, ilen = a0.length; i2 < ilen; ++i2) {
    v0 = a0[i2];
    v1 = a1[i2];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone2(source) {
  if (isArray(source)) {
    return source.map(clone2);
  }
  if (isObject(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone2(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone2(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [
    source
  ];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  let current;
  for (let i2 = 0; i2 < ilen; ++i2) {
    current = sources[i2];
    if (!isObject(current)) {
      continue;
    }
    const keys = Object.keys(current);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, current, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, {
    merger: _mergerIf
  });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone2(sval);
  }
}
var keyResolvers = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (v2) => v2,
  // default resolvers
  x: (o2) => o2.x,
  y: (o2) => o2.y
};
function _splitKey(key) {
  const parts = key.split(".");
  const keys = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys.push(tmp);
      tmp = "";
    }
  }
  return keys;
}
function _getKeyResolver(key) {
  const keys = _splitKey(key);
  return (obj) => {
    for (const k of keys) {
      if (k === "") {
        break;
      }
      obj = obj && obj[k];
    }
    return obj;
  };
}
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = (value) => typeof value !== "undefined";
var isFunction = (value) => typeof value === "function";
var setsEqual = (a2, b2) => {
  if (a2.size !== b2.size) {
    return false;
  }
  for (const item of a2) {
    if (!b2.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e2) {
  return e2.type === "mouseup" || e2.type === "click" || e2.type === "contextmenu";
}
var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;
var log10 = Math.log10;
var sign = Math.sign;
function almostEquals(x2, y2, epsilon) {
  return Math.abs(x2 - y2) < epsilon;
}
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i2;
  for (i2 = 1; i2 < sqrt; i2++) {
    if (value % i2 === 0) {
      result.push(i2);
      result.push(value / i2);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a2, b2) => a2 - b2).pop();
  return result;
}
function isNonPrimitive(n2) {
  return typeof n2 === "symbol" || typeof n2 === "object" && n2 !== null && !(Symbol.toPrimitive in n2 || "toString" in n2 || "valueOf" in n2);
}
function isNumber(n2) {
  return !isNonPrimitive(n2) && !isNaN(parseFloat(n2)) && isFinite(n2);
}
function almostWhole(x2, epsilon) {
  const rounded = Math.round(x2);
  return rounded - epsilon <= x2 && rounded + epsilon >= x2;
}
function _setMinAndMaxByKey(array, target, property) {
  let i2, ilen, value;
  for (i2 = 0, ilen = array.length; i2 < ilen; i2++) {
    value = array[i2][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x2) {
  if (!isNumberFinite(x2)) {
    return;
  }
  let e2 = 1;
  let p2 = 0;
  while (Math.round(x2 * e2) / e2 !== x2) {
    e2 *= 10;
    p2++;
  }
  return p2;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _normalizeAngle(a2) {
  return (a2 % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a2 = _normalizeAngle(angle);
  const s2 = _normalizeAngle(start);
  const e2 = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s2 - a2);
  const angleToEnd = _normalizeAngle(e2 - a2);
  const startToAngle = _normalizeAngle(a2 - s2);
  const endToAngle = _normalizeAngle(a2 - e2);
  return a2 === s2 || a2 === e2 || sameAngleIsFullCircle && s2 === e2 || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index) => table[index] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {
    lo,
    hi
  };
}
var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index) => {
  const ti = table[index][key];
  return ti < value || ti === value && table[index + 1][key] === value;
} : (index) => table[index][key] < value);
var _rlookupByKey = (table, key, value) => _lookup(table, value, (index) => table[index][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
var arrayEvents = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [
        listener
      ]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index = listeners.indexOf(listener);
  if (index !== -1) {
    listeners.splice(index, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set2 = new Set(items);
  if (set2.size === items.length) {
    return items;
  }
  return Array.from(set2);
}
var requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn2, thisArg) {
  let argsToUse = [];
  let ticking = false;
  return function(...args) {
    argsToUse = args;
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn2.apply(thisArg, argsToUse);
      });
    }
  };
}
function debounce(fn2, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn2, delay, args);
    } else {
      fn2.apply(this, args);
    }
    return delay;
  };
}
var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
var _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
var atEdge = (t3) => t3 === 0 || t3 === 1;
var elasticIn = (t3, s2, p2) => -(Math.pow(2, 10 * (t3 -= 1)) * Math.sin((t3 - s2) * TAU / p2));
var elasticOut = (t3, s2, p2) => Math.pow(2, -10 * t3) * Math.sin((t3 - s2) * TAU / p2) + 1;
var effects = {
  linear: (t3) => t3,
  easeInQuad: (t3) => t3 * t3,
  easeOutQuad: (t3) => -t3 * (t3 - 2),
  easeInOutQuad: (t3) => (t3 /= 0.5) < 1 ? 0.5 * t3 * t3 : -0.5 * (--t3 * (t3 - 2) - 1),
  easeInCubic: (t3) => t3 * t3 * t3,
  easeOutCubic: (t3) => (t3 -= 1) * t3 * t3 + 1,
  easeInOutCubic: (t3) => (t3 /= 0.5) < 1 ? 0.5 * t3 * t3 * t3 : 0.5 * ((t3 -= 2) * t3 * t3 + 2),
  easeInQuart: (t3) => t3 * t3 * t3 * t3,
  easeOutQuart: (t3) => -((t3 -= 1) * t3 * t3 * t3 - 1),
  easeInOutQuart: (t3) => (t3 /= 0.5) < 1 ? 0.5 * t3 * t3 * t3 * t3 : -0.5 * ((t3 -= 2) * t3 * t3 * t3 - 2),
  easeInQuint: (t3) => t3 * t3 * t3 * t3 * t3,
  easeOutQuint: (t3) => (t3 -= 1) * t3 * t3 * t3 * t3 + 1,
  easeInOutQuint: (t3) => (t3 /= 0.5) < 1 ? 0.5 * t3 * t3 * t3 * t3 * t3 : 0.5 * ((t3 -= 2) * t3 * t3 * t3 * t3 + 2),
  easeInSine: (t3) => -Math.cos(t3 * HALF_PI) + 1,
  easeOutSine: (t3) => Math.sin(t3 * HALF_PI),
  easeInOutSine: (t3) => -0.5 * (Math.cos(PI * t3) - 1),
  easeInExpo: (t3) => t3 === 0 ? 0 : Math.pow(2, 10 * (t3 - 1)),
  easeOutExpo: (t3) => t3 === 1 ? 1 : -Math.pow(2, -10 * t3) + 1,
  easeInOutExpo: (t3) => atEdge(t3) ? t3 : t3 < 0.5 ? 0.5 * Math.pow(2, 10 * (t3 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t3 * 2 - 1)) + 2),
  easeInCirc: (t3) => t3 >= 1 ? t3 : -(Math.sqrt(1 - t3 * t3) - 1),
  easeOutCirc: (t3) => Math.sqrt(1 - (t3 -= 1) * t3),
  easeInOutCirc: (t3) => (t3 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t3 * t3) - 1) : 0.5 * (Math.sqrt(1 - (t3 -= 2) * t3) + 1),
  easeInElastic: (t3) => atEdge(t3) ? t3 : elasticIn(t3, 0.075, 0.3),
  easeOutElastic: (t3) => atEdge(t3) ? t3 : elasticOut(t3, 0.075, 0.3),
  easeInOutElastic(t3) {
    const s2 = 0.1125;
    const p2 = 0.45;
    return atEdge(t3) ? t3 : t3 < 0.5 ? 0.5 * elasticIn(t3 * 2, s2, p2) : 0.5 + 0.5 * elasticOut(t3 * 2 - 1, s2, p2);
  },
  easeInBack(t3) {
    const s2 = 1.70158;
    return t3 * t3 * ((s2 + 1) * t3 - s2);
  },
  easeOutBack(t3) {
    const s2 = 1.70158;
    return (t3 -= 1) * t3 * ((s2 + 1) * t3 + s2) + 1;
  },
  easeInOutBack(t3) {
    let s2 = 1.70158;
    if ((t3 /= 0.5) < 1) {
      return 0.5 * (t3 * t3 * (((s2 *= 1.525) + 1) * t3 - s2));
    }
    return 0.5 * ((t3 -= 2) * t3 * (((s2 *= 1.525) + 1) * t3 + s2) + 2);
  },
  easeInBounce: (t3) => 1 - effects.easeOutBounce(1 - t3),
  easeOutBounce(t3) {
    const m2 = 7.5625;
    const d2 = 2.75;
    if (t3 < 1 / d2) {
      return m2 * t3 * t3;
    }
    if (t3 < 2 / d2) {
      return m2 * (t3 -= 1.5 / d2) * t3 + 0.75;
    }
    if (t3 < 2.5 / d2) {
      return m2 * (t3 -= 2.25 / d2) * t3 + 0.9375;
    }
    return m2 * (t3 -= 2.625 / d2) * t3 + 0.984375;
  },
  easeInOutBounce: (t3) => t3 < 0.5 ? effects.easeInBounce(t3 * 2) * 0.5 : effects.easeOutBounce(t3 * 2 - 1) * 0.5 + 0.5
};
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function color(value) {
  return isPatternOrGradient(value) ? value : new Color(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
}
var numbers = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
];
var colors = [
  "color",
  "borderColor",
  "backgroundColor"
];
function applyAnimationsDefaults(defaults3) {
  defaults3.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  defaults3.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
  });
  defaults3.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults3.describe("animations", {
    _fallback: "animation"
  });
  defaults3.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v2) => v2 | 0
        }
      }
    }
  });
}
function applyLayoutsDefaults(defaults3) {
  defaults3.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
var intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale2, options) {
  options = options || {};
  const cacheKey = locale2 + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale2, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale2, options) {
  return getNumberFormat(locale2, options).format(num);
}
var formatters = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale2 = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale2, options);
  },
  logarithmic(tickValue, index, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if ([
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(remain) || index > 0.8 * ticks.length) {
      return formatters.numeric.call(this, tickValue, index, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {
  formatters
};
function applyScaleDefaults(defaults3) {
  defaults3.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    clip: true,
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults3.route("scale.ticks", "color", "", "color");
  defaults3.route("scale.grid", "color", "", "borderColor");
  defaults3.route("scale.border", "color", "", "borderColor");
  defaults3.route("scale.title", "color", "", "color");
  defaults3.describe("scale", {
    _fallback: false,
    _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
    _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
  });
  defaults3.describe("scales", {
    _fallback: "scale"
  });
  defaults3.describe("scale.ticks", {
    _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
    _indexable: (name) => name !== "backdropPadding"
  });
}
var overrides = /* @__PURE__ */ Object.create(null);
var descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split(".");
  for (let i2 = 0, n2 = keys.length; i2 < n2; ++i2) {
    const k = keys[i2];
    node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ""), scope);
}
var Defaults = class {
  constructor(_descriptors2, _appliers) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
    this.apply(_appliers);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
  apply(appliers) {
    appliers.forEach((apply) => apply(this));
  }
};
var defaults2 = /* @__PURE__ */ new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  applyAnimationsDefaults,
  applyLayoutsDefaults,
  applyScaleDefaults
]);
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i2, j2, jlen, thing, nestedThing;
  for (i2 = 0; i2 < ilen; i2++) {
    thing = arrayOfThings[i2];
    if (thing !== void 0 && thing !== null && !isArray(thing)) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j2 = 0, jlen = thing.length; j2 < jlen; j2++) {
        nestedThing = thing[j2];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i2 = 0; i2 < gcLen; i2++) {
      delete data[gc[i2]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  if (!ctx && !canvas) {
    return;
  }
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x2, y2) {
  drawPointLegend(ctx, options, x2, y2, null);
}
function drawPointLegend(ctx, options, x2, y2, w2) {
  let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x2, y2);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    // Default includes circle
    default:
      if (w2) {
        ctx.ellipse(x2, y2, w2 / 2, radius, 0, 0, TAU);
      } else {
        ctx.arc(x2, y2, radius, 0, TAU);
      }
      ctx.closePath();
      break;
    case "triangle":
      width = w2 ? w2 / 2 : radius;
      ctx.moveTo(x2 + Math.sin(rad) * width, y2 - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x2 + Math.sin(rad) * width, y2 - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x2 + Math.sin(rad) * width, y2 - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      xOffsetW = Math.cos(rad + QUARTER_PI) * (w2 ? w2 / 2 - cornerRadius : size);
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      yOffsetW = Math.sin(rad + QUARTER_PI) * (w2 ? w2 / 2 - cornerRadius : size);
      ctx.arc(x2 - xOffsetW, y2 - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x2 + yOffsetW, y2 - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x2 + xOffsetW, y2 + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x2 - yOffsetW, y2 + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        width = w2 ? w2 / 2 : size;
        ctx.rect(x2 - width, y2 - size, 2 * width, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    /* falls through */
    case "rectRot":
      xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
      ctx.moveTo(x2 - xOffsetW, y2 - yOffset);
      ctx.lineTo(x2 + yOffsetW, y2 - xOffset);
      ctx.lineTo(x2 + xOffsetW, y2 + yOffset);
      ctx.lineTo(x2 - yOffsetW, y2 + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    /* falls through */
    case "cross":
      xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
      ctx.moveTo(x2 - xOffsetW, y2 - yOffset);
      ctx.lineTo(x2 + xOffsetW, y2 + yOffset);
      ctx.moveTo(x2 + yOffsetW, y2 - xOffset);
      ctx.lineTo(x2 - yOffsetW, y2 + xOffset);
      break;
    case "star":
      xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
      ctx.moveTo(x2 - xOffsetW, y2 - yOffset);
      ctx.lineTo(x2 + xOffsetW, y2 + yOffset);
      ctx.moveTo(x2 + yOffsetW, y2 - xOffset);
      ctx.lineTo(x2 - yOffsetW, y2 + xOffset);
      rad += QUARTER_PI;
      xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
      ctx.moveTo(x2 - xOffsetW, y2 - yOffset);
      ctx.lineTo(x2 + xOffsetW, y2 + yOffset);
      ctx.moveTo(x2 + yOffsetW, y2 - xOffset);
      ctx.lineTo(x2 - yOffsetW, y2 + xOffset);
      break;
    case "line":
      xOffset = w2 ? w2 / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x2 - xOffset, y2 - yOffset);
      ctx.lineTo(x2 + xOffset, y2 + yOffset);
      break;
    case "dash":
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 + Math.cos(rad) * (w2 ? w2 / 2 : radius), y2 + Math.sin(rad) * radius);
      break;
    case false:
      ctx.closePath();
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x2, y2, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x2 - metrics.actualBoundingBoxLeft;
    const right = x2 + metrics.actualBoundingBoxRight;
    const top = y2 - metrics.actualBoundingBoxAscent;
    const bottom = y2 + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function drawBackdrop(ctx, opts) {
  const oldColor = ctx.fillStyle;
  ctx.fillStyle = opts.color;
  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx.fillStyle = oldColor;
}
function renderText(ctx, text, x2, y2, font, opts = {}) {
  const lines = isArray(text) ? text : [
    text
  ];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i2, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i2 = 0; i2 < lines.length; ++i2) {
    line = lines[i2];
    if (opts.backdrop) {
      drawBackdrop(ctx, opts.backdrop);
    }
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x2, y2, opts.maxWidth);
    }
    ctx.fillText(line, x2, y2, opts.maxWidth);
    decorateText(ctx, x2, y2, line, opts);
    y2 += Number(font.lineHeight);
  }
  ctx.restore();
}
function addRoundedRectPath(ctx, rect) {
  const { x: x2, y: y2, w: w2, h: h6, radius } = rect;
  ctx.arc(x2 + radius.topLeft, y2 + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
  ctx.lineTo(x2, y2 + h6 - radius.bottomLeft);
  ctx.arc(x2 + radius.bottomLeft, y2 + h6 - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x2 + w2 - radius.bottomRight, y2 + h6);
  ctx.arc(x2 + w2 - radius.bottomRight, y2 + h6 - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x2 + w2, y2 + radius.topRight);
  ctx.arc(x2 + w2 - radius.topRight, y2 + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x2 + radius.topLeft, y2);
}
var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function toLineHeight(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
var numberOrZero = (v2) => +v2 || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults2.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = void 0;
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index, info) {
  let cacheable = true;
  let i2, ilen, value;
  for (i2 = 0, ilen = inputs.length; i2 < ilen; ++i2) {
    value = inputs[i2];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index !== void 0 && isArray(value)) {
      value = value[index % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _createResolver(scopes, prefixes = [
  ""
], rootScopes, fallback, getTarget = () => scopes[0]) {
  const finalRootScopes = rootScopes || scopes;
  if (typeof fallback === "undefined") {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: finalRootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([
      scope,
      ...scopes
    ], prefixes, finalRootScopes, fallback)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
        enumerable: true,
        configurable: true
      } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults3 = {
  scriptable: true,
  indexable: true
}) {
  const { _scriptable = defaults3.scriptable, _indexable = defaults3.indexable, _allKeys = defaults3.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop) || prop === "constructor") {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, getValue, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  let value = getValue(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (typeof _context.index !== "undefined" && isIndexable(prop)) {
    return value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s2) => s2 !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [
    ...parentScopes,
    ...rootScopes
  ];
  const set2 = /* @__PURE__ */ new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (typeof fallback !== "undefined" && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [
    ""
  ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (typeof value !== "undefined") {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (typeof value !== "undefined") {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = /* @__PURE__ */ new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
var EPSILON = Number.EPSILON || 1e-14;
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
var getComputedStyle2 = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle2(el).getPropertyValue(property);
}
var positions = [
  "top",
  "right",
  "bottom",
  "left"
];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i2 = 0; i2 < 4; i2++) {
    const pos = positions[i2];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
var useOffsetPos = (x2, y2, target) => (x2 > 0 || y2 > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e2, canvas) {
  const touches = e2.touches;
  const source = touches && touches.length ? touches[0] : e2;
  const { offsetX, offsetY } = source;
  let box = false;
  let x2, y2;
  if (useOffsetPos(offsetX, offsetY, e2.target)) {
    x2 = offsetX;
    y2 = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x2 = source.clientX - rect.left;
    y2 = source.clientY - rect.top;
    box = true;
  }
  return {
    x: x2,
    y: y2,
    box
  };
}
function getRelativePosition(event, chart) {
  if ("native" in event) {
    return event;
  }
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle2(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x: x2, y: y2, box } = getCanvasPosition(event, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x2 - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y2 - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = canvas && _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle2(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
var round1 = (v2) => Math.round(v2 * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle2(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
    height = containerSize.height;
    width = round1(Math.floor(height * aspectRatio));
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = Math.floor(chart.height);
  chart.width = Math.floor(chart.width);
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
var supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    if (_isDomSupported()) {
      window.addEventListener("test", null, options);
      window.removeEventListener("test", null, options);
    }
  } catch (e2) {
  }
  return passiveSupported;
}();
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
var getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x2) {
      return rectX + rectX + width - x2;
    },
    setWidth(w2) {
      width = w2;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x2, value) {
      return x2 - value;
    },
    leftForLtr(x2, itemWidth) {
      return x2 - itemWidth;
    }
  };
};
var getLeftToRightAdapter = function() {
  return {
    x(x2) {
      return x2;
    },
    setWidth(w2) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x2, value) {
      return x2 + value;
    },
    leftForLtr(x2, _itemWidth) {
      return x2;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}

// node_modules/.pnpm/chart.js@4.4.8/node_modules/chart.js/dist/chart.js
var Animator = class {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn2) => fn2({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i2 = items.length - 1;
      let draw = false;
      let item;
      for (; i2 >= 0; --i2) {
        item = items[i2];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw = true;
        } else {
          items[i2] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i2 = items.length - 1;
    for (; i2 >= 0; --i2) {
      items[i2].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
};
var animator = /* @__PURE__ */ new Animator();
var transparent = "transparent";
var interpolators = {
  boolean(from2, to2, factor) {
    return factor > 0.5 ? to2 : from2;
  },
  color(from2, to2, factor) {
    const c0 = color(from2 || transparent);
    const c1 = c0.valid && color(to2 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
  },
  number(from2, to2, factor) {
    return from2 + (to2 - from2) * factor;
  }
};
var Animation = class {
  constructor(cfg, target, prop, to2) {
    const currentValue = target[prop];
    to2 = resolve([
      cfg.to,
      to2,
      currentValue,
      cfg.from
    ]);
    const from2 = resolve([
      cfg.from,
      currentValue,
      to2
    ]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from2;
    this._to = to2;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to2, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      this._from = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop = this._loop;
    const to2 = this._to;
    let factor;
    this._active = from2 !== to2 && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to2;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to2, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({
        res,
        rej
      });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i2 = 0; i2 < promises.length; i2++) {
      promises[i2][method]();
    }
  }
};
var Animations = class {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animationOptions = Object.keys(defaults2.animation);
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [
        key
      ]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i2;
    for (i2 = props.length - 1; i2 >= 0; --i2) {
      const prop = props[i2];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
};
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i2 = 0; i2 < keys.length; i2++) {
    const anim = animations[keys[i2]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {
      $shared: false,
      $animations: {}
    });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x2 = scaleClip(xScale, allowedOverflow);
  const y2 = scaleClip(yScale, allowedOverflow);
  return {
    top: y2.end,
    right: x2.end,
    bottom: y2.start,
    left: x2.start
  };
}
function toClip(value) {
  let t3, r2, b2, l2;
  if (isObject(value)) {
    t3 = value.top;
    r2 = value.right;
    b2 = value.bottom;
    l2 = value.left;
  } else {
    t3 = r2 = b2 = l2 = value;
  }
  return {
    top: t3,
    right: r2,
    bottom: b2,
    left: l2,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i2, ilen;
  for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
    keys.push(metasets[i2].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === "single";
  let i2, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  let found = false;
  for (i2 = 0, ilen = keys.length; i2 < ilen; ++i2) {
    datasetIndex = +keys[i2];
    if (datasetIndex === dsIndex) {
      found = true;
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
      value += otherValue;
    }
  }
  if (!found && !options.all) {
    return 0;
  }
  return value;
}
function convertObjectDataToArray(data, meta) {
  const { iScale, vScale } = meta;
  const iAxisKey = iScale.axis === "x" ? "x" : "y";
  const vAxisKey = vScale.axis === "x" ? "x" : "y";
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i2, ilen, key;
  for (i2 = 0, ilen = keys.length; i2 < ilen; ++i2) {
    key = keys[i2];
    adata[i2] = {
      [iAxisKey]: key,
      [vAxisKey]: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min, max, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i2 = 0; i2 < ilen; ++i2) {
    const item = parsed[i2];
    const { [iAxis]: index, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
    const visualValues = stack._visualValues || (stack._visualValues = {});
    visualValues[datasetIndex] = value;
  }
}
function getFirstScaleId(chart, axis) {
  const scales = chart.scales;
  return Object.keys(scales).filter((key) => scales[key].axis === axis).shift();
}
function createDatasetContext(parent, index) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index,
    index,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index,
    parsed: void 0,
    raw: void 0,
    element,
    index,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
    if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
      delete stacks[axis]._visualValues[datasetIndex];
    }
  }
}
var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
  keys: getSortedDatasetIndices(chart, true),
  values: null
};
var DatasetController = class {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.datasetElementType = new.target.datasetElementType;
    this.dataElementType = new.target.dataElementType;
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
    if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
      console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x2, y2, r2) => axis === "x" ? x2 : axis === "r" ? r2 : y2;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      const meta = this._cachedMeta;
      this._data = convertObjectDataToArray(data, meta);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
      meta._stacked = isStacked(meta.vScale, meta);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i2, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i2 = 0; i2 < count; ++i2) {
        meta._parsed[i2 + start] = cur = parsed[i2];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i2, ilen, index;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      index = i2 + start;
      parsed[i2] = {
        [iAxis]: singleScale || iScale.parse(labels[index], index),
        [vAxis]: vScale.parse(data[index], index)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i2, ilen, index, item;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      index = i2 + start;
      item = data[index];
      parsed[i2] = {
        x: xScale.parse(item[0], index),
        y: yScale.parse(item[1], index)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i2, ilen, index, item;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      index = i2 + start;
      item = data[index];
      parsed[i2] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
      };
    }
    return parsed;
  }
  getParsed(index) {
    return this._cachedMeta._parsed[index];
  }
  getDataElement(index) {
    return this._cachedMeta.data[index];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]._visualValues
    };
    return applyStack(stack, value, meta.index, {
      mode
    });
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i2, parsed;
    function _skip() {
      parsed = _parsed[i2];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i2 = 0; i2 < ilen; ++i2) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i2 = ilen - 1; i2 >= 0; --i2) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i2, ilen, value;
    for (i2 = 0, ilen = parsed.length; i2 < ilen; ++i2) {
      value = parsed[i2][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i2;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i2 = start; i2 < start + count; ++i2) {
      const element = elements[i2];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i2 = 0; i2 < active.length; ++i2) {
      active[i2].draw(ctx, area);
    }
  }
  getStyle(index, active) {
    const mode = active ? "active" : "default";
    return index === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
  }
  getContext(index, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index >= 0 && index < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
      context.parsed = this.getParsed(index);
      context.raw = dataset.data[index];
      context.index = context.dataIndex = index;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index);
  }
  _resolveElementOptions(elementType, mode = "default", index) {
    const active = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [
      `${elementType}Hover`,
      "hover",
      elementType,
      ""
    ] : [
      elementType,
      ""
    ];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults2.elements[elementType]);
    const context = () => this.getContext(index, active, mode);
    const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start, mode) {
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return {
      sharedOptions,
      includeOptions
    };
  }
  updateElement(element, index, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index, mode, active) {
    element.active = active;
    const options = this.getStyle(index, active);
    this._resolveAnimations(index, mode, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, "active", false);
  }
  setHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i2;
    const move = (arr) => {
      arr.length += count;
      for (i2 = arr.length - 1; i2 >= end; i2--) {
        arr[i2] = arr[i2 - count];
      }
    };
    move(data);
    for (i2 = start; i2 < end; ++i2) {
      data[i2] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([
      this.index,
      ...args
    ]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - count,
      count
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync([
        "_removeElements",
        start,
        count
      ]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync([
        "_insertElements",
        start,
        newCount
      ]);
    }
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
};
__publicField(DatasetController, "defaults", {});
__publicField(DatasetController, "datasetElementType", null);
__publicField(DatasetController, "dataElementType", null);
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i2 = 0, ilen = visibleMetas.length; i2 < ilen; i2++) {
      values = values.concat(visibleMetas[i2].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a2, b2) => a2 - b2));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i2, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i2 = 0, ilen = values.length; i2 < ilen; ++i2) {
    curr = scale.getPixelForValue(values[i2]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i2 = 0, ilen = scale.ticks.length; i2 < ilen; ++i2) {
    curr = scale.getPixelForTick(i2);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index] - size / 2
  };
}
function computeFlexCategoryTraits(index, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index];
  let prev = index > 0 ? pixels[index - 1] : null;
  let next = index < pixels.length - 1 ? pixels[index + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i2) {
  const startValue = vScale.parse(entry[0], i2);
  const endValue = vScale.parse(entry[1], i2);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i2) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i2);
  } else {
    item[vScale.axis] = vScale.parse(entry, i2);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i2, ilen, item, entry;
  for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
    entry = data[i2];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i2], i2);
    parsed.push(parseValue(entry, item, vScale, i2));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return {
    start,
    end,
    reverse,
    top,
    bottom
  };
}
function setBorderSkipped(properties, options, stack, index) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = {
      top: true,
      right: true,
      bottom: true,
      left: true
    };
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index) {
      edge = top;
    } else if ((stack._bottom || 0) === index) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a2, b2, reverse) {
  if (reverse) {
    edge = swap(edge, a2, b2);
    edge = startEnd(edge, b2, a2);
  } else {
    edge = startEnd(edge, a2, b2);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v2, start, end) {
  return v2 === "start" ? start : v2 === "end" ? end : v2;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
var BarController = class extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i2, ilen, item, obj;
    for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
      obj = data[i2];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i2);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i2));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset2 = mode === "reset";
    const { index, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    for (let i2 = start; i2 < start + count; i2++) {
      const parsed = this.getParsed(i2);
      const vpixels = reset2 || isNullOrUndef(parsed[vScale.axis]) ? {
        base,
        head: base
      } : this._calculateBarValuePixels(i2);
      const ipixels = this._calculateBarIndexPixels(i2, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, bars[i2].active ? "active" : mode);
      }
      const options = properties.options || bars[i2].options;
      setBorderSkipped(properties, options, stack, index);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i2], i2, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const { iScale } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);
    const iScaleValue = currentParsed && currentParsed[iScale.axis];
    const skipNull = (meta) => {
      const parsed = meta._parsed.find((item) => item[iScale.axis] === iScaleValue);
      const val = parsed && parsed[meta.vScale.axis];
      if (isNullOrUndef(val) || isNaN(val)) {
        return true;
      }
    };
    for (const meta of metasets) {
      if (dataIndex !== void 0 && skipNull(meta)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
        stacks.push(meta.stack);
      }
      if (meta.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index) {
    return this._getStacks(void 0, index).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index = name !== void 0 ? stacks.indexOf(name) : -1;
    return index === -1 ? stacks.length - 1 : index;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i2, ilen;
    for (i2 = 0, ilen = meta.data.length; i2 < ilen; ++i2) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i2)[iScale.axis], i2));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index) {
    const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max), min);
      head = base + size;
      if (_stacked && !floating) {
        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
      }
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
      const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : void 0);
      center = range.start + range.chunk * stackIndex + range.chunk / 2;
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i2 = 0;
    for (; i2 < ilen; ++i2) {
      if (this.getParsed(i2)[vScale.axis] !== null && !rects[i2].hidden) {
        rects[i2].draw(this._ctx);
      }
    }
  }
};
__publicField(BarController, "id", "bar");
__publicField(BarController, "defaults", {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
});
__publicField(BarController, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
});
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a2, b2) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a2, a2 * cutout, b2, b2 * cutout);
    const calcMin = (angle, a2, b2) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a2, a2 * cutout, b2, b2 * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {
    ratioX,
    ratioY,
    offsetX,
    offsetY
  };
}
var DoughnutController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i3) => +data[i3];
      if (isObject(data[start])) {
        const { key = "value" } = this._parsing;
        getter = (i3) => +resolveObjectKey(data[i3], key);
      }
      let i2, ilen;
      for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
        meta._parsed[i2] = getter(i2);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i2 = 0; i2 < this.chart.data.datasets.length; ++i2) {
      if (this.chart.isDatasetVisible(i2) && this.chart.getDatasetMeta(i2).type === this._type) {
        const controller = this.chart.getDatasetMeta(i2).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i2, reset2) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset2 && opts.animation.animateRotate || !this.chart.getDataVisibility(i2) || meta._parsed[i2] === null || meta.data[i2].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i2] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset2 = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset2 && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    let startAngle = this._getRotation();
    let i2;
    for (i2 = 0; i2 < start; ++i2) {
      startAngle += this._circumference(i2, reset2);
    }
    for (i2 = start; i2 < start + count; ++i2) {
      const circumference = this._circumference(i2, reset2);
      const arc = arcs[i2];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i2, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i2;
    for (i2 = 0; i2 < metaData.length; i2++) {
      const value = meta._parsed[i2];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i2) && !metaData[i2].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index], chart.options.locale);
    return {
      label: labels[index] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i2, ilen, meta, controller, options;
    if (!arcs) {
      for (i2 = 0, ilen = chart.data.datasets.length; i2 < ilen; ++i2) {
        if (chart.isDatasetVisible(i2)) {
          meta = chart.getDatasetMeta(i2);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
      options = controller.resolveDataElementOptions(i2);
      if (options.borderAlign !== "inner") {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
      const options = this.resolveDataElementOptions(i2);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i2 = 0; i2 < datasetIndex; ++i2) {
      if (this.chart.isDatasetVisible(i2)) {
        ringWeightOffset += this._getRingWeight(i2);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
};
__publicField(DoughnutController, "id", "doughnut");
__publicField(DoughnutController, "defaults", {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
});
__publicField(DoughnutController, "descriptors", {
  _scriptable: (name) => name !== "spacing",
  _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
});
__publicField(DoughnutController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i2) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i2);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i2),
                index: i2
              };
            });
          }
          return [];
        }
      },
      onClick(e2, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  }
});
var PieController = class extends DoughnutController {
};
__publicField(PieController, "id", "pie");
__publicField(PieController, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var DateAdapterBase = class _DateAdapterBase {
  constructor(options) {
    __publicField(this, "options");
    this.options = options || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(members) {
    Object.assign(_DateAdapterBase.prototype, members);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return abstract();
  }
  parse() {
    return abstract();
  }
  format() {
    return abstract();
  }
  add() {
    return abstract();
  }
  diff() {
    return abstract();
  }
  startOf() {
    return abstract();
  }
  endOf() {
    return abstract();
  }
};
var adapters = {
  _date: DateAdapterBase
};
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      const result = lookupMethod(data, axis, value);
      if (spanGaps) {
        const { vScale } = controller._cachedMeta;
        const { _parsed } = metaset;
        const distanceToDefinedLo = _parsed.slice(0, result.lo + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));
        result.lo -= Math.max(0, distanceToDefinedLo);
        const distanceToDefinedHi = _parsed.slice(result.hi).findIndex((point) => !isNullOrUndef(point[vScale.axis]));
        result.hi += Math.max(0, distanceToDefinedHi);
      }
      return result;
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === "function" && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return {
          lo: start.lo,
          hi: end.hi
        };
      }
    }
  }
  return {
    lo: 0,
    hi: data.length - 1
  };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
    const { index, data } = metasets[i2];
    const { lo, hi } = binarySearch(metasets[i2], axis, value, intersect);
    for (let j2 = lo; j2 <= hi; ++j2) {
      const element = data[j2];
      if (!element.skip) {
        handler(element, index, j2);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index) {
    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
      return;
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index
      });
    }
  };
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index) {
    const { startAngle, endAngle } = element.getProps([
      "startAngle",
      "endAngle"
    ], useFinalPosition);
    const { angle } = getAngleFromPoint(element, {
      x: position.x,
      y: position.y
    });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({
        element,
        datasetIndex,
        index
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index) {
    const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [
        {
          element,
          datasetIndex,
          index
        }
      ];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({
        element,
        datasetIndex,
        index
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {
    if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index
      });
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      const axis = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index = items[0].index;
        const element = meta.data[index];
        if (element && !element.skip) {
          elements.push({
            element,
            datasetIndex: meta.index,
            index
          });
        }
      });
      return elements;
    },
    dataset(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i2 = 0; i2 < data.length; ++i2) {
          items.push({
            element: data[i2],
            datasetIndex,
            index: i2
          });
        }
      }
      return items;
    },
    point(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
    },
    y(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
    }
  }
};
var STATIC_POSITIONS = [
  "left",
  "top",
  "right",
  "bottom"
];
function filterByPosition(array, position) {
  return array.filter((v2) => v2.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v2) => STATIC_POSITIONS.indexOf(v2.pos) === -1 && v2.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a2, b2) => {
    const v0 = reverse ? b2 : a2;
    const v1 = reverse ? a2 : b2;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i2, ilen, box, pos, stack, stackWeight;
  for (i2 = 0, ilen = (boxes || []).length; i2 < ilen; ++i2) {
    box = boxes[i2];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i2,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i2, ilen, layout;
  for (i2 = 0, ilen = layouts2.length; i2 < ilen; ++i2) {
    layout = layouts2[i2];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a2, b2) {
  return Math.max(maxPadding[a2], chartArea[a2]) + Math.max(maxPadding[b2], chartArea[b2]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {
      size: 0,
      count: 1
    };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? {
    same: widthChanged,
    other: heightChanged
  } : {
    same: heightChanged,
    other: widthChanged
  };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions([
    "left",
    "right"
  ]) : marginForPositions([
    "top",
    "bottom"
  ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i2, ilen, layout, box, refit, changed;
  for (i2 = 0, ilen = boxes.length, refit = 0; i2 < ilen; ++i2) {
    layout = boxes[i2];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x: x2, y: y2 } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y2 = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y2, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y2, width, height);
      }
      stack.start = y2;
      stack.placed += width;
      y2 = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x2 = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x2, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x2, chartArea.top + stack.placed, width, height);
      }
      stack.start = x2;
      stack.placed += height;
      x2 = box.right;
    }
  }
  chartArea.x = x2;
  chartArea.y = y2;
}
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [
        {
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }
      ];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index !== -1) {
      chart.boxes.splice(index, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
var BasePlatform = class {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
};
var BasicPlatform = class extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
};
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
var isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
var eventListenerOptions = supportsEventListenerOptions ? {
  passive: true
} : false;
function addListener(node, type, listener) {
  if (node) {
    node.addEventListener(type, listener, eventListenerOptions);
  }
}
function removeListener(chart, type, listener) {
  if (chart && chart.canvas) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
  }
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x: x2, y: y2 } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x2 !== void 0 ? x2 : null,
    y: y2 !== void 0 ? y2 : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
var drpListeningCharts = /* @__PURE__ */ new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w2 = container.clientWidth;
    listener(width, height);
    if (w2 < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart);
  addListener(canvas, type, proxy);
  return proxy;
}
var DomPlatform = class extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    [
      "height",
      "width"
    ].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = canvas && _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
};
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
var Element = class {
  constructor() {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "active", false);
    __publicField(this, "options");
    __publicField(this, "$animations");
  }
  tooltipPosition(useFinalPosition) {
    const { x: x2, y: y2 } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x: x2,
      y: y2
    };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
__publicField(Element, "defaults", {});
__publicField(Element, "defaultRoutes");
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const determinedMaxTicks = determineMaxTicks(scale);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i2, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i2 = 0, ilen = numMajorIndices - 1; i2 < ilen; i2++) {
      skip(ticks, newTicks, spacing, majorIndices[i2], majorIndices[i2 + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i2 = 0, ilen = factors.length - 1; i2 < ilen; i2++) {
    const factor = factors[i2];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i2, ilen;
  for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
    if (ticks[i2].major) {
      result.push(i2);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i2;
  spacing = Math.ceil(spacing);
  for (i2 = 0; i2 < ticks.length; i2++) {
    if (i2 === next) {
      newTicks.push(ticks[i2]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i2, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i2 = Math.max(start, 0); i2 < end; i2++) {
    if (i2 === next) {
      newTicks.push(ticks[i2]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i2, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i2 = 1; i2 < len; ++i2) {
    if (arr[i2] - arr[i2 - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
var getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i2 = 0;
  for (; i2 < len; i2 += increment) {
    result.push(arr[Math.floor(i2)]);
  }
  return result;
}
function getPixelForGridLine(scale, index, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i2;
    if (gcLen > length) {
      for (i2 = 0; i2 < gcLen; ++i2) {
        delete cache.data[gc[i2]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index, tick) {
  return createContext(parent, {
    tick,
    index,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return {
    titleX,
    titleY,
    maxWidth,
    rotation
  };
}
var Scale = class _Scale extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return {
        min,
        max
      };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
      range = metas[i2].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  getLabelItems(chartArea = this.chart.chartArea) {
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    return items;
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [
      this
    ]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i2, ilen, tick;
    for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
      tick = ticks[i2];
      tick.label = callback(tickOpts.callback, [
        tick.value,
        i2,
        ticks
      ], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i2, ilen;
    for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
      if (isNullOrUndef(ticks[i2].label)) {
        ticks.splice(i2, 1);
        ilen--;
        i2--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length, maxTicksLimit) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i2, j2, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i2 = 0; i2 < length; i2 += increment) {
      label = ticks[i2].label;
      tickFont = this._resolveTickFontOptions(i2);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j2 = 0, jlen = label.length; j2 < jlen; ++j2) {
          nestedLabel = label[j2];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index) {
    const ticks = this.ticks || [];
    if (index >= 0 && index < ticks.length) {
      const tick = ticks[index];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w2 = labelSizes ? labelSizes.widest.width + padding : 0;
    const h6 = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h6 * cos > w2 * sin ? w2 / cos : h6 / sin : h6 * sin < w2 * cos ? h6 / cos : w2 / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position, border } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i2, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i2 = 0; i2 < ticksLength; i2 += step) {
      const context = this.getContext(i2);
      const optsAtIndex = grid.setContext(context);
      const optsAtIndexBorder = border.setContext(context);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i2, offset);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i2, ilen, tick, label, x2, y2, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y2 = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y2 = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x2 = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x2 = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y2 = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y2 = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x2 = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x2 = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
      tick = ticks[i2];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i2));
      pixel = this.getPixelForTick(i2) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i2);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x2 = pixel;
        if (textAlign === "inner") {
          if (i2 === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i2 === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
          x2 += lineHeight / 2 * Math.sin(rotation);
        }
      } else {
        y2 = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i2];
        const width = labelSizes.widths[i2];
        let top = textOffset - labelPadding.top;
        let left = 0 - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
          case "inner":
            if (i2 === ilen - 1) {
              left -= width;
            } else if (i2 > 0) {
              left -= width / 2;
            }
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        label,
        font,
        textOffset,
        options: {
          rotation,
          color: color2,
          strokeColor,
          strokeWidth,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [
            x2,
            y2
          ],
          backdrop
        }
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x2;
    if (position === "left") {
      if (mirror) {
        x2 = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 += widest / 2;
        } else {
          textAlign = "right";
          x2 += widest;
        }
      } else {
        x2 = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 -= widest / 2;
        } else {
          textAlign = "left";
          x2 = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x2 = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 -= widest / 2;
        } else {
          textAlign = "left";
          x2 -= widest;
        }
      } else {
        x2 = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 += widest / 2;
        } else {
          textAlign = "right";
          x2 = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return {
      textAlign,
      x: x2
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }
    if (position === "top" || position === "bottom") {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index = ticks.findIndex((t3) => t3.value === value);
    if (index >= 0) {
      const opts = grid.setContext(this.getContext(index));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i2, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
        const item = items[i2];
        if (grid.drawOnChartArea) {
          drawLine({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }
        if (grid.drawTicks) {
          drawLine({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { border, grid } } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.width;
    ctx.strokeStyle = borderOpts.color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this.getLabelItems(chartArea);
    for (const item of items) {
      const renderTextOptions = item.options;
      const tickFont = item.font;
      const label = item.label;
      const y2 = item.textOffset;
      renderText(ctx, label, 0, y2, tickFont, renderTextOptions);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject(position)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    const bz = valueOrDefault(opts.border && opts.border.z, 0);
    if (!this._isVisible() || this.draw !== _Scale.prototype.draw) {
      return [
        {
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }
      ];
    }
    return [
      {
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      },
      {
        z: bz,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }
    ];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i2, ilen;
    for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
      const meta = metas[i2];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index) {
    const opts = this.options.ticks.setContext(this.getContext(index));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
};
var TypedRegistry = class {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults2.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults2[scope]) {
      delete defaults2[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
};
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults2.get(parentScope) : {},
    defaults2.get(scope),
    item.defaults
  ]);
  defaults2.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults2.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [
      scope
    ].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults2.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
var Registry = class {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [
      ...args
    ].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i2 = 0; i2 < this._typedRegistries.length; i2++) {
      const reg = this._typedRegistries[i2];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
};
var registry = /* @__PURE__ */ new Registry();
var PluginService = class {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter2) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter2 ? this._descriptors(chart).filter(filter2) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [
        chart,
        args,
        descriptor.options
      ];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a2, b2) => a2.filter((x2) => !b2.some((y2) => x2.plugin.id === y2.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
};
function allPlugins(config) {
  const localIds = {};
  const plugins = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i2 = 0; i2 < keys.length; i2++) {
    plugins.push(registry.getPlugin(keys[i2]));
  }
  const local = config.plugins || [];
  for (let i2 = 0; i2 < local.length; i2++) {
    const plugin = local[i2];
    if (plugins.indexOf(plugin) === -1) {
      plugins.push(plugin);
      localIds[plugin.id] = true;
    }
  }
  return {
    plugins,
    localIds
  };
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, { plugins, localIds }, options, all) {
  const result = [];
  const context = chart.getContext();
  for (const plugin of plugins) {
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, {
        plugin,
        local: localIds[id]
      }, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, { plugin, local }, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  if (local && plugin.defaults) {
    scopes.push(plugin.defaults);
  }
  return config.createResolver(scopes, context, [
    ""
  ], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults2.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function idMatchesAxis(id) {
  if (id === "x" || id === "y" || id === "r") {
    return id;
  }
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, ...scaleOptions) {
  if (idMatchesAxis(id)) {
    return id;
  }
  for (const opts of scaleOptions) {
    const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
    if (axis) {
      return axis;
    }
  }
  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
}
function getAxisFromDataset(id, axis, dataset) {
  if (dataset[axis + "AxisID"] === id) {
    return {
      axis
    };
  }
}
function retrieveAxisFromDatasets(id, config) {
  if (config.data && config.data.datasets) {
    const boundDs = config.data.datasets.filter((d2) => d2.xAxisID === id || d2.yAxisID === id);
    if (boundDs.length) {
      return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
    }
  }
  return {};
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || {
    scales: {}
  };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const scales = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults2.scales[scaleConf.type]);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    scales[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
      {
        axis
      },
      scaleConf,
      defaultScaleOptions[axis],
      defaultScaleOptions[defaultId]
    ]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || axis;
      scales[id] = scales[id] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales[id], [
        {
          axis
        },
        configScales[id],
        defaultScaleOptions[defaultID]
      ]);
    });
  });
  Object.keys(scales).forEach((key) => {
    const scale = scales[key];
    mergeIf(scale, [
      defaults2.scales[scale.type],
      defaults2.scale
    ]);
  });
  return scales;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
var keyCache = /* @__PURE__ */ new Map();
var keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
var addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
var Config = class {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [
      [
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [
      [
        `plugins.${id}`,
        ...plugin.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = /* @__PURE__ */ new Set();
    keyLists.forEach((keys) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys.forEach((key) => addIfFound(scopes, options, key));
      keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach((key) => addIfFound(scopes, defaults2, key));
      keys.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults2.datasets[type] || {},
      {
        type
      },
      defaults2,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [
    ""
  ]) {
    const result = {
      $shared: true
    };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [
    ""
  ], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
};
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = /* @__PURE__ */ new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p2) => !p2.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
var version = "4.4.8";
var KNOWN_POSITIONS = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a2, b2) {
    return a2[l1] === b2[l1] ? a2[l2] - b2[l2] : a2[l1] - b2[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions && animationOptions.onComplete, [
    context
  ], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [
    context
  ], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
var instances = {};
var getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c2) => c2.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e2, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e2.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e2;
}
function getSizeForArea(scale, chartArea, field) {
  return scale.options.clip ? scale[field] : chartArea[field];
}
function getDatasetArea(meta, chartArea) {
  const { xScale, yScale } = meta;
  if (xScale && yScale) {
    return {
      left: getSizeForArea(xScale, chartArea, "left"),
      right: getSizeForArea(xScale, chartArea, "right"),
      top: getSizeForArea(yScale, chartArea, "top"),
      bottom: getSizeForArea(yScale, chartArea, "bottom")
    };
  }
  return chartArea;
}
var Chart = class {
  static register(...items) {
    registry.add(...items);
    invalidatePlugins();
  }
  static unregister(...items) {
    registry.remove(...items);
    invalidatePlugins();
  }
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  get registry() {
    return registry;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {
        width,
        height
      };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", {
      size: newSize
    });
    callback(options.onResize, [
      this,
      newSize
    ], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales = this.scales;
    const updated = Object.keys(scales).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales && scales[id].type === scaleType) {
        scale = scales[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales[id];
      }
    });
    each(scales, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a2, b2) => a2.index - b2.index);
    if (numMeta > numData) {
      for (let i2 = numData; i2 < numMeta; ++i2) {
        this._destroyDatasetMeta(i2);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index) => {
      if (datasets.filter((x2) => x2 === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i2, ilen;
    this._removeUnreferencedMetasets();
    for (i2 = 0, ilen = datasets.length; i2 < ilen; i2++) {
      const dataset = datasets[i2];
      let meta = this.getDatasetMeta(i2);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i2);
        meta = this.getDatasetMeta(i2);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i2;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i2);
      if (meta.controller) {
        meta.controller.updateIndex(i2);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults2.datasets[type];
        Object.assign(ControllerClass, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i2);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; i2++) {
      const { controller } = this.getDatasetMeta(i2);
      const reset2 = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset2);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", {
      mode
    });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c2) => c2[0] === idx).map((c2, i2) => i2 + "," + c2.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i2 = 1; i2 < datasetCount; i2++) {
      if (!setsEqual(changeSet, makeSet(i2))) {
        return;
      }
    }
    return Array.from(changeSet).map((c2) => c2.split(",")).map((a2) => ({
      method: a2[1],
      start: +a2[2],
      count: +a2[3]
    }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: true
    }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index) => {
      item._idx = index;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
      this.getDatasetMeta(i2).controller.configure();
    }
    for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
      this._updateDataset(i2, isFunction(mode) ? mode({
        datasetIndex: i2
      }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", {
      mode
    });
  }
  _updateDataset(index, mode) {
    const meta = this.getDatasetMeta(index);
    const args = {
      meta,
      index,
      mode,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", {
      cancelable: true
    }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({
        chart: this
      });
    }
  }
  draw() {
    let i2;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null;
      this._resize(width, height);
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const layers = this._layers;
    for (i2 = 0; i2 < layers.length && layers[i2].z <= 0; ++i2) {
      layers[i2].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i2 < layers.length; ++i2) {
      layers[i2].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i2, ilen;
    for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
      const meta = metasets[i2];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
      this._drawDataset(metasets[i2]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = getDatasetArea(meta, this.chartArea);
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e2, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e2, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x2) => x2 && x2._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index) {
    this._hiddenIndices[index] = !this._hiddenIndices[index];
  }
  getDataVisibility(index) {
    return !this._hiddenIndices[index];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {
        visible
      });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i2, ilen;
    this.stop();
    animator.remove(this);
    for (i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
      this._destroyDatasetMeta(i2);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e2, x2, y2) => {
      e2.offsetX = x2;
      e2.offsetY = y2;
      this._eventHandler(e2);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i2, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
      item = items[i2];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter2) {
    return this._plugins.notify(this, hook, args, filter2);
  }
  isPluginEnabled(pluginId) {
    return this._plugins._cache.filter((p2) => p2.plugin.id === pluginId).length === 1;
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a2, b2) => a2.filter((x2) => !b2.some((y2) => x2.datasetIndex === y2.datasetIndex && x2.index === y2.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e2, replay) {
    const args = {
      event: e2,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e2)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e2.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e2, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e2, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e2, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e2);
    const lastEvent = determineLastEvent(e2, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [
        e2,
        active,
        this
      ], this);
      if (isClick) {
        callback(options.onClick, [
          e2,
          active,
          this
        ], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e2, lastActive, inChartArea, useFinalPosition) {
    if (e2.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e2, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
};
__publicField(Chart, "defaults", defaults2);
__publicField(Chart, "instances", instances);
__publicField(Chart, "overrides", overrides);
__publicField(Chart, "registry", registry);
__publicField(Chart, "version", version);
__publicField(Chart, "getChart", getChart);
function invalidatePlugins() {
  return each(Chart.instances, (chart) => chart._plugins.invalidate());
}
function clipArc(ctx, element, endAngle) {
  const { startAngle, pixelMargin, x: x2, y: y2, outerRadius, innerRadius } = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x2, y2, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x2, y2, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x2, y2, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o2 = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o2.outerStart),
    outerEnd: computeOuterLimit(o2.outerEnd),
    innerStart: _limitValue(o2.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o2.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r2, theta, x2, y2) {
  return {
    x: x2 + r2 * Math.cos(theta),
    y: y2 + r2 * Math.sin(theta)
  };
}
function pathArc(ctx, element, offset, spacing, end, circular) {
  const { x: x2, y: y2, startAngle: start, pixelMargin, innerRadius: innerR } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha2 = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
    spacingOffset = (alpha2 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha2 - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  if (circular) {
    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
    ctx.arc(x2, y2, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
    ctx.arc(x2, y2, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x2, y2);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x2, y2);
    ctx.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x2, y2);
      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
    ctx.arc(x2, y2, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
    ctx.arc(x2, y2, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x2, y2);
      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x2, y2);
    ctx.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x2, y2);
      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x2, y2);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x2;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y2;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x2;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y2;
    ctx.lineTo(outerEndX, outerEndY);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i2 = 0; i2 < fullCircles; ++i2) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  pathArc(ctx, element, offset, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}
function drawBorder(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference, options } = element;
  const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  ctx.setLineDash(borderDash || []);
  ctx.lineDashOffset = borderDashOffset;
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i2 = 0; i2 < fullCircles; ++i2) {
      ctx.stroke();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  if (!fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.stroke();
  }
}
var ArcElement = class extends Element {
  constructor(cfg) {
    super();
    __publicField(this, "circumference");
    __publicField(this, "endAngle");
    __publicField(this, "fullCircles");
    __publicField(this, "innerRadius");
    __publicField(this, "outerRadius");
    __publicField(this, "pixelMargin");
    __publicField(this, "startAngle");
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, {
      x: chartX,
      y: chartY
    });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;
    const betweenAngles = _circumference >= TAU || nonZeroBetween;
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x: x2, y: y2, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], useFinalPosition);
    const { offset, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x2 + Math.cos(halfAngle) * halfRadius,
      y: y2 + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset = (options.offset || 0) / 4;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    const halfAngle = (this.startAngle + this.endAngle) / 2;
    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
    const radiusOffset = offset * fix;
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, circular);
    ctx.restore();
  }
};
__publicField(ArcElement, "id", "arc");
__publicField(ArcElement, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true
});
__publicField(ArcElement, "defaultRoutes", {
  backgroundColor: "backgroundColor"
});
__publicField(ArcElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash"
});
function getBarBounds(bar, useFinalPosition) {
  const { x: x2, y: y2, base, width, height } = bar.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x2, base);
    right = Math.max(x2, base);
    top = y2 - half;
    bottom = y2 + half;
  } else {
    half = width / 2;
    left = x2 - half;
    right = x2 + half;
    top = Math.min(y2, base);
    bottom = Math.max(y2, base);
  }
  return {
    left,
    top,
    right,
    bottom
  };
}
function skipOrLimit(skip2, value, min, max) {
  return skip2 ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o2 = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o2.top, 0, maxH),
    r: skipOrLimit(skip2.right, o2.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o2.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o2.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps([
    "enableBorderRadius"
  ]);
  const value = bar.options.borderRadius;
  const o2 = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o2.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o2.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o2.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o2.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x2, y2, useFinalPosition) {
  const skipX = x2 === null;
  const skipY = y2 === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x2, bounds.left, bounds.right)) && (skipY || _isBetween(y2, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x2 = rect.x !== refRect.x ? -amount : 0;
  const y2 = rect.y !== refRect.y ? -amount : 0;
  const w2 = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x2;
  const h6 = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y2;
  return {
    x: rect.x + x2,
    y: rect.y + y2,
    w: rect.w + w2,
    h: rect.h + h6,
    radius: rect.radius
  };
}
var BarElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x: x2, y: y2, base, horizontal } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], useFinalPosition);
    return {
      x: horizontal ? (x2 + base) / 2 : x2,
      y: horizontal ? y2 : (y2 + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
};
__publicField(BarElement, "id", "bar");
__publicField(BarElement, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
});
__publicField(BarElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
var itemsEqual = (a2, b2) => a2 !== null && b2 !== null && a2.datasetIndex === b2.datasetIndex && a2.index === b2.index;
var Legend = class extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [
      this.chart
    ], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a2, b2) => labelOpts.sort(a2, b2, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [
      0
    ];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i2) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i2 === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i2 > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i2] = {
        left: 0,
        top,
        row,
        width: itemWidth,
        height: itemHeight
      };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i2) => {
      const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
      if (i2 > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i2] = {
        left,
        top: currentColHeight,
        col,
        width: itemWidth,
        height: itemHeight
      };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({
      width: currentColWidth,
      height: currentColHeight
    });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults2.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x2, y2, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x2, boxWidth / 2);
        const centerY = y2 + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y2 + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x2, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v2) => v2 !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x2, y2, legendItem) {
      renderText(ctx, legendItem.text, x2, y2 + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i2) => {
      ctx.strokeStyle = legendItem.fontColor;
      ctx.fillStyle = legendItem.fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x2 = cursor.x;
      let y2 = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i2 > 0 && x2 + width + padding > this.right) {
          y2 = cursor.y += lineHeight;
          cursor.line++;
          x2 = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i2 > 0 && y2 + lineHeight > this.bottom) {
        x2 = cursor.x = x2 + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y2 = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x2);
      drawLegendBox(realX, y2, legendItem);
      x2 = _textX(textAlign, x2 + boxWidth + halfFontSize, isHorizontal ? x2 + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x2), y2, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else if (typeof legendItem.text !== "string") {
        const fontLineHeight = labelFont.lineHeight;
        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y2;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y2 = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y2 = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x2 = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x2, y2, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x2, y2) {
    let i2, hitBox, lh;
    if (_isBetween(x2, this.left, this.right) && _isBetween(y2, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i2 = 0; i2 < lh.length; ++i2) {
        hitBox = lh[i2];
        if (_isBetween(x2, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y2, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i2];
        }
      }
    }
    return null;
  }
  handleEvent(e2) {
    const opts = this.options;
    if (!isListened(e2.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e2.x, e2.y);
    if (e2.type === "mousemove" || e2.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [
          e2,
          previous,
          this
        ], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [
          e2,
          hoveredItem,
          this
        ], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [
        e2,
        hoveredItem,
        this
      ], this);
    }
  }
};
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
  return {
    itemWidth,
    itemHeight
  };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
  let legendItemText = legendItem.text;
  if (legendItemText && typeof legendItemText !== "string") {
    legendItemText = legendItemText.reduce((a2, b2) => a2.length > b2.length ? a2 : b2);
  }
  return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
  let itemHeight = _itemHeight;
  if (typeof legendItem.text !== "string") {
    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
  }
  return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
  const labelHeight = legendItem.text ? legendItem.text.length : 0;
  return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e2, legendItem, legend) {
      const index = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index)) {
        ci.hide(index);
        legendItem.hidden = true;
      } else {
        ci.show(index);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(name)
    }
  }
};
var Title = class extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
};
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var map2 = /* @__PURE__ */ new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map2.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map2.get(chart));
    map2.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map2.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i2, len;
    let xSet = /* @__PURE__ */ new Set();
    let y2 = 0;
    let count = 0;
    for (i2 = 0, len = items.length; i2 < len; ++i2) {
      const el = items[i2].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        xSet.add(pos.x);
        y2 += pos.y;
        ++count;
      }
    }
    if (count === 0 || xSet.size === 0) {
      return false;
    }
    const xAverage = [
      ...xSet
    ].reduce((a2, b2) => a2 + b2) / xSet.size;
    return {
      x: xAverage,
      y: y2 / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x2 = eventPosition.x;
    let y2 = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i2, len, nearestElement;
    for (i2 = 0, len = items.length; i2 < len; ++i2) {
      const el = items[i2].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d2 = distanceBetweenPoints(eventPosition, center);
        if (d2 < minDistance) {
          minDistance = d2;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x2 = tp.x;
      y2 = tp.y;
    }
    return {
      x: x2,
      y: y2
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element, datasetIndex, index } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index);
  return {
    chart,
    label,
    parsed: controller.getParsed(index),
    raw: chart.data.datasets[datasetIndex].data[index],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return {
    width,
    height
  };
}
function determineYAlign(chart, size) {
  const { y: y2, height } = size;
  if (y2 < height / 2) {
    return "top";
  } else if (y2 > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x: x2, width } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x2 + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x2 - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const { x: x2, width } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x2 <= (left + right) / 2 ? "left" : "right";
  } else if (x2 <= width / 2) {
    xAlign = "left";
  } else if (x2 >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x: x2, width } = size;
  if (xAlign === "right") {
    x2 -= width;
  } else if (xAlign === "center") {
    x2 -= width / 2;
  }
  return x2;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y: y2, height } = size;
  if (yAlign === "top") {
    y2 += paddingAndSize;
  } else if (yAlign === "bottom") {
    y2 -= height + paddingAndSize;
  } else {
    y2 -= height / 2;
  }
  return y2;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x2 = alignX(size, xAlign);
  const y2 = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x2 += paddingAndSize;
    } else if (xAlign === "right") {
      x2 -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x2 -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x2 += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x2, 0, chart.width - size.width),
    y: _limitValue(y2, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
var defaultCallbacks = {
  beforeTitle: noop,
  title(tooltipItems) {
    if (tooltipItems.length > 0) {
      const item = tooltipItems[0];
      const labels = item.chart.data.labels;
      const labelCount = labels ? labels.length : 0;
      if (this && this.options && this.options.mode === "dataset") {
        return item.dataset.label || "";
      } else if (item.label) {
        return item.label;
      } else if (labelCount > 0 && item.dataIndex < labelCount) {
        return labels[item.dataIndex];
      }
    }
    return "";
  },
  afterTitle: noop,
  beforeBody: noop,
  beforeLabel: noop,
  label(tooltipItem) {
    if (this && this.options && this.options.mode === "dataset") {
      return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
    }
    let label = tooltipItem.dataset.label || "";
    if (label) {
      label += ": ";
    }
    const value = tooltipItem.formattedValue;
    if (!isNullOrUndef(value)) {
      label += value;
    }
    return label;
  },
  labelColor(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      borderColor: options.borderColor,
      backgroundColor: options.backgroundColor,
      borderWidth: options.borderWidth,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      pointStyle: options.pointStyle,
      rotation: options.rotation
    };
  },
  afterLabel: noop,
  afterBody: noop,
  beforeFooter: noop,
  footer: noop,
  afterFooter: noop
};
function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
  const result = callbacks[name].call(ctx, arg);
  if (typeof result === "undefined") {
    return defaultCallbacks[name].call(ctx, arg);
  }
  return result;
}
var Tooltip = class extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
    const title = invokeCallbackWithFallback(callbacks, "title", this, context);
    const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
    const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
    const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i2, len;
    for (i2 = 0, len = active.length; i2 < len; ++i2) {
      tooltipItems.push(createTooltipItem(this.chart, active[i2]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a2, b2) => options.itemSort(a2, b2, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
      labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
      labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay
      });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {
      x1,
      x2,
      x3,
      y1,
      y2,
      y3
    };
  }
  drawTitle(pt2, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i2;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt2.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i2 = 0; i2 < length; ++i2) {
        ctx.fillText(title[i2], rtlHelper.x(pt2.x), pt2.y + titleFont.lineHeight / 2);
        pt2.y += titleFont.lineHeight + titleSpacing;
        if (i2 + 1 === length) {
          pt2.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt2, i2, rtlHelper, options) {
    const labelColor = this.labelColors[i2];
    const labelPointStyle = this.labelPointStyles[i2];
    const { boxHeight, boxWidth } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt2.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColor.borderColor;
      ctx.fillStyle = labelColor.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
      ctx.strokeStyle = labelColor.borderColor;
      ctx.setLineDash(labelColor.borderDash || []);
      ctx.lineDashOffset = labelColor.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
      const borderRadius = toTRBLCorners(labelColor.borderRadius);
      if (Object.values(borderRadius).some((v2) => v2 !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i2];
  }
  drawBody(pt2, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt2.x + xLinePadding), pt2.y + bodyLineHeight / 2);
      pt2.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i2, j2, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt2.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i2 = 0, ilen = body.length; i2 < ilen; ++i2) {
      bodyItem = body[i2];
      textColor = this.labelTextColors[i2];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt2, i2, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j2 = 0, jlen = lines.length; j2 < jlen; ++j2) {
        fillLineOfText(lines[j2]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt2.y -= bodySpacing;
  }
  drawFooter(pt2, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i2;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt2.x = getAlignedX(this, options.footerAlign, options);
      pt2.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i2 = 0; i2 < length; ++i2) {
        ctx.fillText(footer[i2], rtlHelper.x(pt2.x), pt2.y + footerFont.lineHeight / 2);
        pt2.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt2, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x: x2, y: y2 } = pt2;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x2 + topLeft, y2);
    if (yAlign === "top") {
      this.drawCaret(pt2, ctx, tooltipSize, options);
    }
    ctx.lineTo(x2 + width - topRight, y2);
    ctx.quadraticCurveTo(x2 + width, y2, x2 + width, y2 + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt2, ctx, tooltipSize, options);
    }
    ctx.lineTo(x2 + width, y2 + height - bottomRight);
    ctx.quadraticCurveTo(x2 + width, y2 + height, x2 + width - bottomRight, y2 + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt2, ctx, tooltipSize, options);
    }
    ctx.lineTo(x2 + bottomLeft, y2 + height);
    ctx.quadraticCurveTo(x2, y2 + height, x2, y2 + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt2, ctx, tooltipSize, options);
    }
    ctx.lineTo(x2, y2 + topLeft);
    ctx.quadraticCurveTo(x2, y2, x2 + topLeft, y2);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt2 = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt2, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt2.y += padding.top;
      this.drawTitle(pt2, ctx, options);
      this.drawBody(pt2, ctx, options);
      this.drawFooter(pt2, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e2, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e2, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e2);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e2.x,
          y: e2.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e2, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e2.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive.filter((i2) => this.chart.data.datasets[i2.datasetIndex] && this.chart.getDatasetMeta(i2.datasetIndex).controller.getParsed(i2.index) !== void 0);
    }
    const active = this.chart.getElementsAtEventForMode(e2, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e2) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e2);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
};
__publicField(Tooltip, "positioners", positioners);
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({
        chart,
        options
      });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins("beforeTooltipDraw", {
        ...args,
        cancelable: true
      }) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: defaultCallbacks
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
var addIfString = (labels, raw, index, addedLabels) => {
  if (typeof raw === "string") {
    index = labels.push(raw) - 1;
    addedLabels.unshift({
      index,
      label: raw
    });
  } else if (isNaN(raw)) {
    index = null;
  }
  return index;
};
function findOrAddLabel(labels, raw, index, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index : first;
}
var validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);
function _getLabelForValue(value) {
  const labels = this.getLabels();
  if (value >= 0 && value < labels.length) {
    return labels[value];
  }
  return value;
}
var CategoryScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index, label } of added) {
        if (labels[index] === label) {
          labels.splice(index, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
    return validIndex(index, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({
        value
      });
    }
    return ticks;
  }
  getLabelForValue(value) {
    return _getLabelForValue.call(this, value);
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
};
__publicField(CategoryScale, "id", "category");
__publicField(CategoryScale, "defaults", {
  ticks: {
    callback: _getLabelForValue
  }
});
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [
      {
        value: rmin
      },
      {
        value: rmax
      }
    ];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j2 = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({
        value: min
      });
      if (niceMin < min) {
        j2++;
      }
      if (almostEquals(Math.round((niceMin + j2 * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j2++;
      }
    } else if (niceMin < min) {
      j2++;
    }
  }
  for (; j2 < numSpaces; ++j2) {
    const tickValue = Math.round((niceMin + j2 * spacing) * factor) / factor;
    if (maxDefined && tickValue > max) {
      break;
    }
    ticks.push({
      value: tickValue
    });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({
        value: max
      });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({
      value: niceMax
    });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v2) => min = minDefined ? min : v2;
    const setMax = (v2) => max = maxDefined ? max : v2;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = max === 0 ? 1 : Math.abs(max * 0.05);
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
};
var LinearScale = class extends LinearScaleBase {
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
__publicField(LinearScale, "id", "linear");
__publicField(LinearScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.numeric
  }
});
var log10Floor = (v2) => Math.floor(log10(v2));
var changeExponent = (v2, m2) => Math.pow(10, log10Floor(v2) + m2);
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, log10Floor(tickVal));
  return remain === 1;
}
function steps(min, max, rangeExp) {
  const rangeStep = Math.pow(10, rangeExp);
  const start = Math.floor(min / rangeStep);
  const end = Math.ceil(max / rangeStep);
  return end - start;
}
function startExp(min, max) {
  const range = max - min;
  let rangeExp = log10Floor(range);
  while (steps(min, max, rangeExp) > 10) {
    rangeExp++;
  }
  while (steps(min, max, rangeExp) < 10) {
    rangeExp--;
  }
  return Math.min(rangeExp, log10Floor(min));
}
function generateTicks(generationOptions, { min, max }) {
  min = finiteOrDefault(generationOptions.min, min);
  const ticks = [];
  const minExp = log10Floor(min);
  let exp = startExp(min, max);
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  const stepSize = Math.pow(10, exp);
  const base = minExp > exp ? Math.pow(10, minExp) : 0;
  const start = Math.round((min - base) * precision) / precision;
  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
  let significand = Math.floor((start - offset) / Math.pow(10, exp));
  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
  while (value < max) {
    ticks.push({
      value,
      major: isMajor(value),
      significand
    });
    if (significand >= 10) {
      significand = significand < 15 ? 15 : 20;
    } else {
      significand++;
    }
    if (significand >= 20) {
      exp++;
      significand = 2;
      precision = exp >= 0 ? 1 : precision;
    }
    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
  }
  const lastTick = finiteOrDefault(generationOptions.max, value);
  ticks.push({
    value: lastTick,
    major: isMajor(lastTick),
    significand
  });
  return ticks;
}
var LogarithmicScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index) {
    const value = LinearScaleBase.prototype.parse.apply(this, [
      raw,
      index
    ]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v2) => min = minDefined ? min : v2;
    const setMax = (v2) => max = maxDefined ? max : v2;
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(changeExponent(min, -1));
        setMax(changeExponent(max, 1));
      }
    }
    if (min <= 0) {
      setMin(changeExponent(max, -1));
    }
    if (max <= 0) {
      setMax(changeExponent(min, 1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
};
__publicField(LogarithmicScale, "id", "logarithmic");
__publicField(LogarithmicScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
});
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults2.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [
    label
  ];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i2 = 0; i2 < valueCount; i2++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i2));
    padding[i2] = opts.padding;
    const pointPosition = scale.getPointPosition(i2, scale.drawingArea + padding[i2], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i2]);
    labelSizes[i2] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i2) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x2 = 0;
  let y2 = 0;
  if (hLimits.start < orig.l) {
    x2 = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x2);
  } else if (hLimits.end > orig.r) {
    x2 = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x2);
  }
  if (vLimits.start < orig.t) {
    y2 = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y2);
  } else if (vLimits.end > orig.b) {
    y2 = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y2);
  }
}
function createPointLabelItem(scale, index, itemOpts) {
  const outerDistance = scale.drawingArea;
  const { extra, additionalAngle, padding, size } = itemOpts;
  const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);
  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
  const y2 = yForAngle(pointLabelPosition.y, size.h, angle);
  const textAlign = getTextAlignForAngle(angle);
  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
  return {
    visible: true,
    x: pointLabelPosition.x,
    y: y2,
    textAlign,
    left,
    top: y2,
    right: left + size.w,
    bottom: y2 + size.h
  };
}
function isNotOverlapped(item, area) {
  if (!area) {
    return true;
  }
  const { left, top, right, bottom } = item;
  const apexesInArea = _isPointInArea({
    x: left,
    y: top
  }, area) || _isPointInArea({
    x: left,
    y: bottom
  }, area) || _isPointInArea({
    x: right,
    y: top
  }, area) || _isPointInArea({
    x: right,
    y: bottom
  }, area);
  return !apexesInArea;
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const { centerPointLabels, display } = opts.pointLabels;
  const itemOpts = {
    extra: getTickBackdropHeight(opts) / 2,
    additionalAngle: centerPointLabels ? PI / valueCount : 0
  };
  let area;
  for (let i2 = 0; i2 < valueCount; i2++) {
    itemOpts.padding = padding[i2];
    itemOpts.size = labelSizes[i2];
    const item = createPointLabelItem(scale, i2, itemOpts);
    items.push(item);
    if (display === "auto") {
      item.visible = isNotOverlapped(item, area);
      if (item.visible) {
        area = item;
      }
    }
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x2, w2, align) {
  if (align === "right") {
    x2 -= w2;
  } else if (align === "center") {
    x2 -= w2 / 2;
  }
  return x2;
}
function yForAngle(y2, h6, angle) {
  if (angle === 90 || angle === 270) {
    y2 -= h6 / 2;
  } else if (angle > 270 || angle < 90) {
    y2 -= h6;
  }
  return y2;
}
function drawPointLabelBox(ctx, opts, item) {
  const { left, top, right, bottom } = item;
  const { backdropColor } = opts;
  if (!isNullOrUndef(backdropColor)) {
    const borderRadius = toTRBLCorners(opts.borderRadius);
    const padding = toPadding(opts.backdropPadding);
    ctx.fillStyle = backdropColor;
    const backdropLeft = left - padding.left;
    const backdropTop = top - padding.top;
    const backdropWidth = right - left + padding.width;
    const backdropHeight = bottom - top + padding.height;
    if (Object.values(borderRadius).some((v2) => v2 !== 0)) {
      ctx.beginPath();
      addRoundedRectPath(ctx, {
        x: backdropLeft,
        y: backdropTop,
        w: backdropWidth,
        h: backdropHeight,
        radius: borderRadius
      });
      ctx.fill();
    } else {
      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
    }
  }
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i2 = labelCount - 1; i2 >= 0; i2--) {
    const item = scale._pointLabelItems[i2];
    if (!item.visible) {
      continue;
    }
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i2));
    drawPointLabelBox(ctx, optsAtIndex, item);
    const plFont = toFont(optsAtIndex.font);
    const { x: x2, y: y2, textAlign } = item;
    renderText(ctx, scale._pointLabels[i2], x2, y2 + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i2 = 1; i2 < labelCount; i2++) {
      pointPosition = scale.getPointPosition(i2, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(borderOpts.dash || []);
  ctx.lineDashOffset = borderOpts.dashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index, label) {
  return createContext(parent, {
    label,
    index,
    type: "pointLabel"
  });
}
var RadialLinearScale = class extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w2 = this.width = this.maxWidth - padding.width;
    const h6 = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w2 / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h6 / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w2, h6) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index) => {
      const label = callback(this.options.pointLabels.callback, [
        value,
        index
      ], this);
      return label || label === 0 ? label : "";
    }).filter((v2, i2) => this.chart.getDataVisibility(i2));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index) {
    const pointLabels = this._pointLabels || [];
    if (index >= 0 && index < pointLabels.length) {
      const pointLabel = pointLabels[index];
      return createPointLabelContext(this.getContext(), index, pointLabel);
    }
  }
  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index, value) {
    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index) {
    return this.getPointPositionForValue(index || 0, this.getBaseValue());
  }
  getPointLabelPosition(index) {
    const { left, top, right, bottom } = this._pointLabelItems[index];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid, border } = opts;
    const labelCount = this._pointLabels.length;
    let i2, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index) => {
        if (index !== 0 || index === 0 && this.min < 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const context = this.getContext(index);
          const optsAtIndex = grid.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i2 = labelCount - 1; i2 >= 0; i2--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i2));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);
        position = this.getPointPosition(i2, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index) => {
      if (index === 0 && this.min >= 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color,
        strokeColor: optsAtIndex.textStrokeColor,
        strokeWidth: optsAtIndex.textStrokeWidth
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
};
__publicField(RadialLinearScale, "id", "radialLinear");
__publicField(RadialLinearScale, "defaults", {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
});
__publicField(RadialLinearScale, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
});
__publicField(RadialLinearScale, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
var INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
};
var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
function sorter(a2, b2) {
  return a2 - b2;
}
function parse2(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round2, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i2 = UNITS.indexOf(minUnit); i2 < ilen - 1; ++i2) {
    const interval = INTERVALS[UNITS[i2]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i2];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i2 = UNITS.length - 1; i2 >= UNITS.indexOf(minUnit); i2--) {
    const unit = UNITS[i2];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i2 = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i2 < ilen; ++i2) {
    if (INTERVALS[UNITS[i2]].common) {
      return UNITS[i2];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map3, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index = map3[major];
    if (index >= 0) {
      ticks[index].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map3 = {};
  const ilen = values.length;
  let i2, value;
  for (i2 = 0; i2 < ilen; ++i2) {
    value = values[i2];
    map3[value] = i2;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
}
var TimeScale = class extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts = {}) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index) {
    if (raw === void 0) {
      return null;
    }
    return parse2(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return {
      min,
      max
    };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps = []) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {
      start,
      end,
      factor: 1 / (start + 1 + end)
    };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(options.ticks.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort(sorter).map((x2) => +x2);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  format(value, format) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const fmt = format || formats[unit];
    return this._adapter.format(value, fmt);
  }
  _tickFormatFunction(time, index, ticks, format) {
    const options = this.options;
    const formatter = options.ticks.callback;
    if (formatter) {
      return callback(formatter, [
        time,
        index,
        ticks
      ], this);
    }
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index];
    const major = majorUnit && majorFormat && tick && tick.major;
    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
  }
  generateTickLabels(ticks) {
    let i2, ilen, tick;
    for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
      tick = ticks[i2];
      tick.label = this._tickFormatFunction(tick.value, i2, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
      exampleTime
    ], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i2, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
      timestamps = timestamps.concat(metas[i2].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i2, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i2 = 0, ilen = labels.length; i2 < ilen; ++i2) {
      timestamps.push(parse2(this, labels[i2]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
};
__publicField(TimeScale, "id", "time");
__publicField(TimeScale, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: false,
    major: {
      enabled: false
    }
  }
});
function interpolate3(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale = class extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate3(table, this.min);
    this._tableRange = interpolate3(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i2, ilen, prev, curr, next;
    for (i2 = 0, ilen = timestamps.length; i2 < ilen; ++i2) {
      curr = timestamps[i2];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {
          time: min,
          pos: 0
        },
        {
          time: max,
          pos: 1
        }
      ];
    }
    for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
      next = items[i2 + 1];
      prev = items[i2 - 1];
      curr = items[i2];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i2 / (ilen - 1)
        });
      }
    }
    return table;
  }
  _generate() {
    const min = this.min;
    const max = this.max;
    let timestamps = super.getDataTimestamps();
    if (!timestamps.includes(min) || !timestamps.length) {
      timestamps.splice(0, 0, min);
    }
    if (!timestamps.includes(max) || timestamps.length === 1) {
      timestamps.push(max);
    }
    return timestamps.sort((a2, b2) => a2 - b2);
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate3(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate3(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
__publicField(TimeSeriesScale, "id", "timeseries");
__publicField(TimeSeriesScale, "defaults", TimeScale.defaults);

// node_modules/.pnpm/gridjs@6.2.0/node_modules/gridjs/dist/gridjs.module.js
function t2(t3, n2) {
  for (var e2 = 0; e2 < n2.length; e2++) {
    var r2 = n2[e2];
    r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t3, "symbol" == typeof (o2 = function(t4, n3) {
      if ("object" != typeof t4 || null === t4) return t4;
      var e3 = t4[Symbol.toPrimitive];
      if (void 0 !== e3) {
        var r3 = e3.call(t4, "string");
        if ("object" != typeof r3) return r3;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return String(t4);
    }(r2.key)) ? o2 : String(o2), r2);
  }
  var o2;
}
function n(n2, e2, r2) {
  return e2 && t2(n2.prototype, e2), r2 && t2(n2, r2), Object.defineProperty(n2, "prototype", { writable: false }), n2;
}
function e() {
  return e = Object.assign ? Object.assign.bind() : function(t3) {
    for (var n2 = 1; n2 < arguments.length; n2++) {
      var e2 = arguments[n2];
      for (var r2 in e2) Object.prototype.hasOwnProperty.call(e2, r2) && (t3[r2] = e2[r2]);
    }
    return t3;
  }, e.apply(this, arguments);
}
function r(t3, n2) {
  t3.prototype = Object.create(n2.prototype), t3.prototype.constructor = t3, o(t3, n2);
}
function o(t3, n2) {
  return o = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, n3) {
    return t4.__proto__ = n3, t4;
  }, o(t3, n2);
}
function i(t3) {
  if (void 0 === t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t3;
}
function u(t3, n2) {
  (null == n2 || n2 > t3.length) && (n2 = t3.length);
  for (var e2 = 0, r2 = new Array(n2); e2 < n2; e2++) r2[e2] = t3[e2];
  return r2;
}
function s(t3, n2) {
  var e2 = "undefined" != typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
  if (e2) return (e2 = e2.call(t3)).next.bind(e2);
  if (Array.isArray(t3) || (e2 = function(t4, n3) {
    if (t4) {
      if ("string" == typeof t4) return u(t4, n3);
      var e3 = Object.prototype.toString.call(t4).slice(8, -1);
      return "Object" === e3 && t4.constructor && (e3 = t4.constructor.name), "Map" === e3 || "Set" === e3 ? Array.from(t4) : "Arguments" === e3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e3) ? u(t4, n3) : void 0;
    }
  }(t3)) || n2 && t3 && "number" == typeof t3.length) {
    e2 && (t3 = e2);
    var r2 = 0;
    return function() {
      return r2 >= t3.length ? { done: true } : { done: false, value: t3[r2++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var a;
!function(t3) {
  t3[t3.Init = 0] = "Init", t3[t3.Loading = 1] = "Loading", t3[t3.Loaded = 2] = "Loaded", t3[t3.Rendered = 3] = "Rendered", t3[t3.Error = 4] = "Error";
}(a || (a = {}));
var l;
var c;
var f;
var p;
var d;
var h;
var _;
var m = {};
var v = [];
var y = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function g(t3, n2) {
  for (var e2 in n2) t3[e2] = n2[e2];
  return t3;
}
function b(t3) {
  var n2 = t3.parentNode;
  n2 && n2.removeChild(t3);
}
function w(t3, n2, e2) {
  var r2, o2, i2, u2 = {};
  for (i2 in n2) "key" == i2 ? r2 = n2[i2] : "ref" == i2 ? o2 = n2[i2] : u2[i2] = n2[i2];
  if (arguments.length > 2 && (u2.children = arguments.length > 3 ? l.call(arguments, 2) : e2), "function" == typeof t3 && null != t3.defaultProps) for (i2 in t3.defaultProps) void 0 === u2[i2] && (u2[i2] = t3.defaultProps[i2]);
  return x(t3, u2, r2, o2, null);
}
function x(t3, n2, e2, r2, o2) {
  var i2 = { type: t3, props: n2, key: e2, ref: r2, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == o2 ? ++f : o2 };
  return null == o2 && null != c.vnode && c.vnode(i2), i2;
}
function S(t3) {
  return t3.children;
}
function N(t3, n2) {
  this.props = t3, this.context = n2;
}
function P(t3, n2) {
  if (null == n2) return t3.__ ? P(t3.__, t3.__.__k.indexOf(t3) + 1) : null;
  for (var e2; n2 < t3.__k.length; n2++) if (null != (e2 = t3.__k[n2]) && null != e2.__e) return e2.__e;
  return "function" == typeof t3.type ? P(t3) : null;
}
function C(t3) {
  var n2, e2;
  if (null != (t3 = t3.__) && null != t3.__c) {
    for (t3.__e = t3.__c.base = null, n2 = 0; n2 < t3.__k.length; n2++) if (null != (e2 = t3.__k[n2]) && null != e2.__e) {
      t3.__e = t3.__c.base = e2.__e;
      break;
    }
    return C(t3);
  }
}
function E(t3) {
  (!t3.__d && (t3.__d = true) && d.push(t3) && !I.__r++ || h !== c.debounceRendering) && ((h = c.debounceRendering) || setTimeout)(I);
}
function I() {
  for (var t3; I.__r = d.length; ) t3 = d.sort(function(t4, n2) {
    return t4.__v.__b - n2.__v.__b;
  }), d = [], t3.some(function(t4) {
    var n2, e2, r2, o2, i2, u2;
    t4.__d && (i2 = (o2 = (n2 = t4).__v).__e, (u2 = n2.__P) && (e2 = [], (r2 = g({}, o2)).__v = o2.__v + 1, M(u2, o2, r2, n2.__n, void 0 !== u2.ownerSVGElement, null != o2.__h ? [i2] : null, e2, null == i2 ? P(o2) : i2, o2.__h), F(e2, o2), o2.__e != i2 && C(o2)));
  });
}
function T(t3, n2, e2, r2, o2, i2, u2, s2, a2, l2) {
  var c2, f2, p2, d2, h6, _2, y2, g2 = r2 && r2.__k || v, b2 = g2.length;
  for (e2.__k = [], c2 = 0; c2 < n2.length; c2++) if (null != (d2 = e2.__k[c2] = null == (d2 = n2[c2]) || "boolean" == typeof d2 ? null : "string" == typeof d2 || "number" == typeof d2 || "bigint" == typeof d2 ? x(null, d2, null, null, d2) : Array.isArray(d2) ? x(S, { children: d2 }, null, null, null) : d2.__b > 0 ? x(d2.type, d2.props, d2.key, d2.ref ? d2.ref : null, d2.__v) : d2)) {
    if (d2.__ = e2, d2.__b = e2.__b + 1, null === (p2 = g2[c2]) || p2 && d2.key == p2.key && d2.type === p2.type) g2[c2] = void 0;
    else for (f2 = 0; f2 < b2; f2++) {
      if ((p2 = g2[f2]) && d2.key == p2.key && d2.type === p2.type) {
        g2[f2] = void 0;
        break;
      }
      p2 = null;
    }
    M(t3, d2, p2 = p2 || m, o2, i2, u2, s2, a2, l2), h6 = d2.__e, (f2 = d2.ref) && p2.ref != f2 && (y2 || (y2 = []), p2.ref && y2.push(p2.ref, null, d2), y2.push(f2, d2.__c || h6, d2)), null != h6 ? (null == _2 && (_2 = h6), "function" == typeof d2.type && d2.__k === p2.__k ? d2.__d = a2 = L(d2, a2, t3) : a2 = A(t3, d2, p2, g2, h6, a2), "function" == typeof e2.type && (e2.__d = a2)) : a2 && p2.__e == a2 && a2.parentNode != t3 && (a2 = P(p2));
  }
  for (e2.__e = _2, c2 = b2; c2--; ) null != g2[c2] && W(g2[c2], g2[c2]);
  if (y2) for (c2 = 0; c2 < y2.length; c2++) U(y2[c2], y2[++c2], y2[++c2]);
}
function L(t3, n2, e2) {
  for (var r2, o2 = t3.__k, i2 = 0; o2 && i2 < o2.length; i2++) (r2 = o2[i2]) && (r2.__ = t3, n2 = "function" == typeof r2.type ? L(r2, n2, e2) : A(e2, r2, r2, o2, r2.__e, n2));
  return n2;
}
function A(t3, n2, e2, r2, o2, i2) {
  var u2, s2, a2;
  if (void 0 !== n2.__d) u2 = n2.__d, n2.__d = void 0;
  else if (null == e2 || o2 != i2 || null == o2.parentNode) t: if (null == i2 || i2.parentNode !== t3) t3.appendChild(o2), u2 = null;
  else {
    for (s2 = i2, a2 = 0; (s2 = s2.nextSibling) && a2 < r2.length; a2 += 1) if (s2 == o2) break t;
    t3.insertBefore(o2, i2), u2 = i2;
  }
  return void 0 !== u2 ? u2 : o2.nextSibling;
}
function O(t3, n2, e2) {
  "-" === n2[0] ? t3.setProperty(n2, e2) : t3[n2] = null == e2 ? "" : "number" != typeof e2 || y.test(n2) ? e2 : e2 + "px";
}
function H(t3, n2, e2, r2, o2) {
  var i2;
  t: if ("style" === n2) if ("string" == typeof e2) t3.style.cssText = e2;
  else {
    if ("string" == typeof r2 && (t3.style.cssText = r2 = ""), r2) for (n2 in r2) e2 && n2 in e2 || O(t3.style, n2, "");
    if (e2) for (n2 in e2) r2 && e2[n2] === r2[n2] || O(t3.style, n2, e2[n2]);
  }
  else if ("o" === n2[0] && "n" === n2[1]) i2 = n2 !== (n2 = n2.replace(/Capture$/, "")), n2 = n2.toLowerCase() in t3 ? n2.toLowerCase().slice(2) : n2.slice(2), t3.l || (t3.l = {}), t3.l[n2 + i2] = e2, e2 ? r2 || t3.addEventListener(n2, i2 ? D : j, i2) : t3.removeEventListener(n2, i2 ? D : j, i2);
  else if ("dangerouslySetInnerHTML" !== n2) {
    if (o2) n2 = n2.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("href" !== n2 && "list" !== n2 && "form" !== n2 && "tabIndex" !== n2 && "download" !== n2 && n2 in t3) try {
      t3[n2] = null == e2 ? "" : e2;
      break t;
    } catch (t4) {
    }
    "function" == typeof e2 || (null == e2 || false === e2 && -1 == n2.indexOf("-") ? t3.removeAttribute(n2) : t3.setAttribute(n2, e2));
  }
}
function j(t3) {
  this.l[t3.type + false](c.event ? c.event(t3) : t3);
}
function D(t3) {
  this.l[t3.type + true](c.event ? c.event(t3) : t3);
}
function M(t3, n2, e2, r2, o2, i2, u2, s2, a2) {
  var l2, f2, p2, d2, h6, _2, m2, v2, y2, b2, w2, x2, k, P2, C2, E2 = n2.type;
  if (void 0 !== n2.constructor) return null;
  null != e2.__h && (a2 = e2.__h, s2 = n2.__e = e2.__e, n2.__h = null, i2 = [s2]), (l2 = c.__b) && l2(n2);
  try {
    t: if ("function" == typeof E2) {
      if (v2 = n2.props, y2 = (l2 = E2.contextType) && r2[l2.__c], b2 = l2 ? y2 ? y2.props.value : l2.__ : r2, e2.__c ? m2 = (f2 = n2.__c = e2.__c).__ = f2.__E : ("prototype" in E2 && E2.prototype.render ? n2.__c = f2 = new E2(v2, b2) : (n2.__c = f2 = new N(v2, b2), f2.constructor = E2, f2.render = B), y2 && y2.sub(f2), f2.props = v2, f2.state || (f2.state = {}), f2.context = b2, f2.__n = r2, p2 = f2.__d = true, f2.__h = [], f2._sb = []), null == f2.__s && (f2.__s = f2.state), null != E2.getDerivedStateFromProps && (f2.__s == f2.state && (f2.__s = g({}, f2.__s)), g(f2.__s, E2.getDerivedStateFromProps(v2, f2.__s))), d2 = f2.props, h6 = f2.state, p2) null == E2.getDerivedStateFromProps && null != f2.componentWillMount && f2.componentWillMount(), null != f2.componentDidMount && f2.__h.push(f2.componentDidMount);
      else {
        if (null == E2.getDerivedStateFromProps && v2 !== d2 && null != f2.componentWillReceiveProps && f2.componentWillReceiveProps(v2, b2), !f2.__e && null != f2.shouldComponentUpdate && false === f2.shouldComponentUpdate(v2, f2.__s, b2) || n2.__v === e2.__v) {
          for (f2.props = v2, f2.state = f2.__s, n2.__v !== e2.__v && (f2.__d = false), f2.__v = n2, n2.__e = e2.__e, n2.__k = e2.__k, n2.__k.forEach(function(t4) {
            t4 && (t4.__ = n2);
          }), w2 = 0; w2 < f2._sb.length; w2++) f2.__h.push(f2._sb[w2]);
          f2._sb = [], f2.__h.length && u2.push(f2);
          break t;
        }
        null != f2.componentWillUpdate && f2.componentWillUpdate(v2, f2.__s, b2), null != f2.componentDidUpdate && f2.__h.push(function() {
          f2.componentDidUpdate(d2, h6, _2);
        });
      }
      if (f2.context = b2, f2.props = v2, f2.__v = n2, f2.__P = t3, x2 = c.__r, k = 0, "prototype" in E2 && E2.prototype.render) {
        for (f2.state = f2.__s, f2.__d = false, x2 && x2(n2), l2 = f2.render(f2.props, f2.state, f2.context), P2 = 0; P2 < f2._sb.length; P2++) f2.__h.push(f2._sb[P2]);
        f2._sb = [];
      } else do {
        f2.__d = false, x2 && x2(n2), l2 = f2.render(f2.props, f2.state, f2.context), f2.state = f2.__s;
      } while (f2.__d && ++k < 25);
      f2.state = f2.__s, null != f2.getChildContext && (r2 = g(g({}, r2), f2.getChildContext())), p2 || null == f2.getSnapshotBeforeUpdate || (_2 = f2.getSnapshotBeforeUpdate(d2, h6)), C2 = null != l2 && l2.type === S && null == l2.key ? l2.props.children : l2, T(t3, Array.isArray(C2) ? C2 : [C2], n2, e2, r2, o2, i2, u2, s2, a2), f2.base = n2.__e, n2.__h = null, f2.__h.length && u2.push(f2), m2 && (f2.__E = f2.__ = null), f2.__e = false;
    } else null == i2 && n2.__v === e2.__v ? (n2.__k = e2.__k, n2.__e = e2.__e) : n2.__e = R(e2.__e, n2, e2, r2, o2, i2, u2, a2);
    (l2 = c.diffed) && l2(n2);
  } catch (t4) {
    n2.__v = null, (a2 || null != i2) && (n2.__e = s2, n2.__h = !!a2, i2[i2.indexOf(s2)] = null), c.__e(t4, n2, e2);
  }
}
function F(t3, n2) {
  c.__c && c.__c(n2, t3), t3.some(function(n3) {
    try {
      t3 = n3.__h, n3.__h = [], t3.some(function(t4) {
        t4.call(n3);
      });
    } catch (t4) {
      c.__e(t4, n3.__v);
    }
  });
}
function R(t3, n2, e2, r2, o2, i2, u2, s2) {
  var a2, c2, f2, p2 = e2.props, d2 = n2.props, h6 = n2.type, _2 = 0;
  if ("svg" === h6 && (o2 = true), null != i2) {
    for (; _2 < i2.length; _2++) if ((a2 = i2[_2]) && "setAttribute" in a2 == !!h6 && (h6 ? a2.localName === h6 : 3 === a2.nodeType)) {
      t3 = a2, i2[_2] = null;
      break;
    }
  }
  if (null == t3) {
    if (null === h6) return document.createTextNode(d2);
    t3 = o2 ? document.createElementNS("http://www.w3.org/2000/svg", h6) : document.createElement(h6, d2.is && d2), i2 = null, s2 = false;
  }
  if (null === h6) p2 === d2 || s2 && t3.data === d2 || (t3.data = d2);
  else {
    if (i2 = i2 && l.call(t3.childNodes), c2 = (p2 = e2.props || m).dangerouslySetInnerHTML, f2 = d2.dangerouslySetInnerHTML, !s2) {
      if (null != i2) for (p2 = {}, _2 = 0; _2 < t3.attributes.length; _2++) p2[t3.attributes[_2].name] = t3.attributes[_2].value;
      (f2 || c2) && (f2 && (c2 && f2.__html == c2.__html || f2.__html === t3.innerHTML) || (t3.innerHTML = f2 && f2.__html || ""));
    }
    if (function(t4, n3, e3, r3, o3) {
      var i3;
      for (i3 in e3) "children" === i3 || "key" === i3 || i3 in n3 || H(t4, i3, null, e3[i3], r3);
      for (i3 in n3) o3 && "function" != typeof n3[i3] || "children" === i3 || "key" === i3 || "value" === i3 || "checked" === i3 || e3[i3] === n3[i3] || H(t4, i3, n3[i3], e3[i3], r3);
    }(t3, d2, p2, o2, s2), f2) n2.__k = [];
    else if (_2 = n2.props.children, T(t3, Array.isArray(_2) ? _2 : [_2], n2, e2, r2, o2 && "foreignObject" !== h6, i2, u2, i2 ? i2[0] : e2.__k && P(e2, 0), s2), null != i2) for (_2 = i2.length; _2--; ) null != i2[_2] && b(i2[_2]);
    s2 || ("value" in d2 && void 0 !== (_2 = d2.value) && (_2 !== t3.value || "progress" === h6 && !_2 || "option" === h6 && _2 !== p2.value) && H(t3, "value", _2, p2.value, false), "checked" in d2 && void 0 !== (_2 = d2.checked) && _2 !== t3.checked && H(t3, "checked", _2, p2.checked, false));
  }
  return t3;
}
function U(t3, n2, e2) {
  try {
    "function" == typeof t3 ? t3(n2) : t3.current = n2;
  } catch (t4) {
    c.__e(t4, e2);
  }
}
function W(t3, n2, e2) {
  var r2, o2;
  if (c.unmount && c.unmount(t3), (r2 = t3.ref) && (r2.current && r2.current !== t3.__e || U(r2, null, n2)), null != (r2 = t3.__c)) {
    if (r2.componentWillUnmount) try {
      r2.componentWillUnmount();
    } catch (t4) {
      c.__e(t4, n2);
    }
    r2.base = r2.__P = null, t3.__c = void 0;
  }
  if (r2 = t3.__k) for (o2 = 0; o2 < r2.length; o2++) r2[o2] && W(r2[o2], n2, e2 || "function" != typeof t3.type);
  e2 || null == t3.__e || b(t3.__e), t3.__ = t3.__e = t3.__d = void 0;
}
function B(t3, n2, e2) {
  return this.constructor(t3, e2);
}
function q(t3, n2, e2) {
  var r2, o2, i2;
  c.__ && c.__(t3, n2), o2 = (r2 = "function" == typeof e2) ? null : e2 && e2.__k || n2.__k, i2 = [], M(n2, t3 = (!r2 && e2 || n2).__k = w(S, null, [t3]), o2 || m, m, void 0 !== n2.ownerSVGElement, !r2 && e2 ? [e2] : o2 ? null : n2.firstChild ? l.call(n2.childNodes) : null, i2, !r2 && e2 ? e2 : o2 ? o2.__e : n2.firstChild, r2), F(i2, t3);
}
function z() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(t3) {
    var n2 = 16 * Math.random() | 0;
    return ("x" == t3 ? n2 : 3 & n2 | 8).toString(16);
  });
}
l = v.slice, c = { __e: function(t3, n2, e2, r2) {
  for (var o2, i2, u2; n2 = n2.__; ) if ((o2 = n2.__c) && !o2.__) try {
    if ((i2 = o2.constructor) && null != i2.getDerivedStateFromError && (o2.setState(i2.getDerivedStateFromError(t3)), u2 = o2.__d), null != o2.componentDidCatch && (o2.componentDidCatch(t3, r2 || {}), u2 = o2.__d), u2) return o2.__E = o2;
  } catch (n3) {
    t3 = n3;
  }
  throw t3;
} }, f = 0, p = function(t3) {
  return null != t3 && void 0 === t3.constructor;
}, N.prototype.setState = function(t3, n2) {
  var e2;
  e2 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = g({}, this.state), "function" == typeof t3 && (t3 = t3(g({}, e2), this.props)), t3 && g(e2, t3), null != t3 && this.__v && (n2 && this._sb.push(n2), E(this));
}, N.prototype.forceUpdate = function(t3) {
  this.__v && (this.__e = true, t3 && this.__h.push(t3), E(this));
}, N.prototype.render = S, d = [], I.__r = 0, _ = 0;
var V = /* @__PURE__ */ function() {
  function t3(t4) {
    this._id = void 0, this._id = t4 || z();
  }
  return n(t3, [{ key: "id", get: function() {
    return this._id;
  } }]), t3;
}();
function $(t3) {
  return w(t3.parentElement || "span", { dangerouslySetInnerHTML: { __html: t3.content } });
}
function G(t3, n2) {
  return w($, { content: t3, parentElement: n2 });
}
var K;
var X = /* @__PURE__ */ function(t3) {
  function n2(n3) {
    var e3;
    return (e3 = t3.call(this) || this).data = void 0, e3.update(n3), e3;
  }
  r(n2, t3);
  var e2 = n2.prototype;
  return e2.cast = function(t4) {
    return t4 instanceof HTMLElement ? G(t4.outerHTML) : t4;
  }, e2.update = function(t4) {
    return this.data = this.cast(t4), this;
  }, n2;
}(V);
var Z = /* @__PURE__ */ function(t3) {
  function e2(n2) {
    var e3;
    return (e3 = t3.call(this) || this)._cells = void 0, e3.cells = n2 || [], e3;
  }
  r(e2, t3);
  var o2 = e2.prototype;
  return o2.cell = function(t4) {
    return this._cells[t4];
  }, o2.toArray = function() {
    return this.cells.map(function(t4) {
      return t4.data;
    });
  }, e2.fromCells = function(t4) {
    return new e2(t4.map(function(t5) {
      return new X(t5.data);
    }));
  }, n(e2, [{ key: "cells", get: function() {
    return this._cells;
  }, set: function(t4) {
    this._cells = t4;
  } }, { key: "length", get: function() {
    return this.cells.length;
  } }]), e2;
}(V);
var J = /* @__PURE__ */ function(t3) {
  function e2(n2) {
    var e3;
    return (e3 = t3.call(this) || this)._rows = void 0, e3._length = void 0, e3.rows = n2 instanceof Array ? n2 : n2 instanceof Z ? [n2] : [], e3;
  }
  return r(e2, t3), e2.prototype.toArray = function() {
    return this.rows.map(function(t4) {
      return t4.toArray();
    });
  }, e2.fromRows = function(t4) {
    return new e2(t4.map(function(t5) {
      return Z.fromCells(t5.cells);
    }));
  }, e2.fromArray = function(t4) {
    return new e2((t4 = function(t5) {
      return !t5[0] || t5[0] instanceof Array ? t5 : [t5];
    }(t4)).map(function(t5) {
      return new Z(t5.map(function(t6) {
        return new X(t6);
      }));
    }));
  }, n(e2, [{ key: "rows", get: function() {
    return this._rows;
  }, set: function(t4) {
    this._rows = t4;
  } }, { key: "length", get: function() {
    return this._length || this.rows.length;
  }, set: function(t4) {
    this._length = t4;
  } }]), e2;
}(V);
var Q = /* @__PURE__ */ function() {
  function t3() {
    this.callbacks = void 0;
  }
  var n2 = t3.prototype;
  return n2.init = function(t4) {
    this.callbacks || (this.callbacks = {}), t4 && !this.callbacks[t4] && (this.callbacks[t4] = []);
  }, n2.listeners = function() {
    return this.callbacks;
  }, n2.on = function(t4, n3) {
    return this.init(t4), this.callbacks[t4].push(n3), this;
  }, n2.off = function(t4, n3) {
    var e2 = t4;
    return this.init(), this.callbacks[e2] && 0 !== this.callbacks[e2].length ? (this.callbacks[e2] = this.callbacks[e2].filter(function(t5) {
      return t5 != n3;
    }), this) : this;
  }, n2.emit = function(t4) {
    var n3 = arguments, e2 = t4;
    return this.init(e2), this.callbacks[e2].length > 0 && (this.callbacks[e2].forEach(function(t5) {
      return t5.apply(void 0, [].slice.call(n3, 1));
    }), true);
  }, t3;
}();
function Y(t3, n2) {
  if (typeof t3 != typeof n2) return false;
  if (null === t3 && null === n2) return true;
  if ("object" != typeof t3) return t3 === n2;
  if (Array.isArray(t3) && Array.isArray(n2)) {
    if (t3.length !== n2.length) return false;
    for (var e2 = 0; e2 < t3.length; e2++) if (!Y(t3[e2], n2[e2])) return false;
    return true;
  }
  if (t3.hasOwnProperty("constructor") && n2.hasOwnProperty("constructor") && t3.hasOwnProperty("props") && n2.hasOwnProperty("props") && t3.hasOwnProperty("key") && n2.hasOwnProperty("key") && t3.hasOwnProperty("ref") && n2.hasOwnProperty("ref") && t3.hasOwnProperty("type") && n2.hasOwnProperty("type")) return Y(t3.props, n2.props);
  var r2 = Object.keys(t3), o2 = Object.keys(n2);
  if (r2.length !== o2.length) return false;
  for (var i2 = 0, u2 = r2; i2 < u2.length; i2++) {
    var s2 = u2[i2];
    if (!n2.hasOwnProperty(s2) || !Y(t3[s2], n2[s2])) return false;
  }
  return true;
}
!function(t3) {
  t3[t3.Initiator = 0] = "Initiator", t3[t3.ServerFilter = 1] = "ServerFilter", t3[t3.ServerSort = 2] = "ServerSort", t3[t3.ServerLimit = 3] = "ServerLimit", t3[t3.Extractor = 4] = "Extractor", t3[t3.Transformer = 5] = "Transformer", t3[t3.Filter = 6] = "Filter", t3[t3.Sort = 7] = "Sort", t3[t3.Limit = 8] = "Limit";
}(K || (K = {}));
var tt = /* @__PURE__ */ function(t3) {
  function o2(n2) {
    var e2;
    return (e2 = t3.call(this) || this).id = void 0, e2._props = void 0, e2._props = {}, e2.id = z(), n2 && e2.setProps(n2), e2;
  }
  r(o2, t3);
  var i2 = o2.prototype;
  return i2.process = function() {
    var t4 = [].slice.call(arguments);
    this.validateProps instanceof Function && this.validateProps.apply(this, t4), this.emit.apply(this, ["beforeProcess"].concat(t4));
    var n2 = this._process.apply(this, t4);
    return this.emit.apply(this, ["afterProcess"].concat(t4)), n2;
  }, i2.setProps = function(t4) {
    var n2 = e({}, this._props, t4);
    return Y(n2, this._props) || (this._props = n2, this.emit("propsUpdated", this)), this;
  }, n(o2, [{ key: "props", get: function() {
    return this._props;
  } }]), o2;
}(Q);
var nt = /* @__PURE__ */ function(t3) {
  function e2() {
    return t3.apply(this, arguments) || this;
  }
  return r(e2, t3), e2.prototype._process = function(t4) {
    return this.props.keyword ? (n2 = String(this.props.keyword).trim(), e3 = this.props.columns, r2 = this.props.ignoreHiddenColumns, o2 = t4, i2 = this.props.selector, n2 = n2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), new J(o2.rows.filter(function(t5, o3) {
      return t5.cells.some(function(t6, u2) {
        if (!t6) return false;
        if (r2 && e3 && e3[u2] && "object" == typeof e3[u2] && e3[u2].hidden) return false;
        var s2 = "";
        if ("function" == typeof i2) s2 = i2(t6.data, o3, u2);
        else if ("object" == typeof t6.data) {
          var a2 = t6.data;
          a2 && a2.props && a2.props.content && (s2 = a2.props.content);
        } else s2 = String(t6.data);
        return new RegExp(n2, "gi").test(s2);
      });
    }))) : t4;
    var n2, e3, r2, o2, i2;
  }, n(e2, [{ key: "type", get: function() {
    return K.Filter;
  } }]), e2;
}(tt);
function et() {
  var t3 = "gridjs";
  return "" + t3 + [].slice.call(arguments).reduce(function(t4, n2) {
    return t4 + "-" + n2;
  }, "");
}
function rt() {
  return [].slice.call(arguments).map(function(t3) {
    return t3 ? t3.toString() : "";
  }).filter(function(t3) {
    return t3;
  }).reduce(function(t3, n2) {
    return (t3 || "") + " " + n2;
  }, "").trim();
}
var ot;
var it;
var ut;
var st;
var at = /* @__PURE__ */ function(t3) {
  function o2() {
    return t3.apply(this, arguments) || this;
  }
  return r(o2, t3), o2.prototype._process = function(t4) {
    if (!this.props.keyword) return t4;
    var n2 = {};
    return this.props.url && (n2.url = this.props.url(t4.url, this.props.keyword)), this.props.body && (n2.body = this.props.body(t4.body, this.props.keyword)), e({}, t4, n2);
  }, n(o2, [{ key: "type", get: function() {
    return K.ServerFilter;
  } }]), o2;
}(tt);
var lt = 0;
var ct = [];
var ft = [];
var pt = c.__b;
var dt = c.__r;
var ht = c.diffed;
var _t = c.__c;
var mt = c.unmount;
function vt(t3, n2) {
  c.__h && c.__h(it, t3, lt || n2), lt = 0;
  var e2 = it.__H || (it.__H = { __: [], __h: [] });
  return t3 >= e2.__.length && e2.__.push({ __V: ft }), e2.__[t3];
}
function yt(t3) {
  return lt = 1, function(t4, n2, e2) {
    var r2 = vt(ot++, 2);
    if (r2.t = t4, !r2.__c && (r2.__ = [Et(void 0, n2), function(t5) {
      var n3 = r2.__N ? r2.__N[0] : r2.__[0], e3 = r2.t(n3, t5);
      n3 !== e3 && (r2.__N = [e3, r2.__[1]], r2.__c.setState({}));
    }], r2.__c = it, !it.u)) {
      it.u = true;
      var o2 = it.shouldComponentUpdate;
      it.shouldComponentUpdate = function(t5, n3, e3) {
        if (!r2.__c.__H) return true;
        var i2 = r2.__c.__H.__.filter(function(t6) {
          return t6.__c;
        });
        if (i2.every(function(t6) {
          return !t6.__N;
        })) return !o2 || o2.call(this, t5, n3, e3);
        var u2 = false;
        return i2.forEach(function(t6) {
          if (t6.__N) {
            var n4 = t6.__[0];
            t6.__ = t6.__N, t6.__N = void 0, n4 !== t6.__[0] && (u2 = true);
          }
        }), !(!u2 && r2.__c.props === t5) && (!o2 || o2.call(this, t5, n3, e3));
      };
    }
    return r2.__N || r2.__;
  }(Et, t3);
}
function gt(t3, n2) {
  var e2 = vt(ot++, 3);
  !c.__s && Ct(e2.__H, n2) && (e2.__ = t3, e2.i = n2, it.__H.__h.push(e2));
}
function bt(t3) {
  return lt = 5, wt(function() {
    return { current: t3 };
  }, []);
}
function wt(t3, n2) {
  var e2 = vt(ot++, 7);
  return Ct(e2.__H, n2) ? (e2.__V = t3(), e2.i = n2, e2.__h = t3, e2.__V) : e2.__;
}
function xt() {
  for (var t3; t3 = ct.shift(); ) if (t3.__P && t3.__H) try {
    t3.__H.__h.forEach(Nt), t3.__H.__h.forEach(Pt), t3.__H.__h = [];
  } catch (n2) {
    t3.__H.__h = [], c.__e(n2, t3.__v);
  }
}
c.__b = function(t3) {
  it = null, pt && pt(t3);
}, c.__r = function(t3) {
  dt && dt(t3), ot = 0;
  var n2 = (it = t3.__c).__H;
  n2 && (ut === it ? (n2.__h = [], it.__h = [], n2.__.forEach(function(t4) {
    t4.__N && (t4.__ = t4.__N), t4.__V = ft, t4.__N = t4.i = void 0;
  })) : (n2.__h.forEach(Nt), n2.__h.forEach(Pt), n2.__h = [])), ut = it;
}, c.diffed = function(t3) {
  ht && ht(t3);
  var n2 = t3.__c;
  n2 && n2.__H && (n2.__H.__h.length && (1 !== ct.push(n2) && st === c.requestAnimationFrame || ((st = c.requestAnimationFrame) || St)(xt)), n2.__H.__.forEach(function(t4) {
    t4.i && (t4.__H = t4.i), t4.__V !== ft && (t4.__ = t4.__V), t4.i = void 0, t4.__V = ft;
  })), ut = it = null;
}, c.__c = function(t3, n2) {
  n2.some(function(t4) {
    try {
      t4.__h.forEach(Nt), t4.__h = t4.__h.filter(function(t5) {
        return !t5.__ || Pt(t5);
      });
    } catch (e2) {
      n2.some(function(t5) {
        t5.__h && (t5.__h = []);
      }), n2 = [], c.__e(e2, t4.__v);
    }
  }), _t && _t(t3, n2);
}, c.unmount = function(t3) {
  mt && mt(t3);
  var n2, e2 = t3.__c;
  e2 && e2.__H && (e2.__H.__.forEach(function(t4) {
    try {
      Nt(t4);
    } catch (t5) {
      n2 = t5;
    }
  }), e2.__H = void 0, n2 && c.__e(n2, e2.__v));
};
var kt = "function" == typeof requestAnimationFrame;
function St(t3) {
  var n2, e2 = function() {
    clearTimeout(r2), kt && cancelAnimationFrame(n2), setTimeout(t3);
  }, r2 = setTimeout(e2, 100);
  kt && (n2 = requestAnimationFrame(e2));
}
function Nt(t3) {
  var n2 = it, e2 = t3.__c;
  "function" == typeof e2 && (t3.__c = void 0, e2()), it = n2;
}
function Pt(t3) {
  var n2 = it;
  t3.__c = t3.__(), it = n2;
}
function Ct(t3, n2) {
  return !t3 || t3.length !== n2.length || n2.some(function(n3, e2) {
    return n3 !== t3[e2];
  });
}
function Et(t3, n2) {
  return "function" == typeof n2 ? n2(t3) : n2;
}
function It() {
  return function(t3) {
    var n2 = it.context[t3.__c], e2 = vt(ot++, 9);
    return e2.c = t3, n2 ? (null == e2.__ && (e2.__ = true, n2.sub(it)), n2.props.value) : t3.__;
  }(fn);
}
var Tt = { search: { placeholder: "Type a keyword..." }, sort: { sortAsc: "Sort column ascending", sortDesc: "Sort column descending" }, pagination: { previous: "Previous", next: "Next", navigate: function(t3, n2) {
  return "Page " + t3 + " of " + n2;
}, page: function(t3) {
  return "Page " + t3;
}, showing: "Showing", of: "of", to: "to", results: "results" }, loading: "Loading...", noRecordsFound: "No matching records found", error: "An error happened while fetching the data" };
var Lt = /* @__PURE__ */ function() {
  function t3(t4) {
    this._language = void 0, this._defaultLanguage = void 0, this._language = t4, this._defaultLanguage = Tt;
  }
  var n2 = t3.prototype;
  return n2.getString = function(t4, n3) {
    if (!n3 || !t4) return null;
    var e2 = t4.split("."), r2 = e2[0];
    if (n3[r2]) {
      var o2 = n3[r2];
      return "string" == typeof o2 ? function() {
        return o2;
      } : "function" == typeof o2 ? o2 : this.getString(e2.slice(1).join("."), o2);
    }
    return null;
  }, n2.translate = function(t4) {
    var n3, e2 = this.getString(t4, this._language);
    return (n3 = e2 || this.getString(t4, this._defaultLanguage)) ? n3.apply(void 0, [].slice.call(arguments, 1)) : t4;
  }, t3;
}();
function At() {
  var t3 = It();
  return function(n2) {
    var e2;
    return (e2 = t3.translator).translate.apply(e2, [n2].concat([].slice.call(arguments, 1)));
  };
}
var Ot = function(t3) {
  return function(n2) {
    return e({}, n2, { search: { keyword: t3 } });
  };
};
function Ht() {
  return It().store;
}
function jt(t3) {
  var n2 = Ht(), e2 = yt(t3(n2.getState())), r2 = e2[0], o2 = e2[1];
  return gt(function() {
    return n2.subscribe(function() {
      var e3 = t3(n2.getState());
      r2 !== e3 && o2(e3);
    });
  }, []), r2;
}
function Dt() {
  var t3, n2 = yt(void 0), e2 = n2[0], r2 = n2[1], o2 = It(), i2 = o2.search, u2 = At(), s2 = Ht().dispatch, a2 = jt(function(t4) {
    return t4.search;
  });
  gt(function() {
    e2 && e2.setProps({ keyword: null == a2 ? void 0 : a2.keyword });
  }, [a2, e2]), gt(function() {
    r2(i2.server ? new at({ keyword: i2.keyword, url: i2.server.url, body: i2.server.body }) : new nt({ keyword: i2.keyword, columns: o2.header && o2.header.columns, ignoreHiddenColumns: i2.ignoreHiddenColumns || void 0 === i2.ignoreHiddenColumns, selector: i2.selector })), i2.keyword && s2(Ot(i2.keyword));
  }, [i2]), gt(function() {
    if (e2) return o2.pipeline.register(e2), function() {
      return o2.pipeline.unregister(e2);
    };
  }, [o2, e2]);
  var l2, c2, f2, p2 = function(t4, n3) {
    return lt = 8, wt(function() {
      return t4;
    }, n3);
  }((l2 = function(t4) {
    t4.target instanceof HTMLInputElement && s2(Ot(t4.target.value));
  }, c2 = e2 instanceof at ? i2.debounceTimeout || 250 : 0, function() {
    var t4 = arguments;
    return new Promise(function(n3) {
      f2 && clearTimeout(f2), f2 = setTimeout(function() {
        return n3(l2.apply(void 0, [].slice.call(t4)));
      }, c2);
    });
  }), [i2, e2]);
  return w("div", { className: et(rt("search", null == (t3 = o2.className) ? void 0 : t3.search)) }, w("input", { type: "search", placeholder: u2("search.placeholder"), "aria-label": u2("search.placeholder"), onInput: p2, className: rt(et("input"), et("search", "input")), defaultValue: (null == a2 ? void 0 : a2.keyword) || "" }));
}
var Mt = /* @__PURE__ */ function(t3) {
  function e2() {
    return t3.apply(this, arguments) || this;
  }
  r(e2, t3);
  var o2 = e2.prototype;
  return o2.validateProps = function() {
    if (isNaN(Number(this.props.limit)) || isNaN(Number(this.props.page))) throw Error("Invalid parameters passed");
  }, o2._process = function(t4) {
    var n2 = this.props.page;
    return new J(t4.rows.slice(n2 * this.props.limit, (n2 + 1) * this.props.limit));
  }, n(e2, [{ key: "type", get: function() {
    return K.Limit;
  } }]), e2;
}(tt);
var Ft = /* @__PURE__ */ function(t3) {
  function o2() {
    return t3.apply(this, arguments) || this;
  }
  return r(o2, t3), o2.prototype._process = function(t4) {
    var n2 = {};
    return this.props.url && (n2.url = this.props.url(t4.url, this.props.page, this.props.limit)), this.props.body && (n2.body = this.props.body(t4.body, this.props.page, this.props.limit)), e({}, t4, n2);
  }, n(o2, [{ key: "type", get: function() {
    return K.ServerLimit;
  } }]), o2;
}(tt);
function Rt() {
  var t3 = It(), n2 = t3.pagination, e2 = n2.server, r2 = n2.summary, o2 = void 0 === r2 || r2, i2 = n2.nextButton, u2 = void 0 === i2 || i2, s2 = n2.prevButton, a2 = void 0 === s2 || s2, l2 = n2.buttonsCount, c2 = void 0 === l2 ? 3 : l2, f2 = n2.limit, p2 = void 0 === f2 ? 10 : f2, d2 = n2.page, h6 = void 0 === d2 ? 0 : d2, _2 = n2.resetPageOnUpdate, m2 = void 0 === _2 || _2, v2 = bt(null), y2 = yt(h6), g2 = y2[0], b2 = y2[1], x2 = yt(0), k = x2[0], N2 = x2[1], P2 = At();
  gt(function() {
    return e2 ? (v2.current = new Ft({ limit: p2, page: g2, url: e2.url, body: e2.body }), t3.pipeline.register(v2.current)) : (v2.current = new Mt({ limit: p2, page: g2 }), t3.pipeline.register(v2.current)), v2.current instanceof Ft ? t3.pipeline.on("afterProcess", function(t4) {
      return N2(t4.length);
    }) : v2.current instanceof Mt && v2.current.on("beforeProcess", function(t4) {
      return N2(t4.length);
    }), t3.pipeline.on("updated", C2), t3.pipeline.on("error", function() {
      N2(0), b2(0);
    }), function() {
      t3.pipeline.unregister(v2.current), t3.pipeline.off("updated", C2);
    };
  }, []);
  var C2 = function(t4) {
    m2 && t4 !== v2.current && (b2(0), 0 !== v2.current.props.page && v2.current.setProps({ page: 0 }));
  }, E2 = function() {
    return Math.ceil(k / p2);
  }, I2 = function(t4) {
    if (t4 >= E2() || t4 < 0 || t4 === g2) return null;
    b2(t4), v2.current.setProps({ page: t4 });
  };
  return w("div", { className: rt(et("pagination"), t3.className.pagination) }, w(S, null, o2 && k > 0 && w("div", { role: "status", "aria-live": "polite", className: rt(et("summary"), t3.className.paginationSummary), title: P2("pagination.navigate", g2 + 1, E2()) }, P2("pagination.showing"), " ", w("b", null, P2("" + (g2 * p2 + 1))), " ", P2("pagination.to"), " ", w("b", null, P2("" + Math.min((g2 + 1) * p2, k))), " ", P2("pagination.of"), " ", w("b", null, P2("" + k)), " ", P2("pagination.results"))), w("div", { className: et("pages") }, a2 && w("button", { tabIndex: 0, role: "button", disabled: 0 === g2, onClick: function() {
    return I2(g2 - 1);
  }, title: P2("pagination.previous"), "aria-label": P2("pagination.previous"), className: rt(t3.className.paginationButton, t3.className.paginationButtonPrev) }, P2("pagination.previous")), function() {
    if (c2 <= 0) return null;
    var n3 = Math.min(E2(), c2), e3 = Math.min(g2, Math.floor(n3 / 2));
    return g2 + Math.floor(n3 / 2) >= E2() && (e3 = n3 - (E2() - g2)), w(S, null, E2() > n3 && g2 - e3 > 0 && w(S, null, w("button", { tabIndex: 0, role: "button", onClick: function() {
      return I2(0);
    }, title: P2("pagination.firstPage"), "aria-label": P2("pagination.firstPage"), className: t3.className.paginationButton }, P2("1")), w("button", { tabIndex: -1, className: rt(et("spread"), t3.className.paginationButton) }, "...")), Array.from(Array(n3).keys()).map(function(t4) {
      return g2 + (t4 - e3);
    }).map(function(n4) {
      return w("button", { tabIndex: 0, role: "button", onClick: function() {
        return I2(n4);
      }, className: rt(g2 === n4 ? rt(et("currentPage"), t3.className.paginationButtonCurrent) : null, t3.className.paginationButton), title: P2("pagination.page", n4 + 1), "aria-label": P2("pagination.page", n4 + 1) }, P2("" + (n4 + 1)));
    }), E2() > n3 && E2() > g2 + e3 + 1 && w(S, null, w("button", { tabIndex: -1, className: rt(et("spread"), t3.className.paginationButton) }, "..."), w("button", { tabIndex: 0, role: "button", onClick: function() {
      return I2(E2() - 1);
    }, title: P2("pagination.page", E2()), "aria-label": P2("pagination.page", E2()), className: t3.className.paginationButton }, P2("" + E2()))));
  }(), u2 && w("button", { tabIndex: 0, role: "button", disabled: E2() === g2 + 1 || 0 === E2(), onClick: function() {
    return I2(g2 + 1);
  }, title: P2("pagination.next"), "aria-label": P2("pagination.next"), className: rt(t3.className.paginationButton, t3.className.paginationButtonNext) }, P2("pagination.next"))));
}
function Ut(t3, n2) {
  return "string" == typeof t3 ? t3.indexOf("%") > -1 ? n2 / 100 * parseInt(t3, 10) : parseInt(t3, 10) : t3;
}
function Wt(t3) {
  return t3 ? Math.floor(t3) + "px" : "";
}
function Bt(t3) {
  var n2 = t3.tableRef.cloneNode(true);
  return n2.style.position = "absolute", n2.style.width = "100%", n2.style.zIndex = "-2147483640", n2.style.visibility = "hidden", w("div", { ref: function(t4) {
    t4 && t4.appendChild(n2);
  } });
}
function qt(t3) {
  if (!t3) return "";
  var n2 = t3.split(" ");
  return 1 === n2.length && /([a-z][A-Z])+/g.test(t3) ? t3 : n2.map(function(t4, n3) {
    return 0 == n3 ? t4.toLowerCase() : t4.charAt(0).toUpperCase() + t4.slice(1).toLowerCase();
  }).join("");
}
var zt;
var Vt = new (/* @__PURE__ */ function() {
  function t3() {
  }
  var n2 = t3.prototype;
  return n2.format = function(t4, n3) {
    return "[Grid.js] [" + n3.toUpperCase() + "]: " + t4;
  }, n2.error = function(t4, n3) {
    void 0 === n3 && (n3 = false);
    var e2 = this.format(t4, "error");
    if (n3) throw Error(e2);
    console.error(e2);
  }, n2.warn = function(t4) {
    console.warn(this.format(t4, "warn"));
  }, n2.info = function(t4) {
    console.info(this.format(t4, "info"));
  }, t3;
}())();
!function(t3) {
  t3[t3.Header = 0] = "Header", t3[t3.Footer = 1] = "Footer", t3[t3.Cell = 2] = "Cell";
}(zt || (zt = {}));
var $t = /* @__PURE__ */ function() {
  function t3() {
    this.plugins = void 0, this.plugins = [];
  }
  var n2 = t3.prototype;
  return n2.get = function(t4) {
    return this.plugins.find(function(n3) {
      return n3.id === t4;
    });
  }, n2.add = function(t4) {
    return t4.id ? this.get(t4.id) ? (Vt.error("Duplicate plugin ID: " + t4.id), this) : (this.plugins.push(t4), this) : (Vt.error("Plugin ID cannot be empty"), this);
  }, n2.remove = function(t4) {
    var n3 = this.get(t4);
    return n3 && this.plugins.splice(this.plugins.indexOf(n3), 1), this;
  }, n2.list = function(t4) {
    var n3;
    return n3 = null != t4 || null != t4 ? this.plugins.filter(function(n4) {
      return n4.position === t4;
    }) : this.plugins, n3.sort(function(t5, n4) {
      return t5.order && n4.order ? t5.order - n4.order : 1;
    });
  }, t3;
}();
function Gt(t3) {
  var n2 = this, r2 = It();
  if (t3.pluginId) {
    var o2 = r2.plugin.get(t3.pluginId);
    return o2 ? w(S, {}, w(o2.component, e({ plugin: o2 }, t3.props))) : null;
  }
  return void 0 !== t3.position ? w(S, {}, r2.plugin.list(t3.position).map(function(t4) {
    return w(t4.component, e({ plugin: t4 }, n2.props.props));
  })) : null;
}
var Kt = /* @__PURE__ */ function(t3) {
  function o2() {
    var n2;
    return (n2 = t3.call(this) || this)._columns = void 0, n2._columns = [], n2;
  }
  r(o2, t3);
  var i2 = o2.prototype;
  return i2.adjustWidth = function(t4, n2, r2) {
    var i3 = t4.container, u2 = t4.autoWidth;
    if (!i3) return this;
    var a2 = i3.clientWidth, l2 = {};
    n2.current && u2 && (q(w(Bt, { tableRef: n2.current }), r2.current), l2 = function(t5) {
      var n3 = t5.querySelector("table");
      if (!n3) return {};
      var r3 = n3.className, o3 = n3.style.cssText;
      n3.className = r3 + " " + et("shadowTable"), n3.style.tableLayout = "auto", n3.style.width = "auto", n3.style.padding = "0", n3.style.margin = "0", n3.style.border = "none", n3.style.outline = "none";
      var i4 = Array.from(n3.parentNode.querySelectorAll("thead th")).reduce(function(t6, n4) {
        var r4;
        return n4.style.width = n4.clientWidth + "px", e(((r4 = {})[n4.getAttribute("data-column-id")] = { minWidth: n4.clientWidth }, r4), t6);
      }, {});
      return n3.className = r3, n3.style.cssText = o3, n3.style.tableLayout = "auto", Array.from(n3.parentNode.querySelectorAll("thead th")).reduce(function(t6, n4) {
        return t6[n4.getAttribute("data-column-id")].width = n4.clientWidth, t6;
      }, i4);
    }(r2.current));
    for (var c2, f2 = s(o2.tabularFormat(this.columns).reduce(function(t5, n3) {
      return t5.concat(n3);
    }, [])); !(c2 = f2()).done; ) {
      var p2 = c2.value;
      p2.columns && p2.columns.length > 0 || (!p2.width && u2 ? p2.id in l2 && (p2.width = Wt(l2[p2.id].width), p2.minWidth = Wt(l2[p2.id].minWidth)) : p2.width = Wt(Ut(p2.width, a2)));
    }
    return n2.current && u2 && q(null, r2.current), this;
  }, i2.setSort = function(t4, n2) {
    for (var r2, o3 = s(n2 || this.columns || []); !(r2 = o3()).done; ) {
      var i3 = r2.value;
      i3.columns && i3.columns.length > 0 ? i3.sort = void 0 : void 0 === i3.sort && t4 ? i3.sort = {} : i3.sort ? "object" == typeof i3.sort && (i3.sort = e({}, i3.sort)) : i3.sort = void 0, i3.columns && this.setSort(t4, i3.columns);
    }
  }, i2.setResizable = function(t4, n2) {
    for (var e2, r2 = s(n2 || this.columns || []); !(e2 = r2()).done; ) {
      var o3 = e2.value;
      void 0 === o3.resizable && (o3.resizable = t4), o3.columns && this.setResizable(t4, o3.columns);
    }
  }, i2.setID = function(t4) {
    for (var n2, e2 = s(t4 || this.columns || []); !(n2 = e2()).done; ) {
      var r2 = n2.value;
      r2.id || "string" != typeof r2.name || (r2.id = qt(r2.name)), r2.id || Vt.error('Could not find a valid ID for one of the columns. Make sure a valid "id" is set for all columns.'), r2.columns && this.setID(r2.columns);
    }
  }, i2.populatePlugins = function(t4, n2) {
    for (var r2, o3 = s(n2); !(r2 = o3()).done; ) {
      var i3 = r2.value;
      void 0 !== i3.plugin && t4.add(e({ id: i3.id }, i3.plugin, { position: zt.Cell }));
    }
  }, o2.fromColumns = function(t4) {
    for (var n2, e2 = new o2(), r2 = s(t4); !(n2 = r2()).done; ) {
      var i3 = n2.value;
      if ("string" == typeof i3 || p(i3)) e2.columns.push({ name: i3 });
      else if ("object" == typeof i3) {
        var u2 = i3;
        u2.columns && (u2.columns = o2.fromColumns(u2.columns).columns), "object" == typeof u2.plugin && void 0 === u2.data && (u2.data = null), e2.columns.push(i3);
      }
    }
    return e2;
  }, o2.createFromConfig = function(t4) {
    var n2 = new o2();
    return t4.from ? n2.columns = o2.fromHTMLTable(t4.from).columns : t4.columns ? n2.columns = o2.fromColumns(t4.columns).columns : !t4.data || "object" != typeof t4.data[0] || t4.data[0] instanceof Array || (n2.columns = Object.keys(t4.data[0]).map(function(t5) {
      return { name: t5 };
    })), n2.columns.length ? (n2.setID(), n2.setSort(t4.sort), n2.setResizable(t4.resizable), n2.populatePlugins(t4.plugin, n2.columns), n2) : null;
  }, o2.fromHTMLTable = function(t4) {
    for (var n2, e2 = new o2(), r2 = s(t4.querySelector("thead").querySelectorAll("th")); !(n2 = r2()).done; ) {
      var i3 = n2.value;
      e2.columns.push({ name: i3.innerHTML, width: i3.width });
    }
    return e2;
  }, o2.tabularFormat = function(t4) {
    var n2 = [], e2 = t4 || [], r2 = [];
    if (e2 && e2.length) {
      n2.push(e2);
      for (var o3, i3 = s(e2); !(o3 = i3()).done; ) {
        var u2 = o3.value;
        u2.columns && u2.columns.length && (r2 = r2.concat(u2.columns));
      }
      r2.length && (n2 = n2.concat(this.tabularFormat(r2)));
    }
    return n2;
  }, o2.leafColumns = function(t4) {
    var n2 = [], e2 = t4 || [];
    if (e2 && e2.length) for (var r2, o3 = s(e2); !(r2 = o3()).done; ) {
      var i3 = r2.value;
      i3.columns && 0 !== i3.columns.length || n2.push(i3), i3.columns && (n2 = n2.concat(this.leafColumns(i3.columns)));
    }
    return n2;
  }, o2.maximumDepth = function(t4) {
    return this.tabularFormat([t4]).length - 1;
  }, n(o2, [{ key: "columns", get: function() {
    return this._columns;
  }, set: function(t4) {
    this._columns = t4;
  } }, { key: "visibleColumns", get: function() {
    return this._columns.filter(function(t4) {
      return !t4.hidden;
    });
  } }]), o2;
}(V);
var Xt = function() {
};
var Zt = /* @__PURE__ */ function(t3) {
  function n2(n3) {
    var e3;
    return (e3 = t3.call(this) || this).data = void 0, e3.set(n3), e3;
  }
  r(n2, t3);
  var e2 = n2.prototype;
  return e2.get = function() {
    try {
      return Promise.resolve(this.data()).then(function(t4) {
        return { data: t4, total: t4.length };
      });
    } catch (t4) {
      return Promise.reject(t4);
    }
  }, e2.set = function(t4) {
    return t4 instanceof Array ? this.data = function() {
      return t4;
    } : t4 instanceof Function && (this.data = t4), this;
  }, n2;
}(Xt);
var Jt = /* @__PURE__ */ function(t3) {
  function n2(n3) {
    var e2;
    return (e2 = t3.call(this) || this).options = void 0, e2.options = n3, e2;
  }
  r(n2, t3);
  var o2 = n2.prototype;
  return o2.handler = function(t4) {
    return "function" == typeof this.options.handle ? this.options.handle(t4) : t4.ok ? t4.json() : (Vt.error("Could not fetch data: " + t4.status + " - " + t4.statusText, true), null);
  }, o2.get = function(t4) {
    var n3 = e({}, this.options, t4);
    return "function" == typeof n3.data ? n3.data(n3) : fetch(n3.url, n3).then(this.handler.bind(this)).then(function(t5) {
      return { data: n3.then(t5), total: "function" == typeof n3.total ? n3.total(t5) : void 0 };
    });
  }, n2;
}(Xt);
var Qt = /* @__PURE__ */ function() {
  function t3() {
  }
  return t3.createFromConfig = function(t4) {
    var n2 = null;
    return t4.data && (n2 = new Zt(t4.data)), t4.from && (n2 = new Zt(this.tableElementToArray(t4.from)), t4.from.style.display = "none"), t4.server && (n2 = new Jt(t4.server)), n2 || Vt.error("Could not determine the storage type", true), n2;
  }, t3.tableElementToArray = function(t4) {
    for (var n2, e2, r2 = [], o2 = s(t4.querySelector("tbody").querySelectorAll("tr")); !(n2 = o2()).done; ) {
      for (var i2, u2 = [], a2 = s(n2.value.querySelectorAll("td")); !(i2 = a2()).done; ) {
        var l2 = i2.value;
        1 === l2.childNodes.length && l2.childNodes[0].nodeType === Node.TEXT_NODE ? u2.push((e2 = l2.innerHTML, new DOMParser().parseFromString(e2, "text/html").documentElement.textContent)) : u2.push(G(l2.innerHTML));
      }
      r2.push(u2);
    }
    return r2;
  }, t3;
}();
var Yt = "undefined" != typeof Symbol ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
function tn(t3, n2, e2) {
  if (!t3.s) {
    if (e2 instanceof nn) {
      if (!e2.s) return void (e2.o = tn.bind(null, t3, n2));
      1 & n2 && (n2 = e2.s), e2 = e2.v;
    }
    if (e2 && e2.then) return void e2.then(tn.bind(null, t3, n2), tn.bind(null, t3, 2));
    t3.s = n2, t3.v = e2;
    var r2 = t3.o;
    r2 && r2(t3);
  }
}
var nn = /* @__PURE__ */ function() {
  function t3() {
  }
  return t3.prototype.then = function(n2, e2) {
    var r2 = new t3(), o2 = this.s;
    if (o2) {
      var i2 = 1 & o2 ? n2 : e2;
      if (i2) {
        try {
          tn(r2, 1, i2(this.v));
        } catch (t4) {
          tn(r2, 2, t4);
        }
        return r2;
      }
      return this;
    }
    return this.o = function(t4) {
      try {
        var o3 = t4.v;
        1 & t4.s ? tn(r2, 1, n2 ? n2(o3) : o3) : e2 ? tn(r2, 1, e2(o3)) : tn(r2, 2, o3);
      } catch (t5) {
        tn(r2, 2, t5);
      }
    }, r2;
  }, t3;
}();
function en(t3) {
  return t3 instanceof nn && 1 & t3.s;
}
var rn = /* @__PURE__ */ function(t3) {
  function e2(n2) {
    var e3;
    return (e3 = t3.call(this) || this)._steps = /* @__PURE__ */ new Map(), e3.cache = /* @__PURE__ */ new Map(), e3.lastProcessorIndexUpdated = -1, n2 && n2.forEach(function(t4) {
      return e3.register(t4);
    }), e3;
  }
  r(e2, t3);
  var o2 = e2.prototype;
  return o2.clearCache = function() {
    this.cache = /* @__PURE__ */ new Map(), this.lastProcessorIndexUpdated = -1;
  }, o2.register = function(t4, n2) {
    if (void 0 === n2 && (n2 = null), !t4) throw Error("Processor is not defined");
    if (null === t4.type) throw Error("Processor type is not defined");
    if (this.findProcessorIndexByID(t4.id) > -1) throw Error("Processor ID " + t4.id + " is already defined");
    return t4.on("propsUpdated", this.processorPropsUpdated.bind(this)), this.addProcessorByPriority(t4, n2), this.afterRegistered(t4), t4;
  }, o2.tryRegister = function(t4, n2) {
    void 0 === n2 && (n2 = null);
    try {
      return this.register(t4, n2);
    } catch (t5) {
    }
  }, o2.unregister = function(t4) {
    if (t4 && -1 !== this.findProcessorIndexByID(t4.id)) {
      var n2 = this._steps.get(t4.type);
      n2 && n2.length && (this._steps.set(t4.type, n2.filter(function(n3) {
        return n3 != t4;
      })), this.emit("updated", t4));
    }
  }, o2.addProcessorByPriority = function(t4, n2) {
    var e3 = this._steps.get(t4.type);
    if (!e3) {
      var r2 = [];
      this._steps.set(t4.type, r2), e3 = r2;
    }
    if (null === n2 || n2 < 0) e3.push(t4);
    else if (e3[n2]) {
      var o3 = e3.slice(0, n2 - 1), i2 = e3.slice(n2 + 1);
      this._steps.set(t4.type, o3.concat(t4).concat(i2));
    } else e3[n2] = t4;
  }, o2.getStepsByType = function(t4) {
    return this.steps.filter(function(n2) {
      return n2.type === t4;
    });
  }, o2.getSortedProcessorTypes = function() {
    return Object.keys(K).filter(function(t4) {
      return !isNaN(Number(t4));
    }).map(function(t4) {
      return Number(t4);
    });
  }, o2.process = function(t4) {
    try {
      var n2 = function(t5) {
        return e3.lastProcessorIndexUpdated = o3.length, e3.emit("afterProcess", i2), i2;
      }, e3 = this, r2 = e3.lastProcessorIndexUpdated, o3 = e3.steps, i2 = t4, u2 = function(t5, n3) {
        try {
          var u3 = function(t6, n4, e4) {
            if ("function" == typeof t6[Yt]) {
              var r3, o4, i3, u4 = t6[Yt]();
              if (function t7(e5) {
                try {
                  for (; !(r3 = u4.next()).done; ) if ((e5 = n4(r3.value)) && e5.then) {
                    if (!en(e5)) return void e5.then(t7, i3 || (i3 = tn.bind(null, o4 = new nn(), 2)));
                    e5 = e5.v;
                  }
                  o4 ? tn(o4, 1, e5) : o4 = e5;
                } catch (t8) {
                  tn(o4 || (o4 = new nn()), 2, t8);
                }
              }(), u4.return) {
                var s2 = function(t7) {
                  try {
                    r3.done || u4.return();
                  } catch (t8) {
                  }
                  return t7;
                };
                if (o4 && o4.then) return o4.then(s2, function(t7) {
                  throw s2(t7);
                });
                s2();
              }
              return o4;
            }
            if (!("length" in t6)) throw new TypeError("Object is not iterable");
            for (var a2 = [], l2 = 0; l2 < t6.length; l2++) a2.push(t6[l2]);
            return function(t7, n5, e5) {
              var r4, o5, i4 = -1;
              return function e6(u5) {
                try {
                  for (; ++i4 < t7.length; ) if ((u5 = n5(i4)) && u5.then) {
                    if (!en(u5)) return void u5.then(e6, o5 || (o5 = tn.bind(null, r4 = new nn(), 2)));
                    u5 = u5.v;
                  }
                  r4 ? tn(r4, 1, u5) : r4 = u5;
                } catch (t8) {
                  tn(r4 || (r4 = new nn()), 2, t8);
                }
              }(), r4;
            }(a2, function(t7) {
              return n4(a2[t7]);
            });
          }(o3, function(t6) {
            var n4 = e3.findProcessorIndexByID(t6.id), o4 = function() {
              if (n4 >= r2) return Promise.resolve(t6.process(i2)).then(function(n5) {
                e3.cache.set(t6.id, i2 = n5);
              });
              i2 = e3.cache.get(t6.id);
            }();
            if (o4 && o4.then) return o4.then(function() {
            });
          });
        } catch (t6) {
          return n3(t6);
        }
        return u3 && u3.then ? u3.then(void 0, n3) : u3;
      }(0, function(t5) {
        throw Vt.error(t5), e3.emit("error", i2), t5;
      });
      return Promise.resolve(u2 && u2.then ? u2.then(n2) : n2());
    } catch (t5) {
      return Promise.reject(t5);
    }
  }, o2.findProcessorIndexByID = function(t4) {
    return this.steps.findIndex(function(n2) {
      return n2.id == t4;
    });
  }, o2.setLastProcessorIndex = function(t4) {
    var n2 = this.findProcessorIndexByID(t4.id);
    this.lastProcessorIndexUpdated > n2 && (this.lastProcessorIndexUpdated = n2);
  }, o2.processorPropsUpdated = function(t4) {
    this.setLastProcessorIndex(t4), this.emit("propsUpdated"), this.emit("updated", t4);
  }, o2.afterRegistered = function(t4) {
    this.setLastProcessorIndex(t4), this.emit("afterRegister"), this.emit("updated", t4);
  }, n(e2, [{ key: "steps", get: function() {
    for (var t4, n2 = [], e3 = s(this.getSortedProcessorTypes()); !(t4 = e3()).done; ) {
      var r2 = this._steps.get(t4.value);
      r2 && r2.length && (n2 = n2.concat(r2));
    }
    return n2.filter(function(t5) {
      return t5;
    });
  } }]), e2;
}(Q);
var on = /* @__PURE__ */ function(t3) {
  function e2() {
    return t3.apply(this, arguments) || this;
  }
  return r(e2, t3), e2.prototype._process = function(t4) {
    try {
      return Promise.resolve(this.props.storage.get(t4));
    } catch (t5) {
      return Promise.reject(t5);
    }
  }, n(e2, [{ key: "type", get: function() {
    return K.Extractor;
  } }]), e2;
}(tt);
var un = /* @__PURE__ */ function(t3) {
  function e2() {
    return t3.apply(this, arguments) || this;
  }
  return r(e2, t3), e2.prototype._process = function(t4) {
    var n2 = J.fromArray(t4.data);
    return n2.length = t4.total, n2;
  }, n(e2, [{ key: "type", get: function() {
    return K.Transformer;
  } }]), e2;
}(tt);
var sn = /* @__PURE__ */ function(t3) {
  function o2() {
    return t3.apply(this, arguments) || this;
  }
  return r(o2, t3), o2.prototype._process = function() {
    return Object.entries(this.props.serverStorageOptions).filter(function(t4) {
      return "function" != typeof t4[1];
    }).reduce(function(t4, n2) {
      var r2;
      return e({}, t4, ((r2 = {})[n2[0]] = n2[1], r2));
    }, {});
  }, n(o2, [{ key: "type", get: function() {
    return K.Initiator;
  } }]), o2;
}(tt);
var an = /* @__PURE__ */ function(t3) {
  function e2() {
    return t3.apply(this, arguments) || this;
  }
  r(e2, t3);
  var o2 = e2.prototype;
  return o2.castData = function(t4) {
    if (!t4 || !t4.length) return [];
    if (!this.props.header || !this.props.header.columns) return t4;
    var n2 = Kt.leafColumns(this.props.header.columns);
    return t4[0] instanceof Array ? t4.map(function(t5) {
      var e3 = 0;
      return n2.map(function(n3, r2) {
        return void 0 !== n3.data ? (e3++, "function" == typeof n3.data ? n3.data(t5) : n3.data) : t5[r2 - e3];
      });
    }) : "object" != typeof t4[0] || t4[0] instanceof Array ? [] : t4.map(function(t5) {
      return n2.map(function(n3, e3) {
        return void 0 !== n3.data ? "function" == typeof n3.data ? n3.data(t5) : n3.data : n3.id ? t5[n3.id] : (Vt.error("Could not find the correct cell for column at position " + e3 + ".\n                          Make sure either 'id' or 'selector' is defined for all columns."), null);
      });
    });
  }, o2._process = function(t4) {
    return { data: this.castData(t4.data), total: t4.total };
  }, n(e2, [{ key: "type", get: function() {
    return K.Transformer;
  } }]), e2;
}(tt);
var ln = /* @__PURE__ */ function() {
  function t3() {
  }
  return t3.createFromConfig = function(t4) {
    var n2 = new rn();
    return t4.storage instanceof Jt && n2.register(new sn({ serverStorageOptions: t4.server })), n2.register(new on({ storage: t4.storage })), n2.register(new an({ header: t4.header })), n2.register(new un()), n2;
  }, t3;
}();
var cn = function(t3) {
  var n2 = this;
  this.state = void 0, this.listeners = [], this.isDispatching = false, this.getState = function() {
    return n2.state;
  }, this.getListeners = function() {
    return n2.listeners;
  }, this.dispatch = function(t4) {
    if ("function" != typeof t4) throw new Error("Reducer is not a function");
    if (n2.isDispatching) throw new Error("Reducers may not dispatch actions");
    n2.isDispatching = true;
    var e2 = n2.state;
    try {
      n2.state = t4(n2.state);
    } finally {
      n2.isDispatching = false;
    }
    for (var r2, o2 = s(n2.listeners); !(r2 = o2()).done; ) (0, r2.value)(n2.state, e2);
    return n2.state;
  }, this.subscribe = function(t4) {
    if ("function" != typeof t4) throw new Error("Listener is not a function");
    return n2.listeners = [].concat(n2.listeners, [t4]), function() {
      return n2.listeners = n2.listeners.filter(function(n3) {
        return n3 !== t4;
      });
    };
  }, this.state = t3;
};
var fn = function(t3, n2) {
  var e2 = { __c: n2 = "__cC" + _++, __: null, Consumer: function(t4, n3) {
    return t4.children(n3);
  }, Provider: function(t4) {
    var e3, r2;
    return this.getChildContext || (e3 = [], (r2 = {})[n2] = this, this.getChildContext = function() {
      return r2;
    }, this.shouldComponentUpdate = function(t5) {
      this.props.value !== t5.value && e3.some(E);
    }, this.sub = function(t5) {
      e3.push(t5);
      var n3 = t5.componentWillUnmount;
      t5.componentWillUnmount = function() {
        e3.splice(e3.indexOf(t5), 1), n3 && n3.call(t5);
      };
    }), t4.children;
  } };
  return e2.Provider.__ = e2.Consumer.contextType = e2;
}();
var pn = /* @__PURE__ */ function() {
  function t3() {
    Object.assign(this, t3.defaultConfig());
  }
  var n2 = t3.prototype;
  return n2.assign = function(t4) {
    return Object.assign(this, t4);
  }, n2.update = function(n3) {
    return n3 ? (this.assign(t3.fromPartialConfig(e({}, this, n3))), this) : this;
  }, t3.defaultConfig = function() {
    return { store: new cn({ status: a.Init, header: void 0, data: null }), plugin: new $t(), tableRef: { current: null }, width: "100%", height: "auto", processingThrottleMs: 100, autoWidth: true, style: {}, className: {} };
  }, t3.fromPartialConfig = function(n3) {
    var e2 = new t3().assign(n3);
    return "boolean" == typeof n3.sort && n3.sort && e2.assign({ sort: { multiColumn: true } }), e2.assign({ header: Kt.createFromConfig(e2) }), e2.assign({ storage: Qt.createFromConfig(e2) }), e2.assign({ pipeline: ln.createFromConfig(e2) }), e2.assign({ translator: new Lt(e2.language) }), e2.plugin = new $t(), e2.search && e2.plugin.add({ id: "search", position: zt.Header, component: Dt }), e2.pagination && e2.plugin.add({ id: "pagination", position: zt.Footer, component: Rt }), e2.plugins && e2.plugins.forEach(function(t4) {
      return e2.plugin.add(t4);
    }), e2;
  }, t3;
}();
function dn(t3) {
  var n2, r2 = It();
  return w("td", e({ role: t3.role, colSpan: t3.colSpan, "data-column-id": t3.column && t3.column.id, className: rt(et("td"), t3.className, r2.className.td), style: e({}, t3.style, r2.style.td), onClick: function(n3) {
    t3.messageCell || r2.eventEmitter.emit("cellClick", n3, t3.cell, t3.column, t3.row);
  } }, (n2 = t3.column) ? "function" == typeof n2.attributes ? n2.attributes(t3.cell.data, t3.row, t3.column) : n2.attributes : {}), t3.column && "function" == typeof t3.column.formatter ? t3.column.formatter(t3.cell.data, t3.row, t3.column) : t3.column && t3.column.plugin ? w(Gt, { pluginId: t3.column.id, props: { column: t3.column, cell: t3.cell, row: t3.row } }) : t3.cell.data);
}
function hn(t3) {
  var n2 = It(), e2 = jt(function(t4) {
    return t4.header;
  });
  return w("tr", { className: rt(et("tr"), n2.className.tr), onClick: function(e3) {
    t3.messageRow || n2.eventEmitter.emit("rowClick", e3, t3.row);
  } }, t3.children ? t3.children : t3.row.cells.map(function(n3, r2) {
    var o2 = function(t4) {
      if (e2) {
        var n4 = Kt.leafColumns(e2.columns);
        if (n4) return n4[t4];
      }
      return null;
    }(r2);
    return o2 && o2.hidden ? null : w(dn, { key: n3.id, cell: n3, row: t3.row, column: o2 });
  }));
}
function _n(t3) {
  return w(hn, { messageRow: true }, w(dn, { role: "alert", colSpan: t3.colSpan, messageCell: true, cell: new X(t3.message), className: rt(et("message"), t3.className ? t3.className : null) }));
}
function mn() {
  var t3 = It(), n2 = jt(function(t4) {
    return t4.data;
  }), e2 = jt(function(t4) {
    return t4.status;
  }), r2 = jt(function(t4) {
    return t4.header;
  }), o2 = At(), i2 = function() {
    return r2 ? r2.visibleColumns.length : 0;
  };
  return w("tbody", { className: rt(et("tbody"), t3.className.tbody) }, n2 && n2.rows.map(function(t4) {
    return w(hn, { key: t4.id, row: t4 });
  }), e2 === a.Loading && (!n2 || 0 === n2.length) && w(_n, { message: o2("loading"), colSpan: i2(), className: rt(et("loading"), t3.className.loading) }), e2 === a.Rendered && n2 && 0 === n2.length && w(_n, { message: o2("noRecordsFound"), colSpan: i2(), className: rt(et("notfound"), t3.className.notfound) }), e2 === a.Error && w(_n, { message: o2("error"), colSpan: i2(), className: rt(et("error"), t3.className.error) }));
}
var vn = /* @__PURE__ */ function(t3) {
  function e2() {
    return t3.apply(this, arguments) || this;
  }
  r(e2, t3);
  var o2 = e2.prototype;
  return o2.validateProps = function() {
    for (var t4, n2 = s(this.props.columns); !(t4 = n2()).done; ) {
      var e3 = t4.value;
      void 0 === e3.direction && (e3.direction = 1), 1 !== e3.direction && -1 !== e3.direction && Vt.error("Invalid sort direction " + e3.direction);
    }
  }, o2.compare = function(t4, n2) {
    return t4 > n2 ? 1 : t4 < n2 ? -1 : 0;
  }, o2.compareWrapper = function(t4, n2) {
    for (var e3, r2 = 0, o3 = s(this.props.columns); !(e3 = o3()).done; ) {
      var i2 = e3.value;
      if (0 !== r2) break;
      var u2 = t4.cells[i2.index].data, a2 = n2.cells[i2.index].data;
      r2 |= "function" == typeof i2.compare ? i2.compare(u2, a2) * i2.direction : this.compare(u2, a2) * i2.direction;
    }
    return r2;
  }, o2._process = function(t4) {
    var n2 = [].concat(t4.rows);
    n2.sort(this.compareWrapper.bind(this));
    var e3 = new J(n2);
    return e3.length = t4.length, e3;
  }, n(e2, [{ key: "type", get: function() {
    return K.Sort;
  } }]), e2;
}(tt);
var yn = function(t3, n2, r2, o2) {
  return function(i2) {
    var u2, s2 = null != (u2 = i2.sort) && u2.columns ? i2.sort.columns.map(function(t4) {
      return e({}, t4);
    }) : [], a2 = s2.length, l2 = s2.find(function(n3) {
      return n3.index === t3;
    }), c2 = false, f2 = false, p2 = false, d2 = false;
    if (void 0 !== l2 ? r2 ? -1 === l2.direction ? p2 = true : d2 = true : 1 === a2 ? d2 = true : a2 > 1 && (f2 = true, c2 = true) : 0 === a2 ? c2 = true : a2 > 0 && !r2 ? (c2 = true, f2 = true) : a2 > 0 && r2 && (c2 = true), f2 && (s2 = []), c2) s2.push({ index: t3, direction: n2, compare: o2 });
    else if (d2) {
      var h6 = s2.indexOf(l2);
      s2[h6].direction = n2;
    } else if (p2) {
      var _2 = s2.indexOf(l2);
      s2.splice(_2, 1);
    }
    return e({}, i2, { sort: { columns: s2 } });
  };
};
var gn = function(t3, n2, r2) {
  return function(o2) {
    var i2 = (o2.sort ? [].concat(o2.sort.columns) : []).find(function(n3) {
      return n3.index === t3;
    });
    return e({}, o2, i2 ? yn(t3, 1 === i2.direction ? -1 : 1, n2, r2)(o2) : yn(t3, 1, n2, r2)(o2));
  };
};
var bn = /* @__PURE__ */ function(t3) {
  function o2() {
    return t3.apply(this, arguments) || this;
  }
  return r(o2, t3), o2.prototype._process = function(t4) {
    var n2 = {};
    return this.props.url && (n2.url = this.props.url(t4.url, this.props.columns)), this.props.body && (n2.body = this.props.body(t4.body, this.props.columns)), e({}, t4, n2);
  }, n(o2, [{ key: "type", get: function() {
    return K.ServerSort;
  } }]), o2;
}(tt);
function wn(t3) {
  var n2 = It(), r2 = Ht().dispatch, o2 = At(), i2 = yt(0), u2 = i2[0], s2 = i2[1], a2 = n2.sort, l2 = jt(function(t4) {
    return t4.sort;
  }), c2 = "object" == typeof (null == a2 ? void 0 : a2.server) ? K.ServerSort : K.Sort, f2 = function() {
    var t4 = n2.pipeline.getStepsByType(c2);
    if (t4.length) return t4[0];
  };
  return gt(function() {
    var t4 = f2() || (c2 === K.ServerSort ? new bn(e({ columns: l2 ? l2.columns : [] }, a2.server)) : new vn({ columns: l2 ? l2.columns : [] }));
    return n2.pipeline.tryRegister(t4), function() {
      return n2.pipeline.unregister(t4);
    };
  }, [n2]), gt(function() {
    if (l2) {
      var n3, e2 = l2.columns.find(function(n4) {
        return n4.index === t3.index;
      });
      e2 ? (0 === u2 && (e2.direction = null != (n3 = t3.direction) ? n3 : 1), s2(e2.direction)) : s2(0);
    }
  }, [l2]), gt(function() {
    var t4 = f2();
    t4 && l2 && t4.setProps({ columns: l2.columns });
  }, [l2]), w("button", { tabIndex: -1, "aria-label": o2("sort.sort" + (1 === u2 ? "Desc" : "Asc")), title: o2("sort.sort" + (1 === u2 ? "Desc" : "Asc")), className: rt(et("sort"), et("sort", /* @__PURE__ */ function(t4) {
    return 1 === t4 ? "asc" : -1 === t4 ? "desc" : "neutral";
  }(u2)), n2.className.sort), onClick: function(n3) {
    n3.preventDefault(), n3.stopPropagation(), r2(gn(t3.index, true === n3.shiftKey && a2.multiColumn, t3.compare));
  } });
}
var xn = function(t3, n2) {
  var e2;
  void 0 === n2 && (n2 = 100);
  var r2 = Date.now(), o2 = function() {
    r2 = Date.now(), t3.apply(void 0, [].slice.call(arguments));
  };
  return function() {
    var t4 = [].slice.call(arguments), i2 = Date.now(), u2 = i2 - r2;
    u2 >= n2 ? o2.apply(void 0, t4) : (e2 && clearTimeout(e2), e2 = setTimeout(function() {
      o2.apply(void 0, t4), e2 = null;
    }, n2 - u2));
  };
};
function kn(t3) {
  var n2, e2 = function(t4) {
    return t4 instanceof MouseEvent ? Math.floor(t4.pageX) : Math.floor(t4.changedTouches[0].pageX);
  }, r2 = function(r3) {
    r3.stopPropagation();
    var u2 = parseInt(t3.thRef.current.style.width, 10) - e2(r3);
    n2 = xn(function(t4) {
      return o2(t4, u2);
    }, 10), document.addEventListener("mouseup", i2), document.addEventListener("touchend", i2), document.addEventListener("mousemove", n2), document.addEventListener("touchmove", n2);
  }, o2 = function(n3, r3) {
    n3.stopPropagation();
    var o3 = t3.thRef.current;
    r3 + e2(n3) >= parseInt(o3.style.minWidth, 10) && (o3.style.width = r3 + e2(n3) + "px");
  }, i2 = function t4(e3) {
    e3.stopPropagation(), document.removeEventListener("mouseup", t4), document.removeEventListener("mousemove", n2), document.removeEventListener("touchmove", n2), document.removeEventListener("touchend", t4);
  };
  return w("div", { className: rt(et("th"), et("resizable")), onMouseDown: r2, onTouchStart: r2, onClick: function(t4) {
    return t4.stopPropagation();
  } });
}
function Sn(t3) {
  var n2 = It(), r2 = bt(null), o2 = yt({}), i2 = o2[0], u2 = o2[1], s2 = Ht().dispatch;
  gt(function() {
    if (n2.fixedHeader && r2.current) {
      var t4 = r2.current.offsetTop;
      "number" == typeof t4 && u2({ top: t4 });
    }
  }, [r2]);
  var a2, l2 = function() {
    return null != t3.column.sort;
  }, c2 = function(e2) {
    e2.stopPropagation(), l2() && s2(gn(t3.index, true === e2.shiftKey && n2.sort.multiColumn, t3.column.sort.compare));
  };
  return w("th", e({ ref: r2, "data-column-id": t3.column && t3.column.id, className: rt(et("th"), l2() ? et("th", "sort") : null, n2.fixedHeader ? et("th", "fixed") : null, n2.className.th), onClick: c2, style: e({}, n2.style.th, { minWidth: t3.column.minWidth, width: t3.column.width }, i2, t3.style), onKeyDown: function(t4) {
    l2() && 13 === t4.which && c2(t4);
  }, rowSpan: t3.rowSpan > 1 ? t3.rowSpan : void 0, colSpan: t3.colSpan > 1 ? t3.colSpan : void 0 }, (a2 = t3.column) ? "function" == typeof a2.attributes ? a2.attributes(null, null, t3.column) : a2.attributes : {}, l2() ? { tabIndex: 0 } : {}), w("div", { className: et("th", "content") }, void 0 !== t3.column.name ? t3.column.name : void 0 !== t3.column.plugin ? w(Gt, { pluginId: t3.column.plugin.id, props: { column: t3.column } }) : null), l2() && w(wn, e({ index: t3.index }, t3.column.sort)), t3.column.resizable && t3.index < n2.header.visibleColumns.length - 1 && w(kn, { column: t3.column, thRef: r2 }));
}
function Nn() {
  var t3, n2 = It(), e2 = jt(function(t4) {
    return t4.header;
  });
  return e2 ? w("thead", { key: e2.id, className: rt(et("thead"), n2.className.thead) }, (t3 = Kt.tabularFormat(e2.columns)).map(function(n3, r2) {
    return function(t4, n4, r3) {
      var o2 = Kt.leafColumns(e2.columns);
      return w(hn, null, t4.map(function(t5) {
        return t5.hidden ? null : function(t6, n5, e3, r4) {
          var o3 = function(t7, n6, e4) {
            var r5 = Kt.maximumDepth(t7), o4 = e4 - n6;
            return { rowSpan: Math.floor(o4 - r5 - r5 / o4), colSpan: t7.columns && t7.columns.length || 1 };
          }(t6, n5, r4);
          return w(Sn, { column: t6, index: e3, colSpan: o3.colSpan, rowSpan: o3.rowSpan });
        }(t5, n4, o2.indexOf(t5), r3);
      }));
    }(n3, r2, t3.length);
  })) : null;
}
var Pn = function(t3) {
  return function(n2) {
    return e({}, n2, { header: t3 });
  };
};
function Cn() {
  var t3 = It(), n2 = bt(null), r2 = Ht().dispatch;
  return gt(function() {
    n2 && r2(/* @__PURE__ */ function(t4) {
      return function(n3) {
        return e({}, n3, { tableRef: t4 });
      };
    }(n2));
  }, [n2]), w("table", { ref: n2, role: "grid", className: rt(et("table"), t3.className.table), style: e({}, t3.style.table, { height: t3.height }) }, w(Nn, null), w(mn, null));
}
function En() {
  var t3 = yt(true), n2 = t3[0], r2 = t3[1], o2 = bt(null), i2 = It();
  return gt(function() {
    0 === o2.current.children.length && r2(false);
  }, [o2]), n2 ? w("div", { ref: o2, className: rt(et("head"), i2.className.header), style: e({}, i2.style.header) }, w(Gt, { position: zt.Header })) : null;
}
function In() {
  var t3 = bt(null), n2 = yt(true), r2 = n2[0], o2 = n2[1], i2 = It();
  return gt(function() {
    0 === t3.current.children.length && o2(false);
  }, [t3]), r2 ? w("div", { ref: t3, className: rt(et("footer"), i2.className.footer), style: e({}, i2.style.footer) }, w(Gt, { position: zt.Footer })) : null;
}
function Tn() {
  var t3 = It(), n2 = Ht().dispatch, r2 = jt(function(t4) {
    return t4.status;
  }), o2 = jt(function(t4) {
    return t4.data;
  }), i2 = jt(function(t4) {
    return t4.tableRef;
  }), u2 = { current: null }, s2 = xn(function() {
    try {
      n2(function(t4) {
        return e({}, t4, { status: a.Loading });
      });
      var r3 = function(r4, o3) {
        try {
          var i3 = Promise.resolve(t3.pipeline.process()).then(function(t4) {
            n2(/* @__PURE__ */ function(t5) {
              return function(n3) {
                return t5 ? e({}, n3, { data: t5, status: a.Loaded }) : n3;
              };
            }(t4)), setTimeout(function() {
              n2(function(t5) {
                return t5.status === a.Loaded ? e({}, t5, { status: a.Rendered }) : t5;
              });
            }, 0);
          });
        } catch (t4) {
          return o3(t4);
        }
        return i3 && i3.then ? i3.then(void 0, o3) : i3;
      }(0, function(t4) {
        Vt.error(t4), n2(function(t5) {
          return e({}, t5, { data: null, status: a.Error });
        });
      });
      return Promise.resolve(r3 && r3.then ? r3.then(function() {
      }) : void 0);
    } catch (t4) {
      return Promise.reject(t4);
    }
  }, t3.processingThrottleMs);
  return gt(function() {
    return n2(Pn(t3.header)), s2(), t3.pipeline.on("updated", s2), function() {
      return t3.pipeline.off("updated", s2);
    };
  }, []), gt(function() {
    t3.header && r2 === a.Loaded && null != o2 && o2.length && n2(Pn(t3.header.adjustWidth(t3, i2, u2)));
  }, [o2, t3, u2]), w("div", { role: "complementary", className: rt("gridjs", et("container"), r2 === a.Loading ? et("loading") : null, t3.className.container), style: e({}, t3.style.container, { width: t3.width }) }, r2 === a.Loading && w("div", { className: et("loading-bar") }), w(En, null), w("div", { className: et("wrapper"), style: { height: t3.height } }, w(Cn, null)), w(In, null), w("div", { ref: u2, id: "gridjs-temp", className: et("temp") }));
}
var Ln = /* @__PURE__ */ function(t3) {
  function n2(n3) {
    var e3;
    return (e3 = t3.call(this) || this).config = void 0, e3.plugin = void 0, e3.config = new pn().assign({ instance: i(e3), eventEmitter: i(e3) }).update(n3), e3.plugin = e3.config.plugin, e3;
  }
  r(n2, t3);
  var e2 = n2.prototype;
  return e2.updateConfig = function(t4) {
    return this.config.update(t4), this;
  }, e2.createElement = function() {
    return w(fn.Provider, { value: this.config, children: w(Tn, {}) });
  }, e2.forceRender = function() {
    return this.config && this.config.container || Vt.error("Container is empty. Make sure you call render() before forceRender()", true), this.destroy(), q(this.createElement(), this.config.container), this;
  }, e2.destroy = function() {
    this.config.pipeline.clearCache(), q(null, this.config.container);
  }, e2.render = function(t4) {
    return t4 || Vt.error("Container element cannot be null", true), t4.childNodes.length > 0 ? (Vt.error("The container element " + t4 + " is not empty. Make sure the container is empty and call render() again"), this) : (this.config.container = t4, q(this.createElement(), t4), this);
  }, n2;
}(Q);

// src/gui/statistics.tsx
var import_path = __toESM(require("path"));
var import_vhtml = __toESM(require_vhtml());
Chart.register(
  BarElement,
  BarController,
  plugin_legend,
  plugin_title,
  plugin_tooltip,
  plugin_subtitle,
  CategoryScale,
  LinearScale,
  PieController,
  ArcElement
);
var StatisticsView = class {
  constructor(containerEl, osrCore) {
    this.containerEl = containerEl;
    this.osrCore = osrCore;
  }
  render() {
    this.containerEl.style.textAlign = "center";
    this.containerEl.innerHTML += /* @__PURE__ */ (0, import_vhtml.default)("select", { id: "sr-chart-period" }, /* @__PURE__ */ (0, import_vhtml.default)("option", { value: "month", selected: true }, t("MONTH")), /* @__PURE__ */ (0, import_vhtml.default)("option", { value: "quarter" }, t("QUARTER")), /* @__PURE__ */ (0, import_vhtml.default)("option", { value: "year" }, t("YEAR")), /* @__PURE__ */ (0, import_vhtml.default)("option", { value: "lifetime" }, t("LIFETIME")));
    const cardStats = this.osrCore.cardStats;
    let maxN = cardStats.delayedDays.getMaxValue();
    for (let dueOffset = 0; dueOffset <= maxN; dueOffset++) {
      cardStats.delayedDays.clearCountIfMissing(dueOffset);
    }
    const dueDatesFlashcardsCopy = { 0: 0 };
    for (const [dueOffset, dueCount] of getTypedObjectEntries(cardStats.delayedDays.dict)) {
      if (dueOffset <= 0) {
        dueDatesFlashcardsCopy[0] += dueCount;
      } else {
        dueDatesFlashcardsCopy[dueOffset] = dueCount;
      }
    }
    const scheduledCount = cardStats.youngCount + cardStats.matureCount;
    maxN = Math.max(maxN, 1);
    this.containerEl.innerHTML += /* @__PURE__ */ (0, import_vhtml.default)("div", null, /* @__PURE__ */ (0, import_vhtml.default)("canvas", { id: "forecastChart" }), /* @__PURE__ */ (0, import_vhtml.default)("span", { id: "forecastChartSummary" }), /* @__PURE__ */ (0, import_vhtml.default)("br", null), /* @__PURE__ */ (0, import_vhtml.default)("br", null), /* @__PURE__ */ (0, import_vhtml.default)("canvas", { id: "intervalsChart" }), /* @__PURE__ */ (0, import_vhtml.default)("span", { id: "intervalsChartSummary" }), /* @__PURE__ */ (0, import_vhtml.default)("br", null), /* @__PURE__ */ (0, import_vhtml.default)("br", null), /* @__PURE__ */ (0, import_vhtml.default)("canvas", { id: "easesChart" }), /* @__PURE__ */ (0, import_vhtml.default)("span", { id: "easesChartSummary" }), /* @__PURE__ */ (0, import_vhtml.default)("br", null), /* @__PURE__ */ (0, import_vhtml.default)("br", null), /* @__PURE__ */ (0, import_vhtml.default)("canvas", { id: "cardTypesChart" }), /* @__PURE__ */ (0, import_vhtml.default)("br", null), /* @__PURE__ */ (0, import_vhtml.default)("span", { id: "cardTypesChartSummary" }), /* @__PURE__ */ (0, import_vhtml.default)("br", null), /* @__PURE__ */ (0, import_vhtml.default)("br", null), /* @__PURE__ */ (0, import_vhtml.default)("h1", null, "Notes"), /* @__PURE__ */ (0, import_vhtml.default)("div", { id: "noteStats" }));
    this.forecastChart = createStatsChart(
      "bar",
      "forecastChart",
      t("FORECAST"),
      t("FORECAST_DESC"),
      Object.keys(dueDatesFlashcardsCopy),
      Object.values(dueDatesFlashcardsCopy),
      t("REVIEWS_PER_DAY", { avg: (scheduledCount / maxN).toFixed(1) }),
      t("SCHEDULED"),
      t("DAYS"),
      t("NUMBER_OF_CARDS")
    );
    maxN = cardStats.intervals.getMaxValue();
    for (let interval = 0; interval <= maxN; interval++) {
      cardStats.intervals.clearCountIfMissing(interval);
    }
    const averageInterval = textInterval(
      Math.round(
        cardStats.intervals.getTotalOfValueMultiplyCount() / scheduledCount * 10
      ) / 10 || 0,
      false
    ), longestInterval = textInterval(cardStats.intervals.getMaxValue(), false);
    this.intervalsChart = createStatsChart(
      "bar",
      "intervalsChart",
      t("INTERVALS"),
      t("INTERVALS_DESC"),
      Object.keys(cardStats.intervals.dict),
      Object.values(cardStats.intervals.dict),
      t("INTERVALS_SUMMARY", { avg: averageInterval, longest: longestInterval }),
      t("COUNT"),
      t("DAYS"),
      t("NUMBER_OF_CARDS")
    );
    const eases = getKeysPreserveType(cardStats.eases.dict);
    for (let ease = Math.min(...eases); ease <= Math.max(...eases); ease++) {
      cardStats.eases.clearCountIfMissing(ease);
    }
    const averageEase = Math.round(cardStats.eases.getTotalOfValueMultiplyCount() / scheduledCount) || 0;
    this.easesChart = createStatsChart(
      "bar",
      "easesChart",
      t("EASES"),
      "",
      Object.keys(cardStats.eases.dict),
      Object.values(cardStats.eases.dict),
      t("EASES_SUMMARY", { avgEase: averageEase }),
      t("COUNT"),
      t("EASES"),
      t("NUMBER_OF_CARDS")
    );
    const totalCardsCount = this.osrCore.reviewableDeckTree.getDistinctCardCount(
      2 /* All */,
      true
    );
    this.cardTypesChart = createStatsChart(
      "pie",
      "cardTypesChart",
      t("CARD_TYPES"),
      t("CARD_TYPES_DESC"),
      [
        `${t("CARD_TYPE_NEW")} - ${Math.round(cardStats.newCount / totalCardsCount * 100)}%`,
        `${t("CARD_TYPE_YOUNG")} - ${Math.round(
          cardStats.youngCount / totalCardsCount * 100
        )}%`,
        `${t("CARD_TYPE_MATURE")} - ${Math.round(
          cardStats.matureCount / totalCardsCount * 100
        )}%`
      ],
      [cardStats.newCount, cardStats.youngCount, cardStats.matureCount],
      t("CARD_TYPES_SUMMARY", { totalCardsCount })
    );
    const noteEases = mapRecord(
      SrsAlgorithm.getInstance().noteStats().dict,
      (key, value) => [
        import_path.default.parse(key).name,
        Math.round(value)
      ]
    );
    this.noteStatsGrid = new Ln({
      columns: [
        {
          name: t("NOTE")
        },
        {
          name: t("EASE"),
          sort: true,
          width: "200px"
        }
      ],
      search: true,
      autoWidth: false,
      data: Object.entries(noteEases).sort((a2, b2) => b2[1] - a2[1]),
      pagination: {
        limit: 10,
        summary: false
      },
      language: {
        search: {
          placeholder: t("SEARCH")
        },
        pagination: {
          previous: t("PREVIOUS"),
          next: t("NEXT")
        }
      }
    });
    this.noteStatsGrid.render(document.getElementById("noteStats"));
  }
  destroy() {
    this.forecastChart.destroy();
    this.intervalsChart.destroy();
    this.easesChart.destroy();
    this.cardTypesChart.destroy();
    this.noteStatsGrid.destroy();
  }
};
function createStatsChart(type, canvasId, title, subtitle, labels, data, summary, seriesTitle = "", xAxisTitle = "", yAxisTitle = "") {
  const style = getComputedStyle(document.body);
  const textColor = style.getPropertyValue("--text-normal");
  let scales = {}, backgroundColor = ["#2196f3"];
  if (type !== "pie") {
    scales = {
      x: {
        title: {
          display: true,
          text: xAxisTitle,
          color: textColor
        }
      },
      y: {
        title: {
          display: true,
          text: yAxisTitle,
          color: textColor
        }
      }
    };
  } else {
    backgroundColor = ["#2196f3", "#4caf50", "green"];
  }
  const shouldFilter = canvasId === "forecastChart" || canvasId === "intervalsChart";
  const statsChart = new Chart(document.getElementById(canvasId), {
    type,
    data: {
      labels: shouldFilter ? labels.slice(0, 31) : labels,
      datasets: [
        {
          label: seriesTitle,
          backgroundColor,
          data: shouldFilter ? data.slice(0, 31) : data
        }
      ]
    },
    options: {
      scales,
      plugins: {
        title: {
          display: true,
          text: title,
          font: {
            size: 22
          },
          color: textColor
        },
        subtitle: {
          display: true,
          text: subtitle,
          font: {
            size: 16,
            style: "italic"
          },
          color: textColor
        },
        legend: {
          display: false
        }
      },
      aspectRatio: 2
    }
  });
  if (shouldFilter) {
    const chartPeriodEl = document.getElementById("sr-chart-period");
    chartPeriodEl.addEventListener("click", () => {
      let filteredLabels, filteredData;
      const chartPeriod = chartPeriodEl.value;
      if (chartPeriod === "month") {
        filteredLabels = labels.slice(0, 31);
        filteredData = data.slice(0, 31);
      } else if (chartPeriod === "quarter") {
        filteredLabels = labels.slice(0, 91);
        filteredData = data.slice(0, 91);
      } else if (chartPeriod === "year") {
        filteredLabels = labels.slice(0, 366);
        filteredData = data.slice(0, 366);
      } else {
        filteredLabels = labels;
        filteredData = data;
      }
      statsChart.data.labels = filteredLabels;
      statsChart.data.datasets[0] = {
        label: seriesTitle,
        backgroundColor,
        data: filteredData
      };
      statsChart.update();
    });
  }
  document.getElementById(`${canvasId}Summary`).innerText = summary;
  return statsChart;
}

// src/gui/tabs.tsx
var import_obsidian5 = require("obsidian");
var import_vhtml2 = __toESM(require_vhtml());
function createTabs(containerElement, tabs, activateTabId) {
  const tabHeader = containerElement.createEl("div", {
    attr: { class: "sr-tab-header" }
  });
  const tabContentContainers = {};
  const tabButtons = {};
  const tabStructure = {
    header: tabHeader,
    // Indicate that the first tab is active.
    // This does not affect what tab is active in practice, it just reports the active tab.
    activeTabId: Object.keys(tabs)[0],
    buttons: tabButtons,
    contentContainers: tabContentContainers,
    contentGeneratorPromises: {}
  };
  let firstButton;
  for (const tabId in tabs) {
    const tab = tabs[tabId];
    const button = tabHeader.createEl("button", {
      attr: {
        class: "sr-tab-header-button",
        activateTab: "sr-tab-" + tabId
      }
    });
    button.onclick = function(event) {
      var _a;
      const tabButton = this;
      let maxWidth = 0;
      let maxHeight = 0;
      const tabHeader2 = tabButton.parentElement;
      if (null === tabHeader2) {
        throw new Error("Tab header is missing. Did not get a parent from tab button.");
      }
      const containerElement2 = tabHeader2.parentElement;
      if (null === containerElement2) {
        throw new Error(
          "Container element is missing. Did not get a parent from tab header."
        );
      }
      const tabContents = containerElement2.findAll("div.sr-tab-content");
      const isMainSettingsModal = containerElement2.hasClass("vertical-tab-content");
      for (const index in tabContents) {
        const tabContent2 = tabContents[index];
        if (!isMainSettingsModal) {
          tabContent2.addClass("sr-tab-active");
          if (tabContent2.offsetHeight > maxHeight) {
            maxHeight = tabContent2.offsetHeight;
          }
          if (tabContent2.offsetWidth > maxWidth) {
            maxWidth = tabContent2.offsetWidth;
          }
        }
        tabContent2.removeClass("sr-tab-active");
      }
      const adjacentTabButtons = tabHeader2.findAll(".sr-tab-header-button");
      for (const index in adjacentTabButtons) {
        const tabButton2 = adjacentTabButtons[index];
        tabButton2.removeClass("sr-tab-active");
      }
      tabButton.addClass("sr-tab-active");
      const activateTabAttribute = tabButton.attributes.getNamedItem("activateTab");
      if (null === activateTabAttribute) {
        throw new Error("Tab button has no 'activateTab' HTML attribute! Murr!");
      }
      const activateTabId2 = activateTabAttribute.value;
      const tabContent = document.getElementById(activateTabId2);
      if (null === tabContent) {
        throw new Error(
          "No tab content was found with activate_tab_id '" + activateTabId2 + "'! Hmph!"
        );
      }
      tabContent.addClass("sr-tab-active");
      tabStructure.activeTabId = activateTabId2.replace(/^sr-tab-/, "");
      (_a = tabContent.find(".sr-focus-element-on-tab-opening")) == null ? void 0 : _a.focus();
      if (!isMainSettingsModal) {
        tabContent.style.width = maxWidth + "px";
        tabContent.style.height = maxHeight + "px";
      }
      event.preventDefault();
    };
    if (tab.icon) (0, import_obsidian5.setIcon)(button, tab.icon);
    button.insertAdjacentHTML("beforeend", /* @__PURE__ */ (0, import_vhtml2.default)("span", { style: "padding-left: 5px;" }, tab.title));
    tabButtons[tabId] = button;
    tabContentContainers[tabId] = containerElement.createEl("div", {
      attr: { class: "sr-tab-content", id: "sr-tab-" + tabId }
    });
    tabStructure.contentGeneratorPromises[tabId] = tab.contentGenerator(
      tabContentContainers[tabId]
    );
    if (void 0 === firstButton) {
      firstButton = button;
    }
  }
  tabButtons[activateTabId].click();
  return tabStructure;
}

// src/gui/settings.tsx
var applyDebounceTimer = 0;
function applySettingsUpdate(callback2) {
  clearTimeout(applyDebounceTimer);
  applyDebounceTimer = window.setTimeout(callback2, 512);
}
var SRSettingTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.lastPosition = {
      scrollPosition: 0,
      tabName: "main-flashcards"
    };
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const header = containerEl.createEl("h4", {
      text: `${t("SETTINGS_HEADER")}`
    });
    header.addClass("sr-centered");
    this.tabStructure = createTabs(
      containerEl,
      {
        "main-flashcards": {
          title: t("FLASHCARDS"),
          icon: "SpacedRepIcon",
          contentGenerator: (containerElement) => this.tabFlashcards(containerElement)
        },
        "main-notes": {
          title: t("NOTES"),
          icon: "book-text",
          contentGenerator: (containerElement) => this.tabNotes(containerElement)
        },
        "main-algorithm": {
          title: t("SCHEDULING"),
          icon: "calendar",
          contentGenerator: (containerElement) => this.tabScheduling(containerElement)
        },
        "main-ui-preferences": {
          title: t("UI"),
          icon: "presentation",
          contentGenerator: (containerElement) => this.tabUiPreferences(containerElement)
        },
        "main-statistics": {
          title: t("STATS_TITLE"),
          icon: "bar-chart-3",
          contentGenerator: async (containerElement) => {
            if (this.plugin.osrAppCore.cardStats == null) {
              await this.plugin.sync();
            }
            this.statistics = new StatisticsView(
              containerElement,
              this.plugin.osrAppCore
            );
            this.statistics.render();
          }
        },
        "main-help": {
          title: t("HELP"),
          icon: "badge-help",
          contentGenerator: (containerElement) => this.tabHelp(containerElement)
        }
      },
      this.lastPosition.tabName
    );
    this.tabStructure.contentGeneratorPromises[this.tabStructure.activeTabId].then(() => {
      this.rememberLastPosition(containerEl);
    });
  }
  hide() {
    this.statistics.destroy();
    this.containerEl.empty();
  }
  async tabFlashcards(containerEl) {
    containerEl.createEl("h3", { text: t("GROUP_TAGS_FOLDERS") });
    new import_obsidian6.Setting(containerEl).setName(t("FLASHCARD_TAGS")).setDesc(t("FLASHCARD_TAGS_DESC")).addTextArea(
      (text) => text.setValue(this.plugin.data.settings.flashcardTags.join(" ")).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.flashcardTags = value.split(/\s+/);
          await this.plugin.savePluginData();
        });
      })
    );
    new import_obsidian6.Setting(containerEl).setName(t("CONVERT_FOLDERS_TO_DECKS")).setDesc(t("CONVERT_FOLDERS_TO_DECKS_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.convertFoldersToDecks).onChange(async (value) => {
        this.plugin.data.settings.convertFoldersToDecks = value;
        await this.plugin.savePluginData();
      })
    );
    this.createSettingFoldersToIgnore(containerEl);
    containerEl.createEl("h3", { text: t("GROUP_FLASHCARD_REVIEW") });
    new import_obsidian6.Setting(containerEl).setName(t("BURY_SIBLINGS_TILL_NEXT_DAY")).setDesc(t("BURY_SIBLINGS_TILL_NEXT_DAY_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.burySiblingCards).onChange(async (value) => {
        this.plugin.data.settings.burySiblingCards = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian6.Setting(containerEl).setName(t("REVIEW_CARD_ORDER_WITHIN_DECK")).addDropdown(
      (dropdown) => dropdown.addOptions({
        NewFirstSequential: t("REVIEW_CARD_ORDER_NEW_FIRST_SEQUENTIAL"),
        DueFirstSequential: t("REVIEW_CARD_ORDER_DUE_FIRST_SEQUENTIAL"),
        NewFirstRandom: t("REVIEW_CARD_ORDER_NEW_FIRST_RANDOM"),
        DueFirstRandom: t("REVIEW_CARD_ORDER_DUE_FIRST_RANDOM"),
        EveryCardRandomDeckAndCard: t("REVIEW_CARD_ORDER_RANDOM_DECK_AND_CARD")
      }).setValue(this.plugin.data.settings.flashcardCardOrder).onChange(async (value) => {
        this.plugin.data.settings.flashcardCardOrder = value;
        await this.plugin.savePluginData();
        this.display();
      })
    );
    const deckOrderEnabled = this.plugin.data.settings.flashcardCardOrder != "EveryCardRandomDeckAndCard";
    new import_obsidian6.Setting(containerEl).setName(t("REVIEW_DECK_ORDER")).addDropdown(
      (dropdown) => dropdown.addOptions(
        deckOrderEnabled ? {
          // eslint-disable-next-line camelcase
          PrevDeckComplete_Sequential: t(
            "REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_SEQUENTIAL"
          ),
          // eslint-disable-next-line camelcase
          PrevDeckComplete_Random: t(
            "REVIEW_DECK_ORDER_PREV_DECK_COMPLETE_RANDOM"
          )
        } : {
          EveryCardRandomDeckAndCard: t(
            "REVIEW_DECK_ORDER_RANDOM_DECK_AND_CARD"
          )
        }
      ).setValue(
        deckOrderEnabled ? this.plugin.data.settings.flashcardDeckOrder : "EveryCardRandomDeckAndCard"
      ).setDisabled(!deckOrderEnabled).onChange(async (value) => {
        this.plugin.data.settings.flashcardDeckOrder = value;
        await this.plugin.savePluginData();
      })
    );
    containerEl.createEl("h3", { text: t("GROUP_FLASHCARD_SEPARATORS") });
    const convertHighlightsToClozesEl = new import_obsidian6.Setting(containerEl).setName(
      t("CONVERT_HIGHLIGHTS_TO_CLOZES")
    );
    convertHighlightsToClozesEl.descEl.insertAdjacentHTML(
      "beforeend",
      t("CONVERT_HIGHLIGHTS_TO_CLOZES_DESC", { defaultPattern: "==[123;;]answer[;;hint]==" })
    );
    convertHighlightsToClozesEl.addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.convertHighlightsToClozes).onChange(async (value) => {
        const defaultHightlightPattern = "==[123;;]answer[;;hint]==";
        const clozePatternSet = new Set(this.plugin.data.settings.clozePatterns);
        if (value) {
          clozePatternSet.add(defaultHightlightPattern);
        } else {
          clozePatternSet.delete(defaultHightlightPattern);
        }
        this.plugin.data.settings.clozePatterns = [...clozePatternSet];
        this.plugin.data.settings.convertHighlightsToClozes = value;
        await this.plugin.savePluginData();
        this.display();
      })
    );
    const convertBoldTextToClozesEl = new import_obsidian6.Setting(containerEl).setName(
      t("CONVERT_BOLD_TEXT_TO_CLOZES")
    );
    convertBoldTextToClozesEl.descEl.insertAdjacentHTML(
      "beforeend",
      t("CONVERT_BOLD_TEXT_TO_CLOZES_DESC", { defaultPattern: "**[123;;]answer[;;hint]**" })
    );
    convertBoldTextToClozesEl.addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.convertBoldTextToClozes).onChange(async (value) => {
        const defaultBoldPattern = "**[123;;]answer[;;hint]**";
        const clozePatternSet = new Set(this.plugin.data.settings.clozePatterns);
        if (value) {
          clozePatternSet.add(defaultBoldPattern);
        } else {
          clozePatternSet.delete(defaultBoldPattern);
        }
        this.plugin.data.settings.clozePatterns = [...clozePatternSet];
        this.plugin.data.settings.convertBoldTextToClozes = value;
        await this.plugin.savePluginData();
        this.display();
      })
    );
    const convertCurlyBracketsToClozesEl = new import_obsidian6.Setting(containerEl).setName(
      t("CONVERT_CURLY_BRACKETS_TO_CLOZES")
    );
    convertCurlyBracketsToClozesEl.descEl.insertAdjacentHTML(
      "beforeend",
      t("CONVERT_CURLY_BRACKETS_TO_CLOZES_DESC", {
        defaultPattern: "{{[123;;]answer[;;hint]}}"
      })
    );
    convertCurlyBracketsToClozesEl.addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.convertCurlyBracketsToClozes).onChange(async (value) => {
        const defaultCurlyBracketsPattern = "{{[123;;]answer[;;hint]}}";
        const clozePatternSet = new Set(this.plugin.data.settings.clozePatterns);
        if (value) {
          clozePatternSet.add(defaultCurlyBracketsPattern);
        } else {
          clozePatternSet.delete(defaultCurlyBracketsPattern);
        }
        this.plugin.data.settings.clozePatterns = [...clozePatternSet];
        this.plugin.data.settings.convertCurlyBracketsToClozes = value;
        await this.plugin.savePluginData();
        this.display();
      })
    );
    const clozePatternsEl = new import_obsidian6.Setting(containerEl).setName(t("CLOZE_PATTERNS"));
    clozePatternsEl.descEl.insertAdjacentHTML(
      "beforeend",
      t("CLOZE_PATTERNS_DESC", {
        docsUrl: "https://www.stephenmwangi.com/obsidian-spaced-repetition/flashcards/cloze-cards/#cloze-types"
      })
    );
    clozePatternsEl.addTextArea(
      (text) => text.setPlaceholder(
        "Example:\n==[123;;]answer[;;hint]==\n**[123;;]answer[;;hint]**\n{{[123;;]answer[;;hint]}}"
      ).setValue(this.plugin.data.settings.clozePatterns.join("\n")).onChange((value) => {
        applySettingsUpdate(async () => {
          const defaultHightlightPattern = "==[123;;]answer[;;hint]==";
          const defaultBoldPattern = "**[123;;]answer[;;hint]**";
          const defaultCurlyBracketsPattern = "{{[123;;]answer[;;hint]}}";
          const clozePatternSet = new Set(
            value.split(/\n+/).map((v2) => v2.trim()).filter((v2) => v2)
          );
          if (clozePatternSet.has(defaultHightlightPattern)) {
            this.plugin.data.settings.convertHighlightsToClozes = true;
          } else {
            this.plugin.data.settings.convertHighlightsToClozes = false;
          }
          if (clozePatternSet.has(defaultBoldPattern)) {
            this.plugin.data.settings.convertBoldTextToClozes = true;
          } else {
            this.plugin.data.settings.convertBoldTextToClozes = false;
          }
          if (clozePatternSet.has(defaultCurlyBracketsPattern)) {
            this.plugin.data.settings.convertCurlyBracketsToClozes = true;
          } else {
            this.plugin.data.settings.convertCurlyBracketsToClozes = false;
          }
          this.plugin.data.settings.clozePatterns = [...clozePatternSet];
          await this.plugin.savePluginData();
        });
      })
    );
    new import_obsidian6.Setting(containerEl).setName(t("INLINE_CARDS_SEPARATOR")).setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING")).addText(
      (text) => text.setValue(this.plugin.data.settings.singleLineCardSeparator).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.singleLineCardSeparator = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.singleLineCardSeparator = DEFAULT_SETTINGS.singleLineCardSeparator;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian6.Setting(containerEl).setName(t("INLINE_REVERSED_CARDS_SEPARATOR")).setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING")).addText(
      (text) => text.setValue(this.plugin.data.settings.singleLineReversedCardSeparator).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.singleLineReversedCardSeparator = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.singleLineReversedCardSeparator = DEFAULT_SETTINGS.singleLineReversedCardSeparator;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian6.Setting(containerEl).setName(t("MULTILINE_CARDS_SEPARATOR")).setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING")).addText(
      (text) => text.setValue(this.plugin.data.settings.multilineCardSeparator).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.multilineCardSeparator = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.multilineCardSeparator = DEFAULT_SETTINGS.multilineCardSeparator;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian6.Setting(containerEl).setName(t("MULTILINE_REVERSED_CARDS_SEPARATOR")).setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING")).addText(
      (text) => text.setValue(this.plugin.data.settings.multilineReversedCardSeparator).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.multilineReversedCardSeparator = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.multilineReversedCardSeparator = DEFAULT_SETTINGS.multilineReversedCardSeparator;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian6.Setting(containerEl).setName(t("MULTILINE_CARDS_END_MARKER")).setDesc(t("FIX_SEPARATORS_MANUALLY_WARNING")).addText(
      (text) => text.setValue(this.plugin.data.settings.multilineCardEndMarker).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.multilineCardEndMarker = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.multilineCardEndMarker = DEFAULT_SETTINGS.multilineCardEndMarker;
        await this.plugin.savePluginData();
        this.display();
      });
    });
  }
  async tabNotes(containerEl) {
    containerEl.createEl("h3", { text: t("GROUP_TAGS_FOLDERS") });
    new import_obsidian6.Setting(containerEl).setName(t("TAGS_TO_REVIEW")).setDesc(t("TAGS_TO_REVIEW_DESC")).addTextArea(
      (text) => text.setValue(this.plugin.data.settings.tagsToReview.join(" ")).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.tagsToReview = value.split(/\s+/);
          await this.plugin.savePluginData();
        });
      })
    );
    this.createSettingFoldersToIgnore(containerEl);
    containerEl.createEl("h3", { text: t("NOTES_REVIEW_QUEUE") });
    new import_obsidian6.Setting(containerEl).setName(t("AUTO_NEXT_NOTE")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.autoNextNote).onChange(async (value) => {
        this.plugin.data.settings.autoNextNote = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian6.Setting(containerEl).setName(t("OPEN_RANDOM_NOTE")).setDesc(t("OPEN_RANDOM_NOTE_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.openRandomNote).onChange(async (value) => {
        this.plugin.data.settings.openRandomNote = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian6.Setting(containerEl).setName(t("REVIEW_PANE_ON_STARTUP")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.enableNoteReviewPaneOnStartup).onChange(async (value) => {
        this.plugin.data.settings.enableNoteReviewPaneOnStartup = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian6.Setting(containerEl).setName(t("MAX_N_DAYS_REVIEW_QUEUE")).addText(
      (text) => text.setValue(this.plugin.data.settings.maxNDaysNotesReviewQueue.toString()).onChange((value) => {
        applySettingsUpdate(async () => {
          const numValue = Number.parseInt(value);
          if (!isNaN(numValue)) {
            if (numValue < 1) {
              new import_obsidian6.Notice(t("MIN_ONE_DAY"));
              text.setValue(
                this.plugin.data.settings.maxNDaysNotesReviewQueue.toString()
              );
              return;
            }
            this.plugin.data.settings.maxNDaysNotesReviewQueue = numValue;
            await this.plugin.savePluginData();
          } else {
            new import_obsidian6.Notice(t("VALID_NUMBER_WARNING"));
          }
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.maxNDaysNotesReviewQueue = DEFAULT_SETTINGS.maxNDaysNotesReviewQueue;
        await this.plugin.savePluginData();
        this.display();
      });
    });
  }
  async createSettingFoldersToIgnore(containerEl) {
    new import_obsidian6.Setting(containerEl).setName(t("FOLDERS_TO_IGNORE")).setDesc(t("FOLDERS_TO_IGNORE_DESC")).addTextArea(
      (text) => text.setValue(this.plugin.data.settings.noteFoldersToIgnore.join("\n")).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.noteFoldersToIgnore = value.split(/\n+/).map((v2) => v2.trim()).filter((v2) => v2);
          await this.plugin.savePluginData();
          this.display();
        });
      })
    );
  }
  async tabUiPreferences(containerEl) {
    containerEl.createEl("h3", { text: t("OBSIDIAN_INTEGRATION") });
    new import_obsidian6.Setting(containerEl).setName(t("OPEN_IN_TAB")).setDesc(t("OPEN_IN_TAB_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.openViewInNewTab).onChange(async (value) => {
        if (value) {
          this.plugin.registerSRFocusListener();
        } else {
          this.plugin.tabViewManager.closeAllTabViews();
          this.plugin.removeSRFocusListener();
        }
        this.plugin.data.settings.openViewInNewTab = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian6.Setting(containerEl).setName(t("SHOW_RIBBON_ICON")).setDesc(t("SHOW_RIBBON_ICON_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.showRibbonIcon).onChange(async (value) => {
        this.plugin.data.settings.showRibbonIcon = value;
        await this.plugin.savePluginData();
        this.plugin.showRibbonIcon(value);
      })
    );
    new import_obsidian6.Setting(containerEl).setName(t("SHOW_STATUS_BAR")).setDesc(t("SHOW_STATUS_BAR_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.showStatusBar).onChange(async (value) => {
        this.plugin.data.settings.showStatusBar = value;
        await this.plugin.savePluginData();
        this.plugin.showStatusBar(value);
      })
    );
    new import_obsidian6.Setting(containerEl).setName(t("ENABLE_FILE_MENU_REVIEW_OPTIONS")).setDesc(t("ENABLE_FILE_MENU_REVIEW_OPTIONS_DESC")).addToggle(
      (toggle) => toggle.setValue(!this.plugin.data.settings.disableFileMenuReviewOptions).onChange(async (value) => {
        this.plugin.data.settings.disableFileMenuReviewOptions = !value;
        await this.plugin.savePluginData();
        this.plugin.showFileMenuItems(value);
      })
    );
    containerEl.createEl("h3", { text: t("FLASHCARDS") });
    new import_obsidian6.Setting(containerEl).setName(t("INITIALLY_EXPAND_SUBDECKS_IN_TREE")).setDesc(t("INITIALLY_EXPAND_SUBDECKS_IN_TREE_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.initiallyExpandAllSubdecksInTree).onChange(async (value) => {
        this.plugin.data.settings.initiallyExpandAllSubdecksInTree = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian6.Setting(containerEl).setName(t("SHOW_CARD_CONTEXT")).setDesc(t("SHOW_CARD_CONTEXT_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.showContextInCards).onChange(async (value) => {
        this.plugin.data.settings.showContextInCards = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian6.Setting(containerEl).setName(t("SHOW_INTERVAL_IN_REVIEW_BUTTONS")).setDesc(t("SHOW_INTERVAL_IN_REVIEW_BUTTONS_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.showIntervalInReviewButtons).onChange(async (value) => {
        this.plugin.data.settings.showIntervalInReviewButtons = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian6.Setting(containerEl).setName(t("CARD_MODAL_HEIGHT_PERCENT")).setDesc(t("CARD_MODAL_SIZE_PERCENT_DESC")).addSlider(
      (slider) => slider.setLimits(10, 100, 5).setValue(this.plugin.data.settings.flashcardHeightPercentage).setDynamicTooltip().onChange(async (value) => {
        this.plugin.data.settings.flashcardHeightPercentage = value;
        await this.plugin.savePluginData();
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.flashcardHeightPercentage = DEFAULT_SETTINGS.flashcardHeightPercentage;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian6.Setting(containerEl).setName(t("CARD_MODAL_WIDTH_PERCENT")).setDesc(t("CARD_MODAL_SIZE_PERCENT_DESC")).addSlider(
      (slider) => slider.setLimits(10, 100, 5).setValue(this.plugin.data.settings.flashcardWidthPercentage).setDynamicTooltip().onChange(async (value) => {
        this.plugin.data.settings.flashcardWidthPercentage = value;
        await this.plugin.savePluginData();
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.flashcardWidthPercentage = DEFAULT_SETTINGS.flashcardWidthPercentage;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    containerEl.createEl("h3", { text: t("GROUP_FLASHCARDS_NOTES") });
    new import_obsidian6.Setting(containerEl).setName(t("FLASHCARD_EASY_LABEL")).setDesc(t("FLASHCARD_EASY_DESC")).addText(
      (text) => text.setValue(this.plugin.data.settings.flashcardEasyText).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.flashcardEasyText = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.flashcardEasyText = DEFAULT_SETTINGS.flashcardEasyText;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian6.Setting(containerEl).setName(t("FLASHCARD_GOOD_LABEL")).setDesc(t("FLASHCARD_GOOD_DESC")).addText(
      (text) => text.setValue(this.plugin.data.settings.flashcardGoodText).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.flashcardGoodText = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.flashcardGoodText = DEFAULT_SETTINGS.flashcardGoodText;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian6.Setting(containerEl).setName(t("FLASHCARD_HARD_LABEL")).setDesc(t("FLASHCARD_HARD_DESC")).addText(
      (text) => text.setValue(this.plugin.data.settings.flashcardHardText).onChange((value) => {
        applySettingsUpdate(async () => {
          this.plugin.data.settings.flashcardHardText = value;
          await this.plugin.savePluginData();
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.flashcardHardText = DEFAULT_SETTINGS.flashcardHardText;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian6.Setting(containerEl).setName(t("REVIEW_BUTTON_DELAY")).setDesc(t("REVIEW_BUTTON_DELAY_DESC")).addSlider(
      (slider) => slider.setLimits(0, 5e3, 100).setValue(this.plugin.data.settings.reviewButtonDelay).setDynamicTooltip().onChange(async (value) => {
        this.plugin.data.settings.reviewButtonDelay = value;
        await this.plugin.savePluginData();
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.reviewButtonDelay = DEFAULT_SETTINGS.reviewButtonDelay;
        await this.plugin.savePluginData();
        this.display();
      });
    });
  }
  async tabScheduling(containerEl) {
    containerEl.createEl("h3", { text: t("ALGORITHM") });
    const algoSettingEl = new import_obsidian6.Setting(containerEl).setName(t("ALGORITHM"));
    algoSettingEl.descEl.insertAdjacentHTML(
      "beforeend",
      t("CHECK_ALGORITHM_WIKI", {
        algoUrl: "https://www.stephenmwangi.com/obsidian-spaced-repetition/algorithms/"
      })
    );
    algoSettingEl.addDropdown(
      (dropdown) => dropdown.addOptions({
        "SM-2-OSR": t("SM2_OSR_VARIANT")
      }).setValue(this.plugin.data.settings.algorithm).onChange(async (value) => {
        this.plugin.data.settings.algorithm = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian6.Setting(containerEl).setName(t("BASE_EASE")).setDesc(t("BASE_EASE_DESC")).addText(
      (text) => text.setValue(this.plugin.data.settings.baseEase.toString()).onChange((value) => {
        applySettingsUpdate(async () => {
          const numValue = Number.parseInt(value);
          if (!isNaN(numValue)) {
            if (numValue < 130) {
              new import_obsidian6.Notice(t("BASE_EASE_MIN_WARNING"));
              text.setValue(this.plugin.data.settings.baseEase.toString());
              return;
            }
            this.plugin.data.settings.baseEase = numValue;
            await this.plugin.savePluginData();
          } else {
            new import_obsidian6.Notice(t("VALID_NUMBER_WARNING"));
          }
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.baseEase = DEFAULT_SETTINGS.baseEase;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian6.Setting(containerEl).setName(t("LAPSE_INTERVAL_CHANGE")).setDesc(t("LAPSE_INTERVAL_CHANGE_DESC")).addSlider(
      (slider) => slider.setLimits(1, 99, 1).setValue(this.plugin.data.settings.lapsesIntervalChange * 100).setDynamicTooltip().onChange(async (value) => {
        this.plugin.data.settings.lapsesIntervalChange = value / 100;
        await this.plugin.savePluginData();
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.lapsesIntervalChange = DEFAULT_SETTINGS.lapsesIntervalChange;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian6.Setting(containerEl).setName(t("EASY_BONUS")).setDesc(t("EASY_BONUS_DESC")).addText(
      (text) => text.setValue((this.plugin.data.settings.easyBonus * 100).toString()).onChange((value) => {
        applySettingsUpdate(async () => {
          const numValue = Number.parseInt(value) / 100;
          if (!isNaN(numValue)) {
            if (numValue < 1) {
              new import_obsidian6.Notice(t("EASY_BONUS_MIN_WARNING"));
              text.setValue(
                (this.plugin.data.settings.easyBonus * 100).toString()
              );
              return;
            }
            this.plugin.data.settings.easyBonus = numValue;
            await this.plugin.savePluginData();
          } else {
            new import_obsidian6.Notice(t("VALID_NUMBER_WARNING"));
          }
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.easyBonus = DEFAULT_SETTINGS.easyBonus;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian6.Setting(containerEl).setName(t("LOAD_BALANCE")).setDesc(t("LOAD_BALANCE_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.loadBalance).onChange(async (value) => {
        this.plugin.data.settings.loadBalance = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian6.Setting(containerEl).setName(t("MAX_INTERVAL")).setDesc(t("MAX_INTERVAL_DESC")).addText(
      (text) => text.setValue(this.plugin.data.settings.maximumInterval.toString()).onChange((value) => {
        applySettingsUpdate(async () => {
          const numValue = Number.parseInt(value);
          if (!isNaN(numValue)) {
            if (numValue < 1) {
              new import_obsidian6.Notice(t("MAX_INTERVAL_MIN_WARNING"));
              text.setValue(
                this.plugin.data.settings.maximumInterval.toString()
              );
              return;
            }
            this.plugin.data.settings.maximumInterval = numValue;
            await this.plugin.savePluginData();
          } else {
            new import_obsidian6.Notice(t("VALID_NUMBER_WARNING"));
          }
        });
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.maximumInterval = DEFAULT_SETTINGS.maximumInterval;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    new import_obsidian6.Setting(containerEl).setName(t("MAX_LINK_CONTRIB")).setDesc(t("MAX_LINK_CONTRIB_DESC")).addSlider(
      (slider) => slider.setLimits(0, 100, 1).setValue(this.plugin.data.settings.maxLinkFactor * 100).setDynamicTooltip().onChange(async (value) => {
        this.plugin.data.settings.maxLinkFactor = value / 100;
        await this.plugin.savePluginData();
      })
    ).addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("RESET_DEFAULT")).onClick(async () => {
        this.plugin.data.settings.maxLinkFactor = DEFAULT_SETTINGS.maxLinkFactor;
        await this.plugin.savePluginData();
        this.display();
      });
    });
    containerEl.createEl("h3", { text: t("GROUP_DATA_STORAGE") });
    new import_obsidian6.Setting(containerEl).setName(t("GROUP_DATA_STORAGE")).setDesc(t("GROUP_DATA_STORAGE_DESC")).addDropdown(
      (dropdown) => dropdown.addOptions({
        NOTES: t("STORE_IN_NOTES")
      }).setValue(this.plugin.data.settings.dataStore).onChange(async (value) => {
        this.plugin.data.settings.dataStore = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian6.Setting(containerEl).setName(t("INLINE_SCHEDULING_COMMENTS")).setDesc(t("INLINE_SCHEDULING_COMMENTS_DESC")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.cardCommentOnSameLine).onChange(async (value) => {
        this.plugin.data.settings.cardCommentOnSameLine = value;
        await this.plugin.savePluginData();
      })
    );
  }
  async tabHelp(containerEl) {
    containerEl.createEl("h3", { text: `${t("HELP")}` });
    containerEl.createEl("p").insertAdjacentHTML(
      "beforeend",
      t("CHECK_WIKI", {
        wikiUrl: "https://www.stephenmwangi.com/obsidian-spaced-repetition/"
      })
    );
    containerEl.createEl("p").insertAdjacentHTML(
      "beforeend",
      t("GITHUB_DISCUSSIONS", {
        discussionsUrl: "https://github.com/st3v3nmw/obsidian-spaced-repetition/discussions/"
      })
    );
    containerEl.createEl("p").insertAdjacentHTML(
      "beforeend",
      t("GITHUB_ISSUES", {
        issuesUrl: "https://github.com/st3v3nmw/obsidian-spaced-repetition/issues/"
      })
    );
    containerEl.createEl("h3", { text: `${t("LOGGING")}` });
    new import_obsidian6.Setting(containerEl).setName(t("DISPLAY_SCHEDULING_DEBUG_INFO")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.showSchedulingDebugMessages).onChange(async (value) => {
        this.plugin.data.settings.showSchedulingDebugMessages = value;
        await this.plugin.savePluginData();
      })
    );
    new import_obsidian6.Setting(containerEl).setName(t("DISPLAY_PARSER_DEBUG_INFO")).addToggle(
      (toggle) => toggle.setValue(this.plugin.data.settings.showParserDebugMessages).onChange(async (value) => {
        this.plugin.data.settings.showParserDebugMessages = value;
        setDebugParser(this.plugin.data.settings.showParserDebugMessages);
        await this.plugin.savePluginData();
      })
    );
    containerEl.createEl("h3", { text: t("GROUP_CONTRIBUTING") });
    containerEl.createEl("p").insertAdjacentHTML(
      "beforeend",
      t("GITHUB_SOURCE_CODE", {
        githubProjectUrl: "https://github.com/st3v3nmw/obsidian-spaced-repetition"
      })
    );
    containerEl.createEl("p").insertAdjacentHTML(
      "beforeend",
      t("CODE_CONTRIBUTION_INFO", {
        codeContributionUrl: "https://www.stephenmwangi.com/obsidian-spaced-repetition/contributing/#code"
      })
    );
    containerEl.createEl("p").insertAdjacentHTML(
      "beforeend",
      t("TRANSLATION_CONTRIBUTION_INFO", {
        translationContributionUrl: "https://www.stephenmwangi.com/obsidian-spaced-repetition/contributing/#translating"
      })
    );
  }
  rememberLastPosition(containerElement) {
    const lastPosition = this.lastPosition;
    this.tabStructure.buttons[lastPosition.tabName].click();
    containerElement.scrollTo({
      top: this.lastPosition.scrollPosition,
      behavior: "auto"
    });
    containerElement.addEventListener("scroll", (_2) => {
      this.lastPosition.scrollPosition = containerElement.scrollTop;
    });
    for (const tabName in this.tabStructure.buttons) {
      const button = this.tabStructure.buttons[tabName];
      button.onClickEvent((_2) => {
        lastPosition.tabName = tabName;
      });
    }
  }
};

// src/gui/sidebar.tsx
var OsrSidebar = class {
  get app() {
    return this.plugin.app;
  }
  constructor(plugin, settings, nextNoteReviewHandler) {
    this.plugin = plugin;
    this.settings = settings;
    this.nextNoteReviewHandler = nextNoteReviewHandler;
  }
  redraw() {
    this.reviewQueueListView.redraw();
  }
  getActiveLeaf(type) {
    const leaves = this.app.workspace.getLeavesOfType(type);
    if (leaves.length == 0) {
      return this.app.workspace.getRightLeaf(false);
    }
    return leaves[0];
  }
  init() {
    this.plugin.registerView(REVIEW_QUEUE_VIEW_TYPE, (leaf) => {
      return this.reviewQueueListView = new ReviewQueueListView(
        leaf,
        this.nextNoteReviewHandler,
        this.settings
      );
    });
  }
  async activateReviewQueueViewPanel() {
    if (this.settings.enableNoteReviewPaneOnStartup) {
      await this.getActiveLeaf(REVIEW_QUEUE_VIEW_TYPE).setViewState({
        type: REVIEW_QUEUE_VIEW_TYPE,
        active: true
      });
    }
  }
  async openReviewQueueView() {
    const reviewQueueLeaf = this.getActiveLeaf(REVIEW_QUEUE_VIEW_TYPE);
    this.app.workspace.revealLeaf(reviewQueueLeaf);
  }
};

// src/gui/sr-modal.tsx
var import_obsidian10 = require("obsidian");

// src/gui/card-ui.tsx
var import_moment4 = __toESM(require_moment());
var import_obsidian8 = require("obsidian");

// src/utils/renderers.ts
var import_obsidian7 = require("obsidian");
var RenderMarkdownWrapper = class {
  constructor(app, plugin, notePath) {
    this.app = app;
    this.notePath = notePath;
    this.plugin = plugin;
  }
  // slightly modified version of the renderMarkdown function in
  // https://github.com/mgmeyers/obsidian-kanban/blob/main/src/KanbanView.tsx
  async renderMarkdownWrapper(markdownString, containerEl, textDirection, recursiveDepth = 0) {
    if (recursiveDepth > 4) return;
    let el;
    if (textDirection == 2 /* Rtl */) {
      el = containerEl.createDiv();
      el.setAttribute("dir", "rtl");
    } else el = containerEl;
    import_obsidian7.MarkdownRenderer.render(this.app, markdownString, el, this.notePath, this.plugin);
    el.findAll(".internal-embed").forEach((el2) => {
      const link2 = this.parseLink(el2.getAttribute("src"));
      if (!link2.target) {
        el2.innerText = link2.text;
      } else if (link2.target instanceof import_obsidian7.TFile) {
        if (link2.target.extension !== "md") {
          this.embedMediaFile(el2, link2.target);
        } else {
        }
      }
    });
  }
  parseLink(src) {
    const linkComponentsRegex = /^(?<file>[^#^]+)?(?:#(?!\^)(?<heading>.+)|#\^(?<blockId>.+)|#)?$/;
    const matched = typeof src === "string" && src.match(linkComponentsRegex);
    const file = matched.groups.file || this.notePath;
    const target = this.plugin.app.metadataCache.getFirstLinkpathDest(file, this.notePath);
    return {
      text: matched[0],
      file: matched.groups.file,
      heading: matched.groups.heading,
      blockId: matched.groups.blockId,
      target
    };
  }
  embedMediaFile(el, target) {
    el.innerText = "";
    if (IMAGE_FORMATS.includes(target.extension)) {
      el.createEl(
        "img",
        {
          attr: {
            src: this.plugin.app.vault.getResourcePath(target)
          }
        },
        (img) => {
          if (el.hasAttribute("width"))
            img.setAttribute("width", el.getAttribute("width"));
          else img.setAttribute("width", "100%");
          if (el.hasAttribute("alt")) img.setAttribute("alt", el.getAttribute("alt"));
          el.addEventListener(
            "click",
            (ev) => ev.target.style.minWidth = ev.target.style.minWidth === "100%" ? null : "100%"
          );
        }
      );
      el.addClasses(["image-embed", "is-loaded"]);
    } else if (AUDIO_FORMATS.includes(target.extension) || VIDEO_FORMATS.includes(target.extension)) {
      el.createEl(
        AUDIO_FORMATS.includes(target.extension) ? "audio" : "video",
        {
          attr: {
            controls: "",
            src: this.plugin.app.vault.getResourcePath(target)
          }
        },
        (audio) => {
          if (el.hasAttribute("alt")) audio.setAttribute("alt", el.getAttribute("alt"));
        }
      );
      el.addClasses(["media-embed", "is-loaded"]);
    } else {
      el.innerText = target.path;
    }
  }
};

// src/gui/card-ui.tsx
var CardUI = class {
  constructor(app, plugin, settings, reviewSequencer, reviewMode, view, backToDeck, editClickHandler) {
    this.totalCardsInSession = 0;
    this.totalDecksInSession = 0;
    this.currentDeckTotalCardsInQueue = 0;
    this._keydownHandler = (e2) => {
      if (document.activeElement.nodeName === "TEXTAREA" || this.mode === 3 /* Closed */ || !this.plugin.getSRInFocusState()) {
        return;
      }
      const consumeKeyEvent = () => {
        e2.preventDefault();
        e2.stopPropagation();
      };
      switch (e2.code) {
        case "KeyS":
          this._skipCurrentCard();
          consumeKeyEvent();
          break;
        case "Space":
          if (this.mode === 1 /* Front */) {
            this._showAnswer();
            consumeKeyEvent();
          } else if (this.mode === 2 /* Back */) {
            this._processReview(1 /* Good */);
            consumeKeyEvent();
          }
          break;
        case "Enter":
        case "NumpadEnter":
          if (this.mode !== 1 /* Front */) {
            break;
          }
          this._showAnswer();
          consumeKeyEvent();
          break;
        case "Numpad1":
        case "Digit1":
          if (this.mode !== 2 /* Back */) {
            break;
          }
          this._processReview(2 /* Hard */);
          consumeKeyEvent();
          break;
        case "Numpad2":
        case "Digit2":
          if (this.mode !== 2 /* Back */) {
            break;
          }
          this._processReview(1 /* Good */);
          consumeKeyEvent();
          break;
        case "Numpad3":
        case "Digit3":
          if (this.mode !== 2 /* Back */) {
            break;
          }
          this._processReview(0 /* Easy */);
          consumeKeyEvent();
          break;
        case "Numpad0":
        case "Digit0":
          if (this.mode !== 2 /* Back */) {
            break;
          }
          this._processReview(3 /* Reset */);
          consumeKeyEvent();
          break;
        default:
          break;
      }
    };
    this.app = app;
    this.plugin = plugin;
    this.settings = settings;
    this.reviewSequencer = reviewSequencer;
    this.reviewMode = reviewMode;
    this.backToDeck = backToDeck;
    this.editClickHandler = editClickHandler;
    this.view = view;
    this.chosenDeck = null;
    this.init();
  }
  // #region -> public methods
  /**
   * Initializes all static elements in the FlashcardView
   */
  init() {
    this.view.addClasses(["sr-flashcard", "sr-is-hidden"]);
    this.controls = this.view.createDiv();
    this.controls.addClass("sr-controls");
    this._createCardControls();
    this._createInfoSection();
    this.content = this.view.createDiv();
    this.content.addClass("sr-content");
    this.response = this.view.createDiv();
    this.response.addClass("sr-response");
    this._createResponseButtons();
  }
  /**
   * Shows the FlashcardView if it is hidden
   */
  async show(chosenDeck) {
    if (!this.view.hasClass("sr-is-hidden")) {
      return;
    }
    this.chosenDeck = chosenDeck;
    const deckStats = this.reviewSequencer.getDeckStats(chosenDeck.getTopicPath());
    this.totalCardsInSession = deckStats.cardsInQueueCount;
    this.totalDecksInSession = deckStats.decksInQueueOfThisDeckCount;
    await this._drawContent();
    this.view.removeClass("sr-is-hidden");
    document.addEventListener("keydown", this._keydownHandler);
  }
  /**
   * Refreshes all dynamic elements
   */
  async refresh() {
    await this._drawContent();
  }
  /**
   * Hides the FlashcardView if it is visible
   */
  hide() {
    if (this.view.hasClass("sr-is-hidden")) {
      return;
    }
    document.removeEventListener("keydown", this._keydownHandler);
    this.view.addClass("sr-is-hidden");
  }
  /**
   * Closes the FlashcardView
   */
  close() {
    this.hide();
    document.removeEventListener("keydown", this._keydownHandler);
  }
  // #region -> Functions & helpers
  async _drawContent() {
    this.resetButton.disabled = true;
    this.mode = 1 /* Front */;
    this.previousDeck = this.currentDeck;
    this.currentDeck = this.reviewSequencer.currentDeck;
    if (this.previousDeck !== this.currentDeck) {
      const currentDeckStats = this.reviewSequencer.getDeckStats(
        this.currentDeck.getTopicPath()
      );
      this.currentDeckTotalCardsInQueue = currentDeckStats.cardsInQueueOfThisDeckCount;
    }
    this._updateInfoBar(this.chosenDeck, this.currentDeck);
    this.content.empty();
    const wrapper = new RenderMarkdownWrapper(
      this.app,
      this.plugin,
      this._currentNote.filePath
    );
    await wrapper.renderMarkdownWrapper(
      this._currentCard.front.trimStart(),
      this.content,
      this._currentQuestion.questionText.textDirection
    );
    this.content.scrollTop = 0;
    this._resetResponseButtons();
  }
  get _currentCard() {
    return this.reviewSequencer.currentCard;
  }
  get _currentQuestion() {
    return this.reviewSequencer.currentQuestion;
  }
  get _currentNote() {
    return this.reviewSequencer.currentNote;
  }
  async _processReview(response) {
    const timeNow = (0, import_moment4.now)();
    if (this.lastPressed && timeNow - this.lastPressed < this.plugin.data.settings.reviewButtonDelay) {
      return;
    }
    this.lastPressed = timeNow;
    await this.reviewSequencer.processReview(response);
    await this._showNextCard();
  }
  async _showNextCard() {
    if (this._currentCard != null) await this.refresh();
    else this.backToDeck();
  }
  // #region -> Controls
  _createCardControls() {
    this._createEditButton();
    this._createResetButton();
    this._createCardInfoButton();
    this._createSkipButton();
  }
  _createEditButton() {
    this.editButton = this.controls.createEl("button");
    this.editButton.addClasses(["sr-button", "sr-edit-button"]);
    (0, import_obsidian8.setIcon)(this.editButton, "edit");
    this.editButton.setAttribute("aria-label", t("EDIT_CARD"));
    this.editButton.addEventListener("click", async () => {
      this.editClickHandler();
    });
  }
  _createResetButton() {
    this.resetButton = this.controls.createEl("button");
    this.resetButton.addClasses(["sr-button", "sr-reset-button"]);
    (0, import_obsidian8.setIcon)(this.resetButton, "refresh-cw");
    this.resetButton.setAttribute("aria-label", t("RESET_CARD_PROGRESS"));
    this.resetButton.addEventListener("click", () => {
      this._processReview(3 /* Reset */);
    });
  }
  _createCardInfoButton() {
    this.infoButton = this.controls.createEl("button");
    this.infoButton.addClasses(["sr-button", "sr-info-button"]);
    (0, import_obsidian8.setIcon)(this.infoButton, "info");
    this.infoButton.setAttribute("aria-label", "View Card Info");
    this.infoButton.addEventListener("click", async () => {
      this._displayCurrentCardInfoNotice();
    });
  }
  _createSkipButton() {
    this.skipButton = this.controls.createEl("button");
    this.skipButton.addClasses(["sr-button", "sr-skip-button"]);
    (0, import_obsidian8.setIcon)(this.skipButton, "chevrons-right");
    this.skipButton.setAttribute("aria-label", t("SKIP"));
    this.skipButton.addEventListener("click", () => {
      this._skipCurrentCard();
    });
  }
  async _skipCurrentCard() {
    this.reviewSequencer.skipCurrentCard();
    await this._showNextCard();
  }
  _displayCurrentCardInfoNotice() {
    var _a;
    const schedule = this._currentCard.scheduleInfo;
    const currentEaseStr = t("CURRENT_EASE_HELP_TEXT") + ((_a = schedule == null ? void 0 : schedule.latestEase) != null ? _a : t("NEW"));
    const currentIntervalStr = t("CURRENT_INTERVAL_HELP_TEXT") + textInterval(schedule == null ? void 0 : schedule.interval, false);
    const generatedFromStr = t("CARD_GENERATED_FROM", {
      notePath: this._currentQuestion.note.filePath
    });
    new import_obsidian8.Notice(currentEaseStr + "\n" + currentIntervalStr + "\n" + generatedFromStr);
  }
  // #region -> Deck Info
  _createInfoSection() {
    this.infoSection = this.view.createDiv();
    this.infoSection.addClass("sr-info-section");
    this.deckProgressInfo = this.infoSection.createDiv();
    this.deckProgressInfo.addClass("sr-deck-progress-info");
    this.chosenDeckInfo = this.deckProgressInfo.createDiv();
    this.chosenDeckInfo.addClass("sr-chosen-deck-info");
    this.chosenDeckName = this.chosenDeckInfo.createDiv();
    this.chosenDeckName.addClass("sr-chosen-deck-name");
    this.chosenDeckCounterWrapper = this.chosenDeckInfo.createDiv();
    this.chosenDeckCounterWrapper.addClass("sr-chosen-deck-counter-wrapper");
    this.chosenDeckCounterDivider = this.chosenDeckCounterWrapper.createDiv();
    this.chosenDeckCounterDivider.addClass("sr-chosen-deck-counter-divider");
    this.chosenDeckCardCounterWrapper = this.chosenDeckCounterWrapper.createDiv();
    this.chosenDeckCardCounterWrapper.addClass("sr-chosen-deck-card-counter-wrapper");
    this.chosenDeckCardCounter = this.chosenDeckCardCounterWrapper.createDiv();
    this.chosenDeckCardCounter.addClass("sr-chosen-deck-card-counter");
    this.chosenDeckCardCounterIcon = this.chosenDeckCardCounterWrapper.createDiv();
    this.chosenDeckCardCounterIcon.addClass("sr-chosen-deck-card-counter-icon");
    (0, import_obsidian8.setIcon)(this.chosenDeckCardCounterIcon, "credit-card");
    this.chosenDeckSubDeckCounterWrapper = this.chosenDeckCounterWrapper.createDiv();
    this.chosenDeckSubDeckCounterWrapper.addClass("sr-is-hidden");
    this.chosenDeckSubDeckCounterWrapper.addClass("sr-chosen-deck-subdeck-counter-wrapper");
    this.chosenDeckSubDeckCounter = this.chosenDeckSubDeckCounterWrapper.createDiv();
    this.chosenDeckSubDeckCounter.addClass("sr-chosen-deck-subdeck-counter");
    this.chosenDeckSubDeckCounterIcon = this.chosenDeckSubDeckCounterWrapper.createDiv();
    this.chosenDeckSubDeckCounterIcon.addClass("sr-chosen-deck-subdeck-counter-icon");
    (0, import_obsidian8.setIcon)(this.chosenDeckSubDeckCounterIcon, "layers");
    this.currentDeckInfo = this.deckProgressInfo.createDiv();
    this.currentDeckInfo.addClass("sr-is-hidden");
    this.currentDeckInfo.addClass("sr-current-deck-info");
    this.currentDeckName = this.currentDeckInfo.createDiv();
    this.currentDeckName.addClass("sr-current-deck-name");
    this.currentDeckCounterWrapper = this.currentDeckInfo.createDiv();
    this.currentDeckCounterWrapper.addClass("sr-current-deck-counter-wrapper");
    this.currentDeckCounterDivider = this.currentDeckCounterWrapper.createDiv();
    this.currentDeckCounterDivider.addClass("sr-current-deck-counter-divider");
    this.currentDeckCardCounterWrapper = this.currentDeckCounterWrapper.createDiv();
    this.currentDeckCardCounterWrapper.addClass("sr-current-deck-card-counter-wrapper");
    this.currentDeckCardCounter = this.currentDeckCardCounterWrapper.createDiv();
    this.currentDeckCardCounter.addClass("sr-current-deck-card-counter");
    this.currentDeckCardCounterIcon = this.currentDeckCardCounterWrapper.createDiv();
    this.currentDeckCardCounterIcon.addClass("sr-current-deck-card-counter-icon");
    (0, import_obsidian8.setIcon)(this.currentDeckCardCounterIcon, "credit-card");
    if (this.settings.showContextInCards) {
      this.cardContext = this.infoSection.createDiv();
      this.cardContext.addClass("sr-context");
    }
  }
  _updateInfoBar(chosenDeck, currentDeck) {
    this._updateChosenDeckInfo(chosenDeck);
    this._updateCurrentDeckInfo(chosenDeck, currentDeck);
    this._updateCardContext();
  }
  _updateChosenDeckInfo(chosenDeck) {
    const chosenDeckStats = this.reviewSequencer.getDeckStats(chosenDeck.getTopicPath());
    this.chosenDeckName.setText(`${chosenDeck.deckName}`);
    this.chosenDeckCardCounter.setText(
      `${this.totalCardsInSession - chosenDeckStats.cardsInQueueCount}/${this.totalCardsInSession}`
    );
    if (chosenDeck.subdecks.length === 0) {
      if (!this.chosenDeckSubDeckCounterWrapper.hasClass("sr-is-hidden")) {
        this.chosenDeckSubDeckCounterWrapper.addClass("sr-is-hidden");
      }
      return;
    }
    if (this.chosenDeckSubDeckCounterWrapper.hasClass("sr-is-hidden")) {
      this.chosenDeckSubDeckCounterWrapper.removeClass("sr-is-hidden");
    }
    this.chosenDeckSubDeckCounter.setText(
      `${this.totalDecksInSession - chosenDeckStats.decksInQueueOfThisDeckCount}/${this.totalDecksInSession}`
    );
  }
  _updateCurrentDeckInfo(chosenDeck, currentDeck) {
    if (chosenDeck.subdecks.length === 0) {
      if (!this.currentDeckInfo.hasClass("sr-is-hidden")) {
        this.currentDeckInfo.addClass("sr-is-hidden");
      }
      return;
    }
    if (this.currentDeckInfo.hasClass("sr-is-hidden")) {
      this.currentDeckInfo.removeClass("sr-is-hidden");
    }
    this.currentDeckName.setText(`${currentDeck.deckName}`);
    const isRandomMode = this.settings.flashcardCardOrder === "EveryCardRandomDeckAndCard";
    if (!isRandomMode) {
      const currentDeckStats = this.reviewSequencer.getDeckStats(currentDeck.getTopicPath());
      this.currentDeckCardCounter.setText(
        `${this.currentDeckTotalCardsInQueue - currentDeckStats.cardsInQueueOfThisDeckCount}/${this.currentDeckTotalCardsInQueue}`
      );
    }
  }
  _updateCardContext() {
    if (!this.settings.showContextInCards) {
      this.cardContext.setText("");
      return;
    }
    this.cardContext.setText(
      ` ${this._formatQuestionContextText(this._currentQuestion.questionContext)}`
    );
  }
  _formatQuestionContextText(questionContext) {
    const separator = " > ";
    let result = this._currentNote.file.basename;
    questionContext.forEach((context) => {
      if (context.startsWith("[[") && context.endsWith("]]")) {
        context = context.replace("[[", "").replace("]]", "");
        if (context.contains("|")) {
          context = context.split("|")[1];
        }
      }
      result += separator + context;
    });
    return result;
  }
  // #region -> Response
  _createResponseButtons() {
    this._createShowAnswerButton();
    this._createHardButton();
    this._createGoodButton();
    this._createEasyButton();
  }
  _resetResponseButtons() {
    this.answerButton.removeClass("sr-is-hidden");
    this.hardButton.addClass("sr-is-hidden");
    this.goodButton.addClass("sr-is-hidden");
    this.easyButton.addClass("sr-is-hidden");
  }
  _createShowAnswerButton() {
    this.answerButton = this.response.createEl("button");
    this.answerButton.addClasses(["sr-response-button", "sr-show-answer-button", "sr-bg-blue"]);
    this.answerButton.setText(t("SHOW_ANSWER"));
    this.answerButton.addEventListener("click", () => {
      this._showAnswer();
    });
  }
  _createHardButton() {
    this.hardButton = this.response.createEl("button");
    this.hardButton.addClasses([
      "sr-response-button",
      "sr-hard-button",
      "sr-bg-red",
      "sr-is-hidden"
    ]);
    this.hardButton.setText(this.settings.flashcardHardText);
    this.hardButton.addEventListener("click", () => {
      this._processReview(2 /* Hard */);
    });
  }
  _createGoodButton() {
    this.goodButton = this.response.createEl("button");
    this.goodButton.addClasses([
      "sr-response-button",
      "sr-good-button",
      "sr-bg-blue",
      "sr-is-hidden"
    ]);
    this.goodButton.setText(this.settings.flashcardGoodText);
    this.goodButton.addEventListener("click", () => {
      this._processReview(1 /* Good */);
    });
  }
  _createEasyButton() {
    this.easyButton = this.response.createEl("button");
    this.easyButton.addClasses([
      "sr-response-button",
      "sr-hard-button",
      "sr-bg-green",
      "sr-is-hidden"
    ]);
    this.easyButton.setText(this.settings.flashcardEasyText);
    this.easyButton.addEventListener("click", () => {
      this._processReview(0 /* Easy */);
    });
  }
  _setupEaseButton(button, buttonName, reviewResponse) {
    const schedule = this.reviewSequencer.determineCardSchedule(
      reviewResponse,
      this._currentCard
    );
    const interval = schedule.interval;
    if (this.settings.showIntervalInReviewButtons) {
      if (import_obsidian8.Platform.isMobile) {
        button.setText(textInterval(interval, true));
      } else {
        button.setText(`${buttonName} - ${textInterval(interval, false)}`);
      }
    } else {
      button.setText(buttonName);
    }
  }
  _showAnswer() {
    const timeNow = (0, import_moment4.now)();
    if (this.lastPressed && timeNow - this.lastPressed < this.plugin.data.settings.reviewButtonDelay) {
      return;
    }
    this.lastPressed = timeNow;
    this.mode = 2 /* Back */;
    this.resetButton.disabled = false;
    if (this._currentQuestion.questionType !== 4 /* Cloze */) {
      const hr = document.createElement("hr");
      this.content.appendChild(hr);
    } else {
      this.content.empty();
    }
    const wrapper = new RenderMarkdownWrapper(
      this.app,
      this.plugin,
      this._currentNote.filePath
    );
    wrapper.renderMarkdownWrapper(
      this._currentCard.back,
      this.content,
      this._currentQuestion.questionText.textDirection
    );
    this.answerButton.addClass("sr-is-hidden");
    this.hardButton.removeClass("sr-is-hidden");
    this.easyButton.removeClass("sr-is-hidden");
    if (this.reviewMode === 0 /* Cram */) {
      this.response.addClass("is-cram");
      this.hardButton.setText(`${this.settings.flashcardHardText}`);
      this.easyButton.setText(`${this.settings.flashcardEasyText}`);
    } else {
      this.goodButton.removeClass("sr-is-hidden");
      this._setupEaseButton(
        this.hardButton,
        this.settings.flashcardHardText,
        2 /* Hard */
      );
      this._setupEaseButton(
        this.goodButton,
        this.settings.flashcardGoodText,
        1 /* Good */
      );
      this._setupEaseButton(
        this.easyButton,
        this.settings.flashcardEasyText,
        0 /* Easy */
      );
    }
  }
};

// src/gui/deck-ui.tsx
var import_vhtml3 = __toESM(require_vhtml());
var DeckUI = class {
  constructor(plugin, settings, reviewSequencer, view, startReviewOfDeck) {
    this.plugin = plugin;
    this.settings = settings;
    this.reviewSequencer = reviewSequencer;
    this.view = view;
    this.startReviewOfDeck = startReviewOfDeck;
    this.init();
  }
  /**
   * Initializes all static elements in the DeckListView
   */
  init() {
    this.view.addClasses(["sr-deck-list", "sr-is-hidden"]);
    this.header = this.view.createDiv();
    this.header.addClass("sr-header");
    this.title = this.header.createDiv();
    this.title.addClass("sr-title");
    this.title.setText(t("DECKS"));
    this.stats = this.header.createDiv();
    this.stats.addClass("sr-header-stats-container");
    this._createHeaderStats();
    this.headerDivider = this.view.createEl("hr");
    this.content = this.view.createDiv();
    this.content.addClass("sr-content");
  }
  /**
   * Shows the DeckListView & rerenders dynamic elements
   */
  show() {
    this.mode = 0 /* Deck */;
    this._createHeaderStats();
    this.content.empty();
    for (const deck of this.reviewSequencer.originalDeckTree.subdecks) {
      this._createTree(deck, this.content);
    }
    if (this.view.hasClass("sr-is-hidden")) {
      this.view.removeClass("sr-is-hidden");
    }
  }
  /**
   * Hides the DeckListView
   */
  hide() {
    if (!this.view.hasClass("sr-is-hidden")) {
      this.view.addClass("sr-is-hidden");
    }
  }
  /**
   * Closes the DeckListView
   */
  close() {
    this.hide();
  }
  // -> Header
  _createHeaderStats() {
    const statistics = this.reviewSequencer.getDeckStats(TopicPath.emptyPath);
    this.stats.empty();
    this._createHeaderStatsContainer(t("DUE_CARDS"), statistics.dueCount, "sr-bg-green");
    this._createHeaderStatsContainer(t("NEW_CARDS"), statistics.newCount, "sr-bg-blue");
    this._createHeaderStatsContainer(t("TOTAL_CARDS"), statistics.totalCount, "sr-bg-red");
  }
  _createHeaderStatsContainer(statsLable, statsNumber, statsClass) {
    const statsContainer = this.stats.createDiv();
    statsContainer.ariaLabel = statsLable;
    statsContainer.addClasses([
      "tag-pane-tag-count",
      "tree-item-flair",
      "sr-header-stats-count",
      statsClass
    ]);
    const lable = statsContainer.createDiv();
    lable.setText(statsLable + ":");
    const number = statsContainer.createDiv();
    number.setText(statsNumber.toString());
  }
  // -> Tree content
  _createTree(deck, container) {
    const deckTree = container.createDiv("tree-item sr-tree-item-container");
    const deckTreeSelf = deckTree.createDiv(
      "tree-item-self tag-pane-tag is-clickable sr-tree-item-row"
    );
    const shouldBeInitiallyExpanded = this.settings.initiallyExpandAllSubdecksInTree;
    let collapsed = !shouldBeInitiallyExpanded;
    let collapseIconEl = null;
    if (deck.subdecks.length > 0) {
      collapseIconEl = deckTreeSelf.createDiv("tree-item-icon collapse-icon");
      collapseIconEl.innerHTML = COLLAPSE_ICON;
      collapseIconEl.childNodes[0].style.transform = collapsed ? "rotate(-90deg)" : "";
    }
    const deckTreeInner = deckTreeSelf.createDiv("tree-item-inner");
    const deckTreeInnerText = deckTreeInner.createDiv("tag-pane-tag-text");
    deckTreeInnerText.innerHTML += /* @__PURE__ */ (0, import_vhtml3.default)("span", { class: "tag-pane-tag-self" }, deck.deckName);
    const deckTreeOuter = deckTreeSelf.createDiv();
    deckTreeOuter.addClasses(["tree-item-flair-outer", "sr-tree-stats-container"]);
    const deckStats = this.reviewSequencer.getDeckStats(deck.getTopicPath());
    this._createStats(deckStats, deckTreeOuter);
    const deckTreeChildren = deckTree.createDiv("tree-item-children");
    deckTreeChildren.style.display = collapsed ? "none" : "block";
    if (deck.subdecks.length > 0) {
      collapseIconEl.addEventListener("click", (e2) => {
        if (collapsed) {
          collapseIconEl.childNodes[0].style.transform = "";
          deckTreeChildren.style.display = "block";
        } else {
          collapseIconEl.childNodes[0].style.transform = "rotate(-90deg)";
          deckTreeChildren.style.display = "none";
        }
        e2.stopPropagation();
        collapsed = !collapsed;
      });
    }
    deckTreeSelf.addEventListener("click", () => {
      this.startReviewOfDeck(deck);
    });
    for (const subdeck of deck.subdecks) {
      this._createTree(subdeck, deckTreeChildren);
    }
  }
  _createStats(statistics, statsWrapper) {
    statsWrapper.empty();
    this._createStatsContainer(
      t("DUE_CARDS"),
      statistics.dueCount,
      "sr-bg-green",
      statsWrapper
    );
    this._createStatsContainer(t("NEW_CARDS"), statistics.newCount, "sr-bg-blue", statsWrapper);
    this._createStatsContainer(
      t("TOTAL_CARDS"),
      statistics.totalCount,
      "sr-bg-red",
      statsWrapper
    );
  }
  _createStatsContainer(statsLable, statsNumber, statsClass, statsWrapper) {
    const statsContainer = statsWrapper.createDiv();
    statsContainer.ariaLabel = statsLable;
    statsContainer.addClasses([
      "tag-pane-tag-count",
      "tree-item-flair",
      "sr-tree-stats-count",
      statsClass
    ]);
    statsContainer.setText(statsNumber.toString());
  }
};

// src/gui/edit-modal.tsx
var import_obsidian9 = require("obsidian");
var FlashcardEditModal = class _FlashcardEditModal extends import_obsidian9.Modal {
  constructor(app, existingText, textDirection) {
    super(app);
    this.didSaveChanges = false;
    // -> Functions & helpers
    this.saveClickCallback = (_2) => this.save();
    this.cancelClickCallback = (_2) => this.cancel();
    this.saveOnEnterCallback = (evt) => {
      if ((evt.ctrlKey || evt.metaKey) && evt.key === "Enter") {
        evt.preventDefault();
        this.save();
      }
    };
    this.modalText = existingText;
    this.changedText = existingText;
    this.textDirection = textDirection;
    this.waitForClose = new Promise((resolve2, reject) => {
      this.resolvePromise = resolve2;
      this.rejectPromise = reject;
    });
    this.modalEl.addClasses(["sr-modal", "sr-edit-modal"]);
    this.init();
    this.open();
  }
  static Prompt(app, placeholder, textDirection) {
    const newPromptModal = new _FlashcardEditModal(app, placeholder, textDirection);
    return newPromptModal.waitForClose;
  }
  /**
   * Initializes all components of the EditModal
   */
  init() {
    var _a;
    this.contentEl.empty();
    this.contentEl.addClass("sr-edit-view");
    this.title = this.contentEl.createDiv();
    this.title.setText(t("EDIT_CARD"));
    this.title.addClass("sr-title");
    this.textArea = this.contentEl.createEl("textarea");
    this.textArea.addClass("sr-input");
    this.textArea.setText((_a = this.modalText) != null ? _a : "");
    this.textArea.addEventListener("keydown", this.saveOnEnterCallback);
    if (this.textDirection == 2 /* Rtl */) {
      this.textArea.setAttribute("dir", "rtl");
    }
    this._createResponse(this.contentEl);
  }
  /**
   * Opens the EditModal
   */
  onOpen() {
    super.onOpen();
    this.textArea.focus();
  }
  /**
   * Closes the EditModal
   */
  onClose() {
    super.onClose();
    this.resolveInput();
    this.removeInputListener();
  }
  save() {
    this.didSaveChanges = true;
    this.changedText = this.textArea.value;
    this.close();
  }
  cancel() {
    this.close();
  }
  resolveInput() {
    if (!this.didSaveChanges) this.rejectPromise(t("NO_INPUT"));
    else this.resolvePromise(this.changedText);
  }
  removeInputListener() {
    this.textArea.removeEventListener("keydown", this.saveOnEnterCallback);
  }
  // -> Response section
  _createResponseButton(container, text, colorClass, callback2) {
    const button = container.createEl("button");
    button.addClasses(["sr-response-button", colorClass]);
    button.setText(text);
    button.addEventListener("click", callback2);
  }
  _createResponse(mainContentContainer) {
    const response = mainContentContainer.createDiv();
    response.addClass("sr-response");
    this._createResponseButton(response, t("CANCEL"), "sr-bg-red", this.cancelClickCallback);
    this._createResponseButton(response, "", "sr-spacer", () => {
    });
    this._createResponseButton(response, t("SAVE"), "sr-bg-green", this.saveClickCallback);
  }
};

// src/gui/sr-modal.tsx
var FlashcardModal = class extends import_obsidian10.Modal {
  constructor(app, plugin, settings, reviewSequencer, reviewMode) {
    super(app);
    this.plugin = plugin;
    this.settings = settings;
    this.reviewSequencer = reviewSequencer;
    this.reviewMode = reviewMode;
    this.modalEl.style.height = this.settings.flashcardHeightPercentage + "%";
    this.modalEl.style.maxHeight = this.settings.flashcardHeightPercentage + "%";
    this.modalEl.style.width = this.settings.flashcardWidthPercentage + "%";
    this.modalEl.style.maxWidth = this.settings.flashcardWidthPercentage + "%";
    this.modalEl.setAttribute("id", "sr-modal");
    if (this.settings.flashcardHeightPercentage >= 100 || this.settings.flashcardWidthPercentage >= 100) {
      this.modalEl.style.borderRadius = "0";
    }
    this.contentEl.addClass("sr-modal-content");
    this.deckView = new DeckUI(
      this.plugin,
      this.settings,
      this.reviewSequencer,
      this.contentEl.createDiv(),
      this._startReviewOfDeck.bind(this)
    );
    this.flashcardView = new CardUI(
      this.app,
      this.plugin,
      this.settings,
      this.reviewSequencer,
      this.reviewMode,
      this.contentEl.createDiv(),
      this._showDecksList.bind(this),
      this._doEditQuestionText.bind(this)
    );
  }
  onOpen() {
    this._createBackButton();
    this._showDecksList();
  }
  onClose() {
    this.plugin.setSRViewInFocus(false);
    this.mode = 3 /* Closed */;
    this.deckView.close();
    this.flashcardView.close();
  }
  _showDecksList() {
    this._hideFlashcard();
    this.deckView.show();
  }
  _hideDecksList() {
    this.deckView.hide();
  }
  _showFlashcard(deck) {
    this._hideDecksList();
    this.flashcardView.show(deck);
  }
  _hideFlashcard() {
    this.flashcardView.hide();
  }
  _startReviewOfDeck(deck) {
    this.reviewSequencer.setCurrentDeck(deck.getTopicPath());
    if (this.reviewSequencer.hasCurrentCard) {
      this._showFlashcard(deck);
      this.backButton.removeClass("sr-is-hidden");
    } else {
      this._showDecksList();
    }
  }
  async _doEditQuestionText() {
    const currentQ = this.reviewSequencer.currentQuestion;
    const textPrompt = currentQ.questionText.actualQuestion;
    const editModal = FlashcardEditModal.Prompt(
      this.app,
      textPrompt,
      currentQ.questionText.textDirection
    );
    editModal.then(async (modifiedCardText) => {
      this.reviewSequencer.updateCurrentQuestionText(modifiedCardText);
    }).catch((reason) => console.log(reason));
  }
  _createBackButton() {
    this.backButton = this.modalEl.createDiv();
    this.backButton.addClasses(["sr-back-button", "sr-is-hidden"]);
    (0, import_obsidian10.setIcon)(this.backButton, "arrow-left");
    this.backButton.setAttribute("aria-label", t("BACK"));
    this.backButton.addEventListener("click", () => {
      this.backButton.addClass("sr-is-hidden");
      this._showDecksList();
    });
  }
};

// src/gui/sr-tab-view.tsx
var import_obsidian11 = require("obsidian");
var SRTabView = class extends import_obsidian11.ItemView {
  constructor(leaf, plugin, loadReviewSequencerData) {
    super(leaf);
    this.openErrorCount = 0;
    this.plugin = plugin;
    this.settings = plugin.data.settings;
    this.loadReviewSequencerData = loadReviewSequencerData;
    const viewContent = this.containerEl.getElementsByClassName("view-content");
    if (viewContent.length > 0) {
      this.viewContainerEl = viewContent[0];
      this.viewContainerEl.addClass("sr-tab-view");
      this.viewContentEl = this.viewContainerEl.createDiv("sr-tab-view-content");
      this.viewContentEl.style.height = this.settings.flashcardHeightPercentage + "%";
      this.viewContentEl.style.maxHeight = this.settings.flashcardHeightPercentage + "%";
      this.viewContentEl.style.width = this.settings.flashcardWidthPercentage + "%";
      this.viewContentEl.style.maxWidth = this.settings.flashcardWidthPercentage + "%";
      this.viewContainerEl.appendChild(this.viewContentEl);
    }
  }
  /**
   * Returns the view type identifier for the SRTabView.
   *
   * @returns {string} The view type identifier.
   */
  getViewType() {
    return SR_TAB_VIEW;
  }
  /**
   * Retrieves the icon identifier for the SRTabView.
   *
   * @returns {string} The tab icon identifier.
   */
  getIcon() {
    return "SpacedRepIcon";
  }
  /**
   * Returns the display text for the SRTabView.
   *
   * @returns {string} The display text for the SRTabView.
   */
  getDisplayText() {
    return "Spaced Repetition";
  }
  /**
   * Initializes the SRTabView when opened by loading the review sequencer data
   * and setting up the deck and flashcard views if they are not already initialized.
   * Catches and logs errors that occur during the initial loading process.
   */
  async onOpen() {
    try {
      this._createBackButton();
      const loadedData = await this.loadReviewSequencerData();
      this.reviewSequencer = loadedData.reviewSequencer;
      this.reviewMode = loadedData.mode;
      if (this.deckView === void 0) {
        this.deckView = new DeckUI(
          this.plugin,
          this.settings,
          this.reviewSequencer,
          this.viewContentEl.createDiv(),
          this._startReviewOfDeck.bind(this)
        );
      }
      if (this.flashcardView === void 0) {
        this.flashcardView = new CardUI(
          this.app,
          this.plugin,
          this.settings,
          this.reviewSequencer,
          this.reviewMode,
          this.viewContentEl.createDiv(),
          this._showDecksList.bind(this),
          this._doEditQuestionText.bind(this)
        );
      }
      this._showDecksList();
    } catch (e2) {
      if (this.openErrorCount > 0) {
        console.error(e2);
      }
      this.openErrorCount++;
    }
  }
  /**
   * Closes the SRTabView by shutting down any active deck or flashcard views.
   * Ensures that resources associated with these views are properly released.
   */
  async onClose() {
    if (this.deckView) this.deckView.close();
    if (this.flashcardView) this.flashcardView.close();
  }
  _showDecksList() {
    this._hideFlashcard();
    this.deckView.show();
  }
  _hideDecksList() {
    this.deckView.hide();
  }
  _showFlashcard(deck) {
    this._hideDecksList();
    this.flashcardView.show(deck);
  }
  _hideFlashcard() {
    this.flashcardView.hide();
  }
  _startReviewOfDeck(deck) {
    this.reviewSequencer.setCurrentDeck(deck.getTopicPath());
    if (this.reviewSequencer.hasCurrentCard) {
      this.backButton.removeClass("sr-is-hidden");
      this._showFlashcard(deck);
    } else {
      this._showDecksList();
    }
  }
  async _doEditQuestionText() {
    const currentQ = this.reviewSequencer.currentQuestion;
    const textPrompt = currentQ.questionText.actualQuestion;
    const editModal = FlashcardEditModal.Prompt(
      this.app,
      textPrompt,
      currentQ.questionText.textDirection
    );
    editModal.then(async (modifiedCardText) => {
      this.reviewSequencer.updateCurrentQuestionText(modifiedCardText);
    }).catch((reason) => console.log(reason));
  }
  _createBackButton() {
    this.backButton = this.viewContentEl.createDiv();
    this.backButton.addClasses(["sr-back-button", "sr-is-hidden"]);
    (0, import_obsidian11.setIcon)(this.backButton, "arrow-left");
    this.backButton.setAttribute("aria-label", t("BACK"));
    this.backButton.addEventListener("click", () => {
      this.backButton.addClass("sr-is-hidden");
      this._showDecksList();
    });
  }
};

// src/gui/tab-view-manager.tsx
var TabViewManager = class {
  // Add any needed resourced
  constructor(plugin) {
    // Add any new other tab view types to this, then they'll be automatically registered
    this.tabViewTypes = [
      {
        type: SR_TAB_VIEW,
        viewCreator: (leaf) => new SRTabView(leaf, this.plugin, async () => {
          if (this.shouldOpenSingeNoteTabView) {
            const singleNoteDeckData = await this.plugin.getPreparedDecksForSingleNoteReview(
              this.chosenSingleNoteForTabbedView,
              this.chosenReviewModeForTabbedView
            );
            return this.plugin.getPreparedReviewSequencer(
              singleNoteDeckData.deckTree,
              singleNoteDeckData.remainingDeckTree,
              singleNoteDeckData.mode
            );
          }
          const fullDeckTree = this.osrAppCore.reviewableDeckTree;
          const remainingDeckTree = this.chosenReviewModeForTabbedView === 0 /* Cram */ ? this.osrAppCore.reviewableDeckTree : this.osrAppCore.remainingDeckTree;
          return this.plugin.getPreparedReviewSequencer(
            fullDeckTree,
            remainingDeckTree,
            this.chosenReviewModeForTabbedView
          );
        })
      }
    ];
    this.plugin = plugin;
    this.shouldOpenSingeNoteTabView = false;
    this.registerAllTabViews();
  }
  /**
   * Opens the Spaced Repetition tab view in the application.
   *
   * This method sets up the necessary state for the tab view and invokes the
   * internal method to open the tab view with the specified parameters.
   *
   * @param osrAppCore - The core application instance used for managing reviewable decks.
   * @param reviewMode - The mode of flashcard review.
   * @param singleNote - Optional parameter specifying a single note to review.
   *                     If provided, the tab view will focus on this note.
   *
   * @returns {Promise<void>} - A promise that resolves when the tab view is opened.
   */
  async openSRTabView(osrAppCore, reviewMode, singleNote) {
    this.osrAppCore = osrAppCore;
    this.chosenReviewModeForTabbedView = reviewMode;
    this.shouldOpenSingeNoteTabView = singleNote !== void 0;
    if (singleNote) this.chosenSingleNoteForTabbedView = singleNote;
    await this.openTabView(SR_TAB_VIEW, true);
  }
  /**
   * Closes all open tab views in the application.
   *
   * This method iterates over all registered tab view types and detaches
   * their corresponding leaves from the workspace, effectively closing them.
   */
  closeAllTabViews() {
    this.forEachTabViewType((viewType) => {
      this.plugin.app.workspace.detachLeavesOfType(viewType.type);
    });
  }
  forEachTabViewType(callback2) {
    this.tabViewTypes.forEach((type) => callback2(type));
  }
  registerAllTabViews() {
    this.forEachTabViewType(
      (viewType) => this.plugin.registerView(viewType.type, viewType.viewCreator)
    );
  }
  async openTabView(type, newLeaf) {
    const { workspace } = this.plugin.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(type);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getLeaf(newLeaf);
      if (leaf !== null) {
        await leaf.setViewState({ type, active: true });
      }
    }
    if (leaf !== null) {
      workspace.revealLeaf(leaf);
    }
  }
};

// src/icons/app-icon.ts
var import_obsidian12 = require("obsidian");
function appIcon() {
  (0, import_obsidian12.addIcon)(
    "SpacedRepIcon",
    `<path fill="currentColor" stroke="currentColor" d="M 88.960938 17.257812 L 47.457031 17.257812 C 45.679688 17.257812 44.230469 18.703125 44.230469 20.484375 L 44.230469 86.558594 C 44.230469 88.335938 45.679688 89.785156 47.457031 89.785156 L 88.960938 89.785156 C 90.738281 89.785156 92.1875 88.335938 92.1875 86.558594 L 92.1875 20.484375 C 92.1875 18.703125 90.738281 17.257812 88.960938 17.257812 Z M 88.28125 85.878906 L 48.136719 85.878906 L 48.136719 21.164062 L 88.28125 21.164062 Z M 88.28125 85.878906 "/>
        <path fill="currentColor" stroke="currentColor"  d="M 88.960938 9.445312 L 61.667969 9.445312 C 59.925781 3.816406 54.011719 0.515625 48.269531 2.054688 L 8.183594 12.796875 C 2.304688 14.371094 -1.199219 20.4375 0.378906 26.316406 L 17.476562 90.140625 C 18.796875 95.066406 23.269531 98.324219 28.144531 98.324219 C 29.085938 98.324219 30.046875 98.199219 31 97.945312 L 40.765625 95.328125 C 42.625 96.75 44.941406 97.597656 47.457031 97.597656 L 88.960938 97.597656 C 95.046875 97.597656 100 92.644531 100 86.558594 L 100 20.484375 C 100 14.398438 95.046875 9.445312 88.960938 9.445312 Z M 29.988281 94.171875 C 26.1875 95.191406 22.269531 92.925781 21.25 89.128906 L 4.152344 25.304688 C 3.132812 21.507812 5.394531 17.585938 9.195312 16.570312 L 49.28125 5.828125 C 52.578125 4.945312 55.960938 6.53125 57.464844 9.445312 L 47.457031 9.445312 C 41.371094 9.445312 36.417969 14.398438 36.417969 20.484375 L 36.417969 86.558594 C 36.417969 88.558594 36.957031 90.433594 37.890625 92.054688 Z M 96.09375 86.558594 C 96.09375 90.492188 92.894531 93.691406 88.960938 93.691406 L 47.457031 93.691406 C 43.523438 93.691406 40.324219 90.492188 40.324219 86.558594 L 40.324219 20.484375 C 40.324219 16.550781 43.523438 13.351562 47.457031 13.351562 L 88.960938 13.351562 C 92.894531 13.351562 96.09375 16.550781 96.09375 20.484375 Z M 96.09375 86.558594 "/>
        <path fill="currentColor" stroke="currentColor"  d="M 54.101562 53.09375 L 60.070312 57.410156 L 57.789062 64.378906 C 56.90625 67.074219 59.996094 69.320312 62.285156 67.648438 L 68.210938 63.324219 L 74.132812 67.648438 C 76.421875 69.320312 79.511719 67.074219 78.628906 64.378906 L 76.347656 57.410156 L 82.320312 53.09375 C 84.613281 51.433594 83.441406 47.804688 80.605469 47.804688 L 73.242188 47.804688 L 70.988281 40.839844 C 70.117188 38.144531 66.300781 38.144531 65.429688 40.839844 L 63.179688 47.804688 L 55.8125 47.804688 C 52.980469 47.804688 51.804688 51.433594 54.101562 53.09375 Z M 54.101562 53.09375 "/>
        `
  );
}

// src/next-note-review-handler.ts
var import_obsidian14 = require("obsidian");

// src/gui/review-deck-selection-modal.tsx
var import_obsidian13 = require("obsidian");
var ReviewDeckSelectionModal = class extends import_obsidian13.FuzzySuggestModal {
  constructor(app, deckKeys) {
    super(app);
    this.deckKeys = [];
    this.deckKeys = deckKeys;
  }
  getItems() {
    return this.deckKeys;
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(deckKey, _2) {
    this.close();
    this.submitCallback(deckKey);
  }
};

// src/next-note-review-handler.ts
var NextNoteReviewHandler = class {
  get lastSelectedReviewDeck() {
    return this._lastSelectedReviewDeck;
  }
  get noteReviewQueue() {
    return this._noteReviewQueue;
  }
  constructor(app, settings, noteReviewQueue) {
    this.app = app;
    this.settings = settings;
    this._noteReviewQueue = noteReviewQueue;
  }
  async autoReviewNextNote() {
    if (this.settings.autoNextNote) {
      if (!this._lastSelectedReviewDeck) {
        const reviewDeckKeys = this._noteReviewQueue.reviewDeckNameList;
        if (reviewDeckKeys.length > 0) this._lastSelectedReviewDeck = reviewDeckKeys[0];
        else {
          new import_obsidian14.Notice(t("ALL_CAUGHT_UP"));
          return;
        }
      }
      this.reviewNextNote(this._lastSelectedReviewDeck);
    }
  }
  async reviewNextNoteModal() {
    const reviewDeckNames = this._noteReviewQueue.reviewDeckNameList;
    if (reviewDeckNames.length === 1) {
      this.reviewNextNote(reviewDeckNames[0]);
    } else {
      const deckSelectionModal = new ReviewDeckSelectionModal(this.app, reviewDeckNames);
      deckSelectionModal.submitCallback = (deckKey) => this.reviewNextNote(deckKey);
      deckSelectionModal.open();
    }
  }
  async reviewNextNote(deckKey) {
    if (!this._noteReviewQueue.reviewDeckNameList.contains(deckKey)) {
      new import_obsidian14.Notice(t("NO_DECK_EXISTS", { deckName: deckKey }));
      return;
    }
    this._lastSelectedReviewDeck = deckKey;
    const deck = this._noteReviewQueue.reviewDecks.get(deckKey);
    const notefile = deck.determineNextNote(this.settings.openRandomNote);
    if (notefile) {
      await this.openNote(deckKey, notefile.tfile);
    } else {
      new import_obsidian14.Notice(t("ALL_CAUGHT_UP"));
    }
  }
  async openNote(deckName, file) {
    this._lastSelectedReviewDeck = deckName;
    await this.app.workspace.getLeaf().openFile(file);
  }
};

// src/note-review-deck.ts
var SchedNote = class {
  constructor(note, dueUnix) {
    this.note = note;
    this.dueUnix = dueUnix;
  }
  isDue(todayUnix) {
    return this.dueUnix <= todayUnix;
  }
};
var NoteReviewDeck = class {
  constructor(name) {
    this._newNotes = [];
    this._scheduledNotes = [];
    this._dueNotesCount = 0;
    this._deckName = name;
    this._activeFolders = /* @__PURE__ */ new Set([this._deckName, t("TODAY")]);
  }
  get deckName() {
    return this._deckName;
  }
  get newNotes() {
    return this._newNotes;
  }
  get scheduledNotes() {
    return this._scheduledNotes;
  }
  get dueNotesCount() {
    return this._dueNotesCount;
  }
  get activeFolders() {
    return this._activeFolders;
  }
  calcDueNotesCount(todayUnix) {
    this._dueNotesCount = 0;
    this.scheduledNotes.forEach((scheduledNote) => {
      if (scheduledNote.isDue(todayUnix)) {
        this._dueNotesCount++;
      }
    });
  }
  sortNotesByDateAndImportance(pageranks) {
    this._newNotes = this.newNotes.sort(
      (a2, b2) => (pageranks[b2.path] || 0) - (pageranks[a2.path] || 0)
    );
    this._scheduledNotes = this.scheduledNotes.sort((a2, b2) => {
      const result = a2.dueUnix - b2.dueUnix;
      if (result != 0) {
        return result;
      }
      return (pageranks[b2.note.path] || 0) - (pageranks[a2.note.path] || 0);
    });
  }
  determineNextNote(openRandomNote) {
    const todayUnix = globalDateProvider.today.valueOf();
    const dueNotes = this.scheduledNotes.filter((note) => note.isDue(todayUnix));
    if (dueNotes.length > 0) {
      const index = openRandomNote ? globalRandomNumberProvider.getInteger(0, dueNotes.length - 1) : 0;
      return dueNotes[index].note;
    }
    if (this.newNotes.length > 0) {
      const index = openRandomNote ? globalRandomNumberProvider.getInteger(0, this.newNotes.length - 1) : 0;
      return this.newNotes[index];
    }
    return null;
  }
};

// src/note-review-queue.ts
var NoteReviewQueue = class {
  get reviewDecks() {
    return this._reviewDecks;
  }
  get dueNotesCount() {
    return this._dueNotesCount;
  }
  get reviewDeckNameList() {
    return [...this._reviewDecks.keys()];
  }
  init() {
    this._reviewDecks = /* @__PURE__ */ new Map();
  }
  calcDueNotesCount(todayUnix) {
    this._dueNotesCount = 0;
    this._reviewDecks.forEach((reviewDeck) => {
      reviewDeck.calcDueNotesCount(todayUnix);
      this._dueNotesCount += reviewDeck.dueNotesCount;
    });
  }
  addNoteToQueue(noteFile, noteSchedule, matchedNoteTags) {
    for (const matchedNoteTag of matchedNoteTags) {
      if (!this.reviewDecks.has(matchedNoteTag)) {
        this.reviewDecks.set(matchedNoteTag, new NoteReviewDeck(matchedNoteTag));
      }
    }
    if (noteSchedule == null) {
      for (const matchedNoteTag of matchedNoteTags) {
        this.reviewDecks.get(matchedNoteTag).newNotes.push(noteFile);
      }
    } else {
      for (const matchedNoteTag of matchedNoteTags) {
        this.reviewDecks.get(matchedNoteTag).scheduledNotes.push(new SchedNote(noteFile, noteSchedule.dueDateAsUnix));
      }
    }
  }
  updateScheduleInfo(note, scheduleInfo) {
    this.reviewDecks.forEach((reviewDeck) => {
      let wasDueInDeck = false;
      for (const scheduledNote of reviewDeck.scheduledNotes) {
        if (scheduledNote.note.path === note.path) {
          scheduledNote.dueUnix = scheduleInfo.dueDate.valueOf();
          wasDueInDeck = true;
          break;
        }
      }
      if (!wasDueInDeck) {
        reviewDeck.newNotes.splice(
          reviewDeck.newNotes.findIndex((newNote) => newNote.path === note.path),
          1
        );
        reviewDeck.scheduledNotes.push(new SchedNote(note, scheduleInfo.dueDate.valueOf()));
      }
    });
  }
};

// src/plugin-data.ts
var DEFAULT_DATA = {
  settings: DEFAULT_SETTINGS,
  buryDate: "",
  buryList: [],
  historyDeck: null
};

// src/question-postponement-list.ts
var QuestionPostponementList = class {
  constructor(plugin, settings, list) {
    this.plugin = plugin;
    this.settings = settings;
    this.list = list;
  }
  async clearIfNewDay(data) {
    const now2 = window.moment(Date.now());
    const todayDate = now2.format("YYYY-MM-DD");
    const isNewDay = todayDate !== data.buryDate;
    if (isNewDay) {
      data.buryDate = todayDate;
      this.clear();
      await this.write();
    }
  }
  clear() {
    this.list.splice(0);
  }
  add(question) {
    if (!this.includes(question)) this.list.push(question.questionText.textHash);
  }
  includes(question) {
    return this.list.includes(question.questionText.textHash);
  }
  async write() {
    if (this.plugin == null) return;
    await this.plugin.savePluginData();
  }
};

// src/main.ts
var SRPlugin = class _SRPlugin extends import_obsidian15.Plugin {
  constructor() {
    super(...arguments);
    this.ribbonIcon = null;
    this.statusBar = null;
    this.isSRInFocus = false;
  }
  async onload() {
    this.tabViewManager = new TabViewManager(this);
    this.app.workspace.onLayoutReady(async () => {
      this.tabViewManager.closeAllTabViews();
    });
    await this.loadPluginData();
    const noteReviewQueue = new NoteReviewQueue();
    this.nextNoteReviewHandler = new NextNoteReviewHandler(
      this.app,
      this.data.settings,
      noteReviewQueue
    );
    this.osrSidebar = new OsrSidebar(this, this.data.settings, this.nextNoteReviewHandler);
    this.osrSidebar.init();
    this.app.workspace.onLayoutReady(async () => {
      await this.osrSidebar.activateReviewQueueViewPanel();
      setTimeout(async () => {
        if (!this.osrAppCore.syncLock) {
          await this.sync();
        }
      }, 2e3);
    });
    const questionPostponementList = new QuestionPostponementList(
      this,
      this.data.settings,
      this.data.buryList
    );
    const osrNoteLinkInfoFinder = new ObsidianVaultNoteLinkInfoFinder(this.app.metadataCache);
    this.osrAppCore = new OsrAppCore(this.app);
    this.osrAppCore.init(
      questionPostponementList,
      osrNoteLinkInfoFinder,
      this.data.settings,
      this.onOsrVaultDataChanged.bind(this),
      noteReviewQueue
    );
    appIcon();
    this.showStatusBar(this.data.settings.showStatusBar);
    this.showRibbonIcon(this.data.settings.showRibbonIcon);
    this.showFileMenuItems(!this.data.settings.disableFileMenuReviewOptions);
    this.addPluginCommands();
    this.addSettingTab(new SRSettingTab(this.app, this));
    this.registerSRFocusListener();
  }
  showFileMenuItems(status) {
    if (this.fileMenuHandler === void 0) {
      this.fileMenuHandler = (menu, fileish) => {
        if (fileish instanceof import_obsidian15.TFile && fileish.extension === "md") {
          menu.addItem((item) => {
            item.setTitle(
              t("REVIEW_DIFFICULTY_FILE_MENU", {
                difficulty: this.data.settings.flashcardEasyText
              })
            ).setIcon("SpacedRepIcon").onClick(() => {
              this.saveNoteReviewResponse(fileish, 0 /* Easy */);
            });
          });
          menu.addItem((item) => {
            item.setTitle(
              t("REVIEW_DIFFICULTY_FILE_MENU", {
                difficulty: this.data.settings.flashcardGoodText
              })
            ).setIcon("SpacedRepIcon").onClick(() => {
              this.saveNoteReviewResponse(fileish, 1 /* Good */);
            });
          });
          menu.addItem((item) => {
            item.setTitle(
              t("REVIEW_DIFFICULTY_FILE_MENU", {
                difficulty: this.data.settings.flashcardHardText
              })
            ).setIcon("SpacedRepIcon").onClick(() => {
              this.saveNoteReviewResponse(fileish, 2 /* Hard */);
            });
          });
        }
      };
    }
    if (status) {
      this.registerEvent(this.app.workspace.on("file-menu", this.fileMenuHandler));
    } else {
      this.app.workspace.off("file-menu", this.fileMenuHandler);
    }
  }
  addPluginCommands() {
    this.addCommand({
      id: "srs-note-review-open-note",
      name: t("OPEN_NOTE_FOR_REVIEW"),
      callback: async () => {
        if (!this.osrAppCore.syncLock) {
          await this.sync();
          this.nextNoteReviewHandler.reviewNextNoteModal();
        }
      }
    });
    this.addCommand({
      id: "srs-note-review-easy",
      name: t("REVIEW_NOTE_DIFFICULTY_CMD", {
        difficulty: this.data.settings.flashcardEasyText
      }),
      callback: () => {
        const openFile = this.app.workspace.getActiveFile();
        if (openFile && openFile.extension === "md") {
          this.saveNoteReviewResponse(openFile, 0 /* Easy */);
        }
      }
    });
    this.addCommand({
      id: "srs-note-review-good",
      name: t("REVIEW_NOTE_DIFFICULTY_CMD", {
        difficulty: this.data.settings.flashcardGoodText
      }),
      callback: () => {
        const openFile = this.app.workspace.getActiveFile();
        if (openFile && openFile.extension === "md") {
          this.saveNoteReviewResponse(openFile, 1 /* Good */);
        }
      }
    });
    this.addCommand({
      id: "srs-note-review-hard",
      name: t("REVIEW_NOTE_DIFFICULTY_CMD", {
        difficulty: this.data.settings.flashcardHardText
      }),
      callback: () => {
        const openFile = this.app.workspace.getActiveFile();
        if (openFile && openFile.extension === "md") {
          this.saveNoteReviewResponse(openFile, 2 /* Hard */);
        }
      }
    });
    this.addCommand({
      id: "srs-review-flashcards",
      name: t("REVIEW_ALL_CARDS"),
      callback: async () => {
        if (this.osrAppCore.syncLock) {
          return;
        }
        await this.sync();
        if (this.data.settings.openViewInNewTab) {
          this.tabViewManager.openSRTabView(this.osrAppCore, 1 /* Review */);
        } else {
          this.openFlashcardModal(
            this.osrAppCore.reviewableDeckTree,
            this.osrAppCore.remainingDeckTree,
            1 /* Review */
          );
        }
      }
    });
    this.addCommand({
      id: "srs-cram-flashcards",
      name: t("CRAM_ALL_CARDS"),
      callback: async () => {
        await this.sync();
        if (this.data.settings.openViewInNewTab) {
          this.tabViewManager.openSRTabView(this.osrAppCore, 0 /* Cram */);
        } else {
          this.openFlashcardModal(
            this.osrAppCore.reviewableDeckTree,
            this.osrAppCore.reviewableDeckTree,
            0 /* Cram */
          );
        }
      }
    });
    this.addCommand({
      id: "srs-review-flashcards-in-note",
      name: t("REVIEW_CARDS_IN_NOTE"),
      callback: async () => {
        const openFile = this.app.workspace.getActiveFile();
        if (!openFile || openFile.extension !== "md") {
          return;
        }
        if (this.data.settings.openViewInNewTab) {
          this.tabViewManager.openSRTabView(
            this.osrAppCore,
            1 /* Review */,
            openFile
          );
        } else {
          this.openFlashcardModalForSingleNote(openFile, 1 /* Review */);
        }
      }
    });
    this.addCommand({
      id: "srs-cram-flashcards-in-note",
      name: t("CRAM_CARDS_IN_NOTE"),
      callback: async () => {
        const openFile = this.app.workspace.getActiveFile();
        if (!openFile || openFile.extension !== "md") {
          return;
        }
        if (this.data.settings.openViewInNewTab) {
          this.tabViewManager.openSRTabView(
            this.osrAppCore,
            0 /* Cram */,
            openFile
          );
        } else {
          this.openFlashcardModalForSingleNote(openFile, 0 /* Cram */);
        }
      }
    });
    this.addCommand({
      id: "srs-open-review-queue-view",
      name: t("OPEN_REVIEW_QUEUE_VIEW"),
      callback: async () => {
        await this.osrSidebar.openReviewQueueView();
      }
    });
  }
  onunload() {
    this.app.workspace.getLeavesOfType(REVIEW_QUEUE_VIEW_TYPE).forEach((leaf) => leaf.detach());
    this.tabViewManager.closeAllTabViews();
  }
  getPreparedReviewSequencer(fullDeckTree, remainingDeckTree, reviewMode) {
    const deckIterator = _SRPlugin.createDeckTreeIterator(this.data.settings);
    const reviewSequencer = new FlashcardReviewSequencer(
      reviewMode,
      deckIterator,
      this.data.settings,
      SrsAlgorithm.getInstance(),
      this.osrAppCore.questionPostponementList,
      this.osrAppCore.dueDateFlashcardHistogram
    );
    reviewSequencer.setDeckTree(fullDeckTree, remainingDeckTree);
    return { reviewSequencer, mode: reviewMode };
  }
  async getPreparedDecksForSingleNoteReview(file, mode) {
    const note = await this.loadNote(file);
    const deckTree = new Deck2("root", null);
    note.appendCardsToDeck(deckTree);
    const remainingDeckTree = DeckTreeFilter.filterForRemainingCards(
      this.osrAppCore.questionPostponementList,
      deckTree,
      mode
    );
    return { deckTree, remainingDeckTree, mode };
  }
  registerSRFocusListener() {
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", this.handleFocusChange.bind(this))
    );
  }
  removeSRFocusListener() {
    this.setSRViewInFocus(false);
    this.app.workspace.off("active-leaf-change", this.handleFocusChange.bind(this));
  }
  handleFocusChange(leaf) {
    this.setSRViewInFocus(leaf !== null && leaf.view instanceof SRTabView);
  }
  setSRViewInFocus(value) {
    this.isSRInFocus = value;
  }
  getSRInFocusState() {
    return this.isSRInFocus;
  }
  async openFlashcardModalForSingleNote(noteFile, reviewMode) {
    const singleNoteDeckData = await this.getPreparedDecksForSingleNoteReview(
      noteFile,
      reviewMode
    );
    this.openFlashcardModal(
      singleNoteDeckData.deckTree,
      singleNoteDeckData.remainingDeckTree,
      reviewMode
    );
  }
  openFlashcardModal(fullDeckTree, remainingDeckTree, reviewMode) {
    const reviewSequencerData = this.getPreparedReviewSequencer(
      fullDeckTree,
      remainingDeckTree,
      reviewMode
    );
    this.setSRViewInFocus(true);
    new FlashcardModal(
      this.app,
      this,
      this.data.settings,
      reviewSequencerData.reviewSequencer,
      reviewSequencerData.mode
    ).open();
  }
  static createDeckTreeIterator(settings) {
    let cardOrder = CardOrder[settings.flashcardCardOrder];
    if (cardOrder === void 0) cardOrder = 2 /* DueFirstSequential */;
    let deckOrder = DeckOrder[settings.flashcardDeckOrder];
    if (deckOrder === void 0) deckOrder = 0 /* PrevDeckComplete_Sequential */;
    const iteratorOrder = {
      deckOrder,
      cardOrder
    };
    return new DeckTreeIterator(iteratorOrder, null);
  }
  async sync() {
    if (this.osrAppCore.syncLock) {
      return;
    }
    const now2 = window.moment(Date.now());
    this.osrAppCore.defaultTextDirection = this.getObsidianRtlSetting();
    await this.osrAppCore.loadVault();
    if (this.data.settings.showSchedulingDebugMessages) {
      console.log(`SR: ${t("DECKS")}`, this.osrAppCore.reviewableDeckTree);
      console.log(
        "SR: " + t("SYNC_TIME_TAKEN", {
          t: Date.now() - now2.valueOf()
        })
      );
    }
  }
  onOsrVaultDataChanged() {
    this.statusBar.setText(
      t("STATUS_BAR", {
        dueNotesCount: this.osrAppCore.noteReviewQueue.dueNotesCount,
        dueFlashcardsCount: this.osrAppCore.remainingDeckTree.getCardCount(
          2 /* All */,
          true
        )
      })
    );
    if (this.data.settings.enableNoteReviewPaneOnStartup) this.osrSidebar.redraw();
  }
  async loadNote(noteFile) {
    const loader = new NoteFileLoader(this.data.settings);
    const srFile = this.createSrTFile(noteFile);
    const folderTopicPath = TopicPath.getFolderPathFromFilename(
      srFile,
      this.data.settings
    );
    const note = await loader.load(
      this.createSrTFile(noteFile),
      this.getObsidianRtlSetting(),
      folderTopicPath
    );
    if (note.hasChanged) {
      note.writeNoteFile(this.data.settings);
    }
    return note;
  }
  getObsidianRtlSetting() {
    const v2 = this.app.vault.getConfig("rightToLeft");
    return convertToStringOrEmpty(v2) == "true" ? 2 /* Rtl */ : 1 /* Ltr */;
  }
  async saveNoteReviewResponse(note, response) {
    const noteSrTFile = this.createSrTFile(note);
    if (SettingsUtil.isPathInNoteIgnoreFolder(this.data.settings, note.path)) {
      new import_obsidian15.Notice(t("NOTE_IN_IGNORED_FOLDER"));
      return;
    }
    const tags = noteSrTFile.getAllTagsFromCache();
    if (!SettingsUtil.isAnyTagANoteReviewTag(this.data.settings, tags)) {
      new import_obsidian15.Notice(t("PLEASE_TAG_NOTE"));
      return;
    }
    await this.osrAppCore.saveNoteReviewResponse(noteSrTFile, response, this.data.settings);
    new import_obsidian15.Notice(t("RESPONSE_RECEIVED"));
    if (this.data.settings.autoNextNote) {
      this.nextNoteReviewHandler.autoReviewNextNote();
    }
  }
  createSrTFile(note) {
    return new SrTFile(this.app.vault, this.app.metadataCache, note);
  }
  async loadPluginData() {
    const loadedData = await this.loadData();
    if (loadedData == null ? void 0 : loadedData.settings) upgradeSettings(loadedData.settings);
    this.data = Object.assign({}, DEFAULT_DATA, loadedData);
    this.data.settings = Object.assign({}, DEFAULT_SETTINGS, this.data.settings);
    setDebugParser(this.data.settings.showParserDebugMessages);
    this.setupDataStoreAndAlgorithmInstances(this.data.settings);
  }
  setupDataStoreAndAlgorithmInstances(settings) {
    DataStore.instance = new StoreInNotes(settings);
    SrsAlgorithm.instance = new SrsAlgorithmOsr(settings);
    DataStoreAlgorithm.instance = new DataStoreInNoteAlgorithmOsr(settings);
  }
  async savePluginData() {
    await this.saveData(this.data);
  }
  showRibbonIcon(status) {
    if (!this.ribbonIcon) {
      this.ribbonIcon = this.addRibbonIcon("SpacedRepIcon", t("REVIEW_CARDS"), async () => {
        if (!this.osrAppCore.syncLock) {
          await this.sync();
          this.openFlashcardModal(
            this.osrAppCore.reviewableDeckTree,
            this.osrAppCore.remainingDeckTree,
            1 /* Review */
          );
        }
      });
    }
    if (status) {
      this.ribbonIcon.style.display = "";
    } else {
      this.ribbonIcon.style.display = "none";
    }
  }
  showStatusBar(status) {
    if (!this.statusBar) {
      this.statusBar = this.addStatusBarItem();
      this.statusBar.classList.add("mod-clickable");
      this.statusBar.setAttribute("aria-label", t("OPEN_NOTE_FOR_REVIEW"));
      this.statusBar.setAttribute("aria-label-position", "top");
      this.statusBar.addEventListener("click", async () => {
        if (!this.osrAppCore.syncLock) {
          await this.sync();
          this.nextNoteReviewHandler.reviewNextNoteModal();
        }
      });
    }
    if (status) {
      this.statusBar.style.display = "";
    } else {
      this.statusBar.style.display = "none";
    }
  }
};
/*! Bundled license information:

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.30.1 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)

@kurkle/color/dist/color.esm.js:
  (*!
   * @kurkle/color v0.3.4
   * https://github.com/kurkle/color#readme
   * (c) 2024 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.segment.js:
  (*!
   * Chart.js v4.4.8
   * https://www.chartjs.org
   * (c) 2025 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chart.js:
  (*!
   * Chart.js v4.4.8
   * https://www.chartjs.org
   * (c) 2025 Chart.js Contributors
   * Released under the MIT License
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21vbWVudEAyLjMwLjEvbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3BhZ2VyYW5rLmpzQDEuMC4yL25vZGVfbW9kdWxlcy9wYWdlcmFuay5qcy9saWIvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JhbGFuY2VkLW1hdGNoQDEuMC4yL25vZGVfbW9kdWxlcy9iYWxhbmNlZC1tYXRjaC9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vYnJhY2UtZXhwYW5zaW9uQDIuMC4xL25vZGVfbW9kdWxlcy9icmFjZS1leHBhbnNpb24vaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nsb3plY3JhZnRAMC40LjAvbm9kZV9tb2R1bGVzL2Nsb3plY3JhZnQvZGlzdC9pbXBsZW1lbnRhdGlvbi91dGlscy5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2xvemVjcmFmdEAwLjQuMC9ub2RlX21vZHVsZXMvY2xvemVjcmFmdC9kaXN0L2ltcGxlbWVudGF0aW9uL0Nsb3plRmllbGRFbnVtLmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jbG96ZWNyYWZ0QDAuNC4wL25vZGVfbW9kdWxlcy9jbG96ZWNyYWZ0L2Rpc3QvaW1wbGVtZW50YXRpb24vQ2xvemVSZWdFeHAuanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nsb3plY3JhZnRAMC40LjAvbm9kZV9tb2R1bGVzL2Nsb3plY3JhZnQvZGlzdC9pbXBsZW1lbnRhdGlvbi9DbG96ZU5vdGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nsb3plY3JhZnRAMC40LjAvbm9kZV9tb2R1bGVzL2Nsb3plY3JhZnQvZGlzdC9pbXBsZW1lbnRhdGlvbi9DbG96ZU5vdGVDbGFzc2ljLmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jbG96ZWNyYWZ0QDAuNC4wL25vZGVfbW9kdWxlcy9jbG96ZWNyYWZ0L2Rpc3QvaW1wbGVtZW50YXRpb24vQ2xvemVOb3RlT0wuanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nsb3plY3JhZnRAMC40LjAvbm9kZV9tb2R1bGVzL2Nsb3plY3JhZnQvZGlzdC9pbXBsZW1lbnRhdGlvbi9DbG96ZU5vdGVTaW1wbGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nsb3plY3JhZnRAMC40LjAvbm9kZV9tb2R1bGVzL2Nsb3plY3JhZnQvZGlzdC9pbXBsZW1lbnRhdGlvbi9DbG96ZVR5cGVFbnVtLmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jbG96ZWNyYWZ0QDAuNC4wL25vZGVfbW9kdWxlcy9jbG96ZWNyYWZ0L2Rpc3QvaW1wbGVtZW50YXRpb24vQ2xvemVQYXR0ZXJuLmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jbG96ZWNyYWZ0QDAuNC4wL25vZGVfbW9kdWxlcy9jbG96ZWNyYWZ0L2Rpc3QvaW1wbGVtZW50YXRpb24vQ2xvemVDcmFmdGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jbG96ZWNyYWZ0QDAuNC4wL25vZGVfbW9kdWxlcy9jbG96ZWNyYWZ0L2Rpc3QvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3ZodG1sQDIuMi4wL25vZGVfbW9kdWxlcy92aHRtbC9zcmMvZW1wdHktdGFncy5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vdmh0bWxAMi4yLjAvbm9kZV9tb2R1bGVzL3ZodG1sL3NyYy92aHRtbC5qcyIsICIuLi9zcmMvbWFpbi50cyIsICIuLi9zcmMvYWxnb3JpdGhtcy9iYXNlL3JlcGV0aXRpb24taXRlbS50cyIsICIuLi9zcmMvYWxnb3JpdGhtcy9iYXNlL3Nycy1hbGdvcml0aG0udHMiLCAiLi4vc3JjL2FsZ29yaXRobXMvb3NyL29ic2lkaWFuLXZhdWx0LW5vdGVsaW5rLWluZm8tZmluZGVyLnRzIiwgIi4uL3NyYy9hbGdvcml0aG1zL29zci9zcnMtYWxnb3JpdGhtLW9zci50cyIsICIuLi9zcmMvY29uc3RhbnRzLnRzIiwgIi4uL3NyYy9sYW5nL2hlbHBlcnMudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2FmLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9hci50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvYm4udHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2N6LnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9kYS50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvZGUudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2VuLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9lbi1nYi50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvZXMudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2ZyLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9oaS50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvaWQudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL2l0LnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9qYS50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUva28udHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL21yLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9ubC50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvbm8udHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3BsLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9wdC50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvcHQtYnIudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3JvLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS9ydS50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvc3cudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3RhLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS90ZS50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvdGgudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3RyLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS91ay50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvdXIudHMiLCAiLi4vc3JjL2xhbmcvbG9jYWxlL3ZpLnRzIiwgIi4uL3NyYy9sYW5nL2xvY2FsZS96aC1jbi50cyIsICIuLi9zcmMvbGFuZy9sb2NhbGUvemgtdHcudHMiLCAiLi4vc3JjL2FsZ29yaXRobXMvb3NyL25vdGUtc2NoZWR1bGluZy50cyIsICIuLi9zcmMvdXRpbHMvZGF0ZXMudHMiLCAiLi4vc3JjL2FsZ29yaXRobXMvYmFzZS9yZXAtaXRlbS1zY2hlZHVsZS1pbmZvLnRzIiwgIi4uL3NyYy9hbGdvcml0aG1zL29zci9yZXAtaXRlbS1zY2hlZHVsZS1pbmZvLW9zci50cyIsICIuLi9zcmMvbm90ZS1lYXNlLWxpc3QudHMiLCAiLi4vc3JjL2FsZ29yaXRobXMvb3NyL29zci1ub3RlLWdyYXBoLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9taW5pbWF0Y2hAMTAuMC4xL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvc3JjL2luZGV4LnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9taW5pbWF0Y2hAMTAuMC4xL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvc3JjL2Fzc2VydC12YWxpZC1wYXR0ZXJuLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9taW5pbWF0Y2hAMTAuMC4xL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvc3JjL2JyYWNlLWV4cHJlc3Npb25zLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9taW5pbWF0Y2hAMTAuMC4xL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvc3JjL3VuZXNjYXBlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9taW5pbWF0Y2hAMTAuMC4xL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvc3JjL2FzdC50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vbWluaW1hdGNoQDEwLjAuMS9ub2RlX21vZHVsZXMvbWluaW1hdGNoL3NyYy9lc2NhcGUudHMiLCAiLi4vc3JjL3V0aWxzL2ZzLnRzIiwgIi4uL3NyYy9kYXRhLXN0b3JlLWFsZ29yaXRobS9kYXRhLXN0b3JlLWFsZ29yaXRobS50cyIsICIuLi9zcmMvZGF0YS1zdG9yZXMvYmFzZS9kYXRhLXN0b3JlLnRzIiwgIi4uL3NyYy90b3BpYy1wYXRoLnRzIiwgIi4uL3NyYy9mbGFzaGNhcmQtcmV2aWV3LXNlcXVlbmNlci50cyIsICIuLi9zcmMvZGVjay50cyIsICIuLi9zcmMvdXRpbHMvdHlwZXMudHMiLCAiLi4vc3JjL3V0aWxzL251bWJlcnMudHMiLCAiLi4vc3JjL2RlY2stdHJlZS1pdGVyYXRvci50cyIsICIuLi9zcmMvc3RhdHMudHMiLCAiLi4vc3JjL2RlY2stdHJlZS1zdGF0cy1jYWxjdWxhdG9yLnRzIiwgIi4uL3NyYy9kdWUtZGF0ZS1oaXN0b2dyYW0udHMiLCAiLi4vc3JjL2ZpbGUudHMiLCAiLi4vc3JjL3V0aWxzL3N0cmluZ3MudHMiLCAiLi4vc3JjL25vdGUudHMiLCAiLi4vc3JjL2NhcmQudHMiLCAiLi4vc3JjL3BhcnNlci50cyIsICIuLi9zcmMvcXVlc3Rpb24udHMiLCAiLi4vc3JjL3F1ZXN0aW9uLXR5cGUudHMiLCAiLi4vc3JjL3NldHRpbmdzLnRzIiwgIi4uL3NyYy9ub3RlLXF1ZXN0aW9uLXBhcnNlci50cyIsICIuLi9zcmMvbm90ZS1maWxlLWxvYWRlci50cyIsICIuLi9zcmMvY29yZS50cyIsICIuLi9zcmMvZGF0YS1zdG9yZS1hbGdvcml0aG0vZGF0YS1zdG9yZS1pbi1ub3RlLWFsZ29yaXRobS1vc3IudHMiLCAiLi4vc3JjL2RhdGEtc3RvcmVzL25vdGVzL25vdGVzLnRzIiwgIi4uL3NyYy9ndWkvcmV2aWV3LXF1ZXVlLWxpc3Qtdmlldy50c3giLCAiLi4vc3JjL2d1aS9zZXR0aW5ncy50c3giLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BrdXJrbGUrY29sb3JAMC4zLjQvbm9kZV9tb2R1bGVzL0BrdXJrbGUvY29sb3IvZGlzdC9jb2xvci5lc20uanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYXJ0LmpzQDQuNC44L25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNvcmUudHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYXJ0LmpzQDQuNC44L25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLm1hdGgudHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYXJ0LmpzQDQuNC44L25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYXJ0LmpzQDQuNC44L25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmV4dHJhcy50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuZWFzaW5nLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jb2xvci50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYW5pbWF0aW9ucy5kZWZhdWx0cy5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUubGF5b3V0cy5kZWZhdWx0cy5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuaW50bC50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUudGlja3MuanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYXJ0LmpzQDQuNC44L25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnNjYWxlLmRlZmF1bHRzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5kZWZhdWx0cy5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jb25maWcudHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYXJ0LmpzQDQuNC44L25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmN1cnZlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5kb20udHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYXJ0LmpzQDQuNC44L25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmludGVycG9sYXRpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYXJ0LmpzQDQuNC44L25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLnJ0bC50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuc2VnbWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYW5pbWF0b3IuanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYXJ0LmpzQDQuNC44L25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFuaW1hdGlvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYW5pbWF0aW9ucy5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYXJ0LmpzQDQuNC44L25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5iYXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYXJ0LmpzQDQuNC44L25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5idWJibGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYXJ0LmpzQDQuNC44L25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5kb3VnaG51dC5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmxpbmUuanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYXJ0LmpzQDQuNC44L25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5wb2xhckFyZWEuanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYXJ0LmpzQDQuNC44L25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5waWUuanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYXJ0LmpzQDQuNC44L25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5yYWRhci5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnNjYXR0ZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYXJ0LmpzQDQuNC44L25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFkYXB0ZXJzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5pbnRlcmFjdGlvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUubGF5b3V0cy5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbGF0Zm9ybS9wbGF0Zm9ybS5iYXNlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsYXRmb3JtL3BsYXRmb3JtLmJhc2ljLmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsYXRmb3JtL3BsYXRmb3JtLmRvbS5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbGF0Zm9ybS9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuZWxlbWVudC50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuc2NhbGUuYXV0b3NraXAuanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYXJ0LmpzQDQuNC44L25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnNjYWxlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS50eXBlZFJlZ2lzdHJ5LmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5yZWdpc3RyeS5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUucGx1Z2lucy5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuY29uZmlnLmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5jb250cm9sbGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2VsZW1lbnRzL2VsZW1lbnQuYXJjLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2VsZW1lbnRzL2VsZW1lbnQubGluZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9lbGVtZW50cy9lbGVtZW50LnBvaW50LnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2VsZW1lbnRzL2VsZW1lbnQuYmFyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmNvbG9ycy50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5kZWNpbWF0aW9uLmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIuc2VnbWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLmhlbHBlci5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLm9wdGlvbnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYXJ0LmpzQDQuNC44L25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci50YXJnZXQuc3RhY2suanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYXJ0LmpzQDQuNC44L25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL3NpbXBsZUFyYy5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLnRhcmdldC5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLmRyYXdpbmcuanMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NoYXJ0LmpzQDQuNC44L25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmxlZ2VuZC5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi50aXRsZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5zdWJ0aXRsZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi50b29sdGlwLmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5jYXRlZ29yeS5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUubGluZWFyYmFzZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUubGluZWFyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5sb2dhcml0aG1pYy5qcyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vY2hhcnQuanNANC40Ljgvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUucmFkaWFsTGluZWFyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS50aW1lLmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS50aW1lc2VyaWVzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFydC5qc0A0LjQuOC9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2luZGV4LnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdHlwZXMudHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL25vZGVfbW9kdWxlcy9wcmVhY3QvZGlzdC9wcmVhY3QubW9kdWxlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdXRpbC9pZC50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JpZGpzQDYuMi4wL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL2Jhc2UudHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy92aWV3L2h0bWxFbGVtZW50LnRzeCIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JpZGpzQDYuMi4wL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3V0aWwvaHRtbC50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JpZGpzQDYuMi4wL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL2NlbGwudHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9waXBlbGluZS9wcm9jZXNzb3IudHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9yb3cudHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy90YWJ1bGFyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdXRpbC9hcnJheS50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JpZGpzQDYuMi4wL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3V0aWwvZXZlbnRFbWl0dGVyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdXRpbC9kZWVwRXF1YWwudHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9waXBlbGluZS9maWx0ZXIvZ2xvYmFsU2VhcmNoLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvb3BlcmF0b3Ivc2VhcmNoLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdXRpbC9jbGFzc05hbWUudHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9waXBlbGluZS9maWx0ZXIvc2VydmVyR2xvYmFsU2VhcmNoLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9ub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL2Rpc3QvaG9va3MubW9kdWxlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvaG9va3MvdXNlQ29uZmlnLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvaTE4bi9lbl9VUy50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JpZGpzQDYuMi4wL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL2kxOG4vbGFuZ3VhZ2UudHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy92aWV3L3BsdWdpbi9zZWFyY2gvYWN0aW9ucy50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JpZGpzQDYuMi4wL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL2hvb2tzL3VzZVN0b3JlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvaG9va3MvdXNlU2VsZWN0b3IudHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy92aWV3L3BsdWdpbi9zZWFyY2gvc2VhcmNoLnRzeCIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JpZGpzQDYuMi4wL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3V0aWwvZGVib3VuY2UudHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9waXBlbGluZS9saW1pdC9wYWdpbmF0aW9uLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvcGlwZWxpbmUvbGltaXQvc2VydmVyUGFnaW5hdGlvbi50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JpZGpzQDYuMi4wL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3ZpZXcvcGx1Z2luL3BhZ2luYXRpb24udHN4IiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdXRpbC93aWR0aC50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JpZGpzQDYuMi4wL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3ZpZXcvdGFibGUvc2hhZG93LnRzeCIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JpZGpzQDYuMi4wL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3V0aWwvc3RyaW5nLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvcGx1Z2luLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdXRpbC9sb2cudHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9oZWFkZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9zdG9yYWdlL3N0b3JhZ2UudHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9zdG9yYWdlL21lbW9yeS50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JpZGpzQDYuMi4wL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3N0b3JhZ2Uvc2VydmVyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvc3RvcmFnZS9zdG9yYWdlVXRpbHMudHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9waXBlbGluZS9waXBlbGluZS50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JpZGpzQDYuMi4wL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3BpcGVsaW5lL2V4dHJhY3Rvci9zdG9yYWdlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvcGlwZWxpbmUvdHJhbnNmb3JtZXIvYXJyYXlUb1RhYnVsYXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9waXBlbGluZS9pbml0aWF0b3Ivc2VydmVyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvcGlwZWxpbmUvdHJhbnNmb3JtZXIvc3RvcmFnZVJlc3BvbnNlVG9BcnJheS50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JpZGpzQDYuMi4wL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3BpcGVsaW5lL3BpcGVsaW5lVXRpbHMudHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9zdGF0ZS9zdG9yZS50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JpZGpzQDYuMi4wL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL2NvbmZpZy50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JpZGpzQDYuMi4wL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3ZpZXcvdGFibGUvdGQudHN4IiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdmlldy90YWJsZS90ci50c3giLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy92aWV3L3RhYmxlL21lc3NhZ2VSb3cudHN4IiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdmlldy90YWJsZS90Ym9keS50c3giLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9waXBlbGluZS9zb3J0L25hdGl2ZS50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JpZGpzQDYuMi4wL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3ZpZXcvcGx1Z2luL3NvcnQvYWN0aW9ucy50cyIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JpZGpzQDYuMi4wL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3BpcGVsaW5lL3NvcnQvc2VydmVyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdmlldy9wbHVnaW4vc29ydC9zb3J0LnRzeCIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JpZGpzQDYuMi4wL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3V0aWwvdGhyb3R0bGUudHMiLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy92aWV3L3BsdWdpbi9yZXNpemUvcmVzaXplLnRzeCIsICIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JpZGpzQDYuMi4wL25vZGVfbW9kdWxlcy9ncmlkanMvc3JjL3ZpZXcvdGFibGUvdGgudHN4IiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdmlldy90YWJsZS90aGVhZC50c3giLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy91dGlsL3RhYmxlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdmlldy9hY3Rpb25zLnRzIiwgIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmlkanNANi4yLjAvbm9kZV9tb2R1bGVzL2dyaWRqcy9zcmMvdmlldy90YWJsZS90YWJsZS50c3giLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy92aWV3L2hlYWRlckNvbnRhaW5lci50c3giLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy92aWV3L2Zvb3RlckNvbnRhaW5lci50c3giLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy92aWV3L2NvbnRhaW5lci50c3giLCAiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyaWRqc0A2LjIuMC9ub2RlX21vZHVsZXMvZ3JpZGpzL3NyYy9ncmlkLnRzIiwgIi4uL3NyYy9ndWkvc3RhdGlzdGljcy50c3giLCAiLi4vc3JjL2d1aS90YWJzLnRzeCIsICIuLi9zcmMvZ3VpL3NpZGViYXIudHN4IiwgIi4uL3NyYy9ndWkvc3ItbW9kYWwudHN4IiwgIi4uL3NyYy9ndWkvY2FyZC11aS50c3giLCAiLi4vc3JjL3V0aWxzL3JlbmRlcmVycy50cyIsICIuLi9zcmMvZ3VpL2RlY2stdWkudHN4IiwgIi4uL3NyYy9ndWkvZWRpdC1tb2RhbC50c3giLCAiLi4vc3JjL2d1aS9zci10YWItdmlldy50c3giLCAiLi4vc3JjL2d1aS90YWItdmlldy1tYW5hZ2VyLnRzeCIsICIuLi9zcmMvaWNvbnMvYXBwLWljb24udHMiLCAiLi4vc3JjL25leHQtbm90ZS1yZXZpZXctaGFuZGxlci50cyIsICIuLi9zcmMvZ3VpL3Jldmlldy1kZWNrLXNlbGVjdGlvbi1tb2RhbC50c3giLCAiLi4vc3JjL25vdGUtcmV2aWV3LWRlY2sudHMiLCAiLi4vc3JjL25vdGUtcmV2aWV3LXF1ZXVlLnRzIiwgIi4uL3NyYy9wbHVnaW4tZGF0YS50cyIsICIuLi9zcmMvcXVlc3Rpb24tcG9zdHBvbmVtZW50LWxpc3QudHMiXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBLDRFQUFBQSxTQUFBO0FBTUMsS0FBQyxTQUFVLFFBQVEsU0FBUztBQUN6QixhQUFPLFlBQVksWUFBWSxPQUFPQSxZQUFXLGNBQWNBLFFBQU8sVUFBVSxRQUFRLElBQ3hGLE9BQU8sV0FBVyxjQUFjLE9BQU8sTUFBTSxPQUFPLE9BQU8sSUFDM0QsT0FBTyxTQUFTLFFBQVE7QUFBQSxJQUM1QixHQUFFLFNBQU8sV0FBWTtBQUFFO0FBRW5CLFVBQUk7QUFFSixlQUFTLFFBQVE7QUFDYixlQUFPLGFBQWEsTUFBTSxNQUFNLFNBQVM7QUFBQSxNQUM3QztBQUlBLGVBQVMsZ0JBQWdCQyxXQUFVO0FBQy9CLHVCQUFlQTtBQUFBLE1BQ25CO0FBRUEsZUFBU0MsU0FBUSxPQUFPO0FBQ3BCLGVBQ0ksaUJBQWlCLFNBQ2pCLE9BQU8sVUFBVSxTQUFTLEtBQUssS0FBSyxNQUFNO0FBQUEsTUFFbEQ7QUFFQSxlQUFTQyxVQUFTLE9BQU87QUFHckIsZUFDSSxTQUFTLFFBQ1QsT0FBTyxVQUFVLFNBQVMsS0FBSyxLQUFLLE1BQU07QUFBQSxNQUVsRDtBQUVBLGVBQVMsV0FBV0MsSUFBR0MsSUFBRztBQUN0QixlQUFPLE9BQU8sVUFBVSxlQUFlLEtBQUtELElBQUdDLEVBQUM7QUFBQSxNQUNwRDtBQUVBLGVBQVMsY0FBYyxLQUFLO0FBQ3hCLFlBQUksT0FBTyxxQkFBcUI7QUFDNUIsaUJBQU8sT0FBTyxvQkFBb0IsR0FBRyxFQUFFLFdBQVc7QUFBQSxRQUN0RCxPQUFPO0FBQ0gsY0FBSTtBQUNKLGVBQUssS0FBSyxLQUFLO0FBQ1gsZ0JBQUksV0FBVyxLQUFLLENBQUMsR0FBRztBQUNw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Q3BDLE9BQU9JLEVBQUMsS0FBS0MsRUFBQyxNQUFNQyxFQUFDO0FBQzNCO0FBRUEsSUFBTSxNQUFNO0FBQUEsRUFDWCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQ0o7QUFDQSxJQUFNLFVBQVU7QUFBQSxFQUNmLFFBQVE7QUFBQSxFQUNSLGFBQWE7QUFBQSxFQUNiLE1BQU07QUFBQSxFQUNOLFdBQVc7QUFBQSxFQUNYLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLGNBQWM7QUFBQSxFQUNkLElBQUk7QUFBQSxFQUNKLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLFdBQVc7QUFBQSxFQUNYLFFBQVE7QUFBQSxFQUNSLFVBQVU7QUFBQSxFQUNWLFNBQVM7QUFBQSxFQUNULEtBQUs7QUFBQSxFQUNMLGFBQWE7QUFBQSxFQUNiLFNBQVM7QUFBQSxFQUNULFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLEtBQUs7QUFBQSxFQUNMLE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULFVBQVU7QUFBQSxFQUNWLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFVBQVU7QUFBQSxFQUNWLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFVBQVU7QUFBQSxFQUNWLFVBQVU7QUFBQSxFQUNWLFVBQVU7QUFBQSxFQUNWLFVBQVU7QUFBQSxFQUNWLFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULFdBQVc7QUFBQSxFQUNYLEtBQUs7QUFBQSxFQUNMLFFBQVE7QUFBQSxFQUNSLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLFNBQVM7QUFBQSxFQUNULFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFdBQVc7QUFBQSxFQUNYLFNBQVM7QUFBQSxFQUNULFlBQVk7QUFBQSxFQUNaLEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLFdBQVc7QUFBQSxFQUNYLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLFNBQVM7QUFBQSxFQUNULEtBQUs7QUFBQSxFQUNMLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFlBQVk7QUFBQSxFQUNaLEtBQUs7QUFBQSxFQUNMLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE1BQU07QUFBQSxFQUNOLFdBQVc7QUFBQSxFQUNYLEtBQUs7QUFBQSxFQUNMLFVBQVU7QUFBQSxFQUNWLFlBQVk7QUFBQSxFQUNaLFNBQVM7QUFBQSxFQUNULFVBQVU7QUFBQSxFQUNWLFNBQVM7QUFBQSxFQUNULFlBQVk7QUFBQSxFQUNaLE1BQU07QUFBQSxFQUNOLFFBQVE7QUFBQSxFQUNSLE1BQU07QUFBQSxFQUNOLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLFdBQVc7QUFBQSxFQUNYLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFlBQVk7QUFBQSxFQUNaLFdBQVc7QUFBQSxFQUNYLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLGFBQWE7QUFBQSxFQUNiLElBQUk7QUFBQSxFQUNKLFVBQVU7QUFBQSxFQUNWLE9BQU87QUFBQSxFQUNQLFdBQVc7QUFBQSxFQUNYLE9BQU87QUFBQSxFQUNQLFdBQVc7QUFBQSxFQUNYLE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLFVBQVU7QUFBQSxFQUNWLFFBQVE7QUFBQSxFQUNSLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLElBQUk7QUFBQSxFQUNKLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLFdBQVc7QUFBQSxFQUNYLElBQUk7QUFBQSxFQUNKLE9B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SUFDbkMsT0FBTztBQUNILFdBQUssVUFBVSxNQUFNLFVBQVU7QUFBQSxJQUNuQztBQUFBLEVBQ0o7QUFDSjsiLAogICJuYW1lcyI6IFsibW9kdWxlIiwgImNhbGxiYWNrIiwgImlzQXJyYXkiLCAiaXNPYmplY3QiLCAiYSIsICJiIiwgImlzTnVtYmVyIiwgIm1hcCIsICJmbiIsICJpIiwgImZvcm1hdCIsICJsb2NhbGUiLCAibSIsICJ0IiwgInRvIiwgImZyb20iLCAiTW9tZW50IiwgImlzRnVuY3Rpb24iLCAic2V0IiwgIm5vdyIsICJzaWduIiwgInRva2VuIiwgIm9yZGluYWwiLCAiZGlmZiIsICJ1IiwgImxvY2FsZURhdGEiLCAicyIsICJ5IiwgImQiLCAibiIsICJ4IiwgIm8iLCAiaCIsICJNIiwgImhvdXJzIiwgIm1pbnV0ZXMiLCAibmFtZXMiLCAiaiIsICJlIiwgImwiLCAibWF0Y2giLCAiZGVmYXVsdHMiLCAiYyIsICJ3IiwgInRva2VucyIsICJtZXJpZGllbSIsICJ5ZWFycyIsICJtb250aHMiLCAid2Vla3MiLCAiZGF5cyIsICJzZWNvbmRzIiwgIm1pbGxpc2Vjb25kcyIsICJvZmZzZXQiLCAiY2xvbmUiLCAicm91bmQiLCAidGhyZXNob2xkcyIsICJtb2R1bGUiLCAiY2FsbGJhY2siLCAiYWxwaGEiLCAibW9kdWxlIiwgImEiLCAiYiIsICJyIiwgIm0iLCAiaSIsICJtb2R1bGUiLCAibSIsICJwIiwgImV4cGFuZCIsICJpIiwgInkiLCAibiIsICJOIiwgIngiLCAiYyIsICJ6IiwgImoiLCAiQ2xvemVGaWVsZEVudW0iLCAibWF0Y2giLCAibWF0Y2giLCAibWF0Y2giLCAibWF0Y2giLCAiQ2xvemVUeXBlRW51bSIsICJwb3NpdGlvbnMiLCAiYSIsICJiIiwgIngiLCAiQ2xvemVDcmFmdGVyIiwgImVzYyIsICJTdHJpbmciLCAic3RyIiwgInJlcGxhY2UiLCAicyIsICJtYXAiLCAic2V0SW5uZXJIVE1MQXR0ciIsICJET01BdHRyaWJ1dGVOYW1lcyIsICJzYW5pdGl6ZWQiLCAiaCIsICJuYW1lIiwgImF0dHJzIiwgInN0YWNrIiwgImkiLCAiYXJndW1lbnRzIiwgImxlbmd0aCIsICJwdXNoIiwgImNoaWxkcmVuIiwgInJldmVyc2UiLCAiZW1wdHlUYWdzIiwgImluZGV4T2YiLCAiX19odG1sIiwgImNoaWxkIiwgInBvcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAicGF0aCIsICJpbXBvcnRfbW9tZW50IiwgIm5hbWVzIiwgIm0iLCAieSIsICJtb21lbnQiLCAibW9tZW50IiwgInBhdGgiLCAibW9tZW50IiwgInBhdGgiLCAicyIsICJpIiwgImMiLCAidSIsICJyIiwgInMiLCAiYyIsICJzIiwgInAiLCAiaSIsICJfYSIsICJfIiwgInN0YXJ0IiwgImZpbmFsIiwgIm4iLCAiYWNjIiwgImV4dCIsICJfaGFzTWFnaWMiLCAicyIsICJwIiwgImV4dCIsICJmIiwgInFtYXJrIiwgInN0YXIiLCAiYSIsICJiIiwgIm0iLCAicyIsICJleHBhbmQiLCAicmVnRXhwRXNjYXBlIiwgIl8iLCAic2V0IiwgImkiLCAiaiIsICJwMiIsICJwYXRoIiwgInBhdGgiLCAicmFuayIsICJwYXRoIiwgImkiLCAic2VwIiwgInEiLCAiRGVjayIsICJpIiwgInQiLCAiYSIsICJiIiwgInMiLCAidiIsICJhIiwgImIiLCAiaSIsICJ4IiwgIl8iLCAiQ2FyZE9yZGVyIiwgIkRlY2tPcmRlciIsICJEZWNrIiwgImkiLCAiXyIsICJpIiwgImltcG9ydF9vYnNpZGlhbiIsICJoMSIsICJoMiIsICJpIiwgInYiLCAidiIsICJPYnNpZGlhbkdldEFsbFRhZ3MiLCAiaSIsICJxIiwgIm1hdGNoIiwgInNlcCIsICJhIiwgImIiLCAiaSIsICJpbXBvcnRfY2xvemVjcmFmdCIsICJpIiwgImltcG9ydF9vYnNpZGlhbiIsICJwYXRoIiwgInEiLCAiaSIsICJhIiwgImIiLCAiRGVjayIsICJpbXBvcnRfbW9tZW50IiwgIm1vbWVudCIsICJpIiwgIl8iLCAiaSIsICJtYXRjaCIsICJpbXBvcnRfb2JzaWRpYW4iLCAibm93IiwgImltcG9ydF9vYnNpZGlhbiIsICJ2IiwgImwiLCAiaCIsICJ2IiwgImIiLCAiYSIsICJmIiwgImgiLCAicyIsICJsIiwgIm4iLCAidyIsICJpIiwgInIiLCAiZyIsICJkIiwgImMiLCAibSIsICJqIiwgImludGVycG9sYXRlIiwgInQiLCAiY29sb3IiLCAicCIsICJub29wIiwgInVpZCIsICJpZCIsICJpc051bGxPclVuZGVmIiwgInZhbHVlIiwgInVuZGVmaW5lZCIsICJpc0FycmF5IiwgIkFycmF5IiwgInR5cGUiLCAiT2JqZWN0IiwgInByb3RvdHlwZSIsICJ0b1N0cmluZyIsICJjYWxsIiwgInNsaWNlIiwgImlzT2JqZWN0IiwgImlzTnVtYmVyRmluaXRlIiwgIk51bWJlciIsICJpc0Zpbml0ZSIsICJmaW5pdGVPckRlZmF1bHQiLCAiZGVmYXVsdFZhbHVlIiwgInZhbHVlT3JEZWZhdWx0IiwgInRvUGVyY2VudGFnZSIsICJkaW1lbnNpb24iLCAiZW5kc1dpdGgiLCAicGFyc2VGbG9hdCIsICJ0b0RpbWVuc2lvbiIsICJjYWxsYmFjayIsICJmbiIsICJhcmdzIiwgInRoaXNBcmciLCAiYXBwbHkiLCAiZWFjaCIsICJsb29wYWJsZSIsICJyZXZlcnNlIiwgImkiLCAibGVuIiwgImtleXMiLCAibGVuZ3RoIiwgIl9lbGVtZW50c0VxdWFsIiwgImEwIiwgImExIiwgImlsZW4iLCAidjAiLCAidjEiLCAiZGF0YXNldEluZGV4IiwgImluZGV4IiwgImNsb25lIiwgInNvdXJjZSIsICJtYXAiLCAidGFyZ2V0IiwgImNyZWF0ZSIsICJrbGVuIiwgImsiLCAiaXNWYWxpZEtleSIsICJrZXkiLCAiaW5kZXhPZiIsICJfbWVyZ2VyIiwgIm9wdGlvbnMiLCAidHZhbCIsICJzdmFsIiwgIm1lcmdlIiwgInNvdXJjZXMiLCAibWVyZ2VyIiwgImN1cnJlbnQiLCAibWVyZ2VJZiIsICJfbWVyZ2VySWYiLCAiaGFzT3duUHJvcGVydHkiLCAia2V5UmVzb2x2ZXJzIiwgInYiLCAieCIsICJvIiwgInkiLCAiX3NwbGl0S2V5IiwgImtleSIsICJwYXJ0cyIsICJzcGxpdCIsICJrZXlzIiwgInRtcCIsICJwYXJ0IiwgImVuZHNXaXRoIiwgInNsaWNlIiwgInB1c2giLCAiX2dldEtleVJlc29sdmVyIiwgIm9iaiIsICJrIiwgInJlc29sdmVPYmplY3RLZXkiLCAicmVzb2x2ZXIiLCAiX2NhcGl0YWxpemUiLCAic3RyIiwgImNoYXJBdCIsICJ0b1VwcGVyQ2FzZSIsICJkZWZpbmVkIiwgInZhbHVlIiwgImlzRnVuY3Rpb24iLCAic2V0c0VxdWFsIiwgImEiLCAiYiIsICJzaXplIiwgIml0ZW0iLCAiaGFzIiwgIl9pc0NsaWNrRXZlbnQiLCAiZSIsICJ0eXBlIiwgIlBJIiwgIk1hdGgiLCAiVEFVIiwgIlBJVEFVIiwgIklORklOSVRZIiwgIk51bWJlciIsICJQT1NJVElWRV9JTkZJTklUWSIsICJSQURfUEVSX0RFRyIsICJIQUxGX1BJIiwgIlFVQVJURVJfUEkiLCAiVFdPX1RISVJEU19QSSIsICJsb2cxMCIsICJzaWduIiwgImFsbW9zdEVxdWFscyIsICJlcHNpbG9uIiwgImFicyIsICJuaWNlTnVtIiwgInJhbmdlIiwgInJvdW5kZWRSYW5nZSIsICJyb3VuZCIsICJuaWNlUmFuZ2UiLCAicG93IiwgImZsb29yIiwgImZyYWN0aW9uIiwgIm5pY2VGcmFjdGlvbiIsICJfZmFjdG9yaXplIiwgInJlc3VsdCIsICJzcXJ0IiwgImkiLCAic29ydCIsICJwb3AiLCAiaXNOb25QcmltaXRpdmUiLCAibiIsICJTeW1ib2wiLCAidG9QcmltaXRpdmUiLCAiaXNOdW1iZXIiLCAiaXNOYU4iLCAicGFyc2VGbG9hdCIsICJpc0Zpbml0ZSIsICJhbG1vc3RXaG9sZSIsICJyb3VuZGVkIiwgIl9zZXRNaW5BbmRNYXhCeUtleSIsICJhcnJheSIsICJ0YXJnZXQiLCAicHJvcGVydHkiLCAiaWxlbiIsICJsZW5ndGgiLCAibWluIiwgIm1heCIsICJ0b1JhZGlhbnMiLCAiZGVncmVlcyIsICJ0b0RlZ3JlZXMiLCAicmFkaWFucyIsICJfZGVjaW1hbFBsYWNlcyIsICJpc0Zpbml0ZU51bWJlciIsICJwIiwgImdldEFuZ2xlRnJvbVBvaW50IiwgImNlbnRyZVBvaW50IiwgImFuZ2xlUG9pbnQiLCAiZGlzdGFuY2VGcm9tWENlbnRlciIsICJkaXN0YW5jZUZyb21ZQ2VudGVyIiwgInJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciIsICJhbmdsZSIsICJhdGFuMiIsICJkaXN0YW5jZSIsICJkaXN0YW5jZUJldHdlZW5Qb2ludHMiLCAicHQxIiwgInB0MiIsICJfbm9ybWFsaXplQW5nbGUiLCAiYSIsICJUQVUiLCAiX2FuZ2xlQmV0d2VlbiIsICJhbmdsZSIsICJzdGFydCIsICJlbmQiLCAic2FtZUFuZ2xlSXNGdWxsQ2lyY2xlIiwgInMiLCAiZSIsICJhbmdsZVRvU3RhcnQiLCAiYW5nbGVUb0VuZCIsICJzdGFydFRvQW5nbGUiLCAiZW5kVG9BbmdsZSIsICJfbGltaXRWYWx1ZSIsICJ2YWx1ZSIsICJtaW4iLCAibWF4IiwgIk1hdGgiLCAiX2ludDE2UmFuZ2UiLCAiX2lzQmV0d2VlbiIsICJlcHNpbG9uIiwgIl9sb29rdXAiLCAidGFibGUiLCAiY21wIiwgImluZGV4IiwgImhpIiwgImxlbmd0aCIsICJsbyIsICJtaWQiLCAiX2xvb2t1cEJ5S2V5IiwgImtleSIsICJsYXN0IiwgInRpIiwgIl9ybG9va3VwQnlLZXkiLCAiX2ZpbHRlckJldHdlZW4iLCAidmFsdWVzIiwgInNsaWNlIiwgImFycmF5RXZlbnRzIiwgImxpc3RlbkFycmF5RXZlbnRzIiwgImFycmF5IiwgImxpc3RlbmVyIiwgIl9jaGFydGpzIiwgImxpc3RlbmVycyIsICJwdXNoIiwgIk9iamVjdCIsICJkZWZpbmVQcm9wZXJ0eSIsICJjb25maWd1cmFibGUiLCAiZW51bWVyYWJsZSIsICJmb3JFYWNoIiwgIm1ldGhvZCIsICJfY2FwaXRhbGl6ZSIsICJiYXNlIiwgImFyZ3MiLCAicmVzIiwgImFwcGx5IiwgIm9iamVjdCIsICJ1bmxpc3RlbkFycmF5RXZlbnRzIiwgInN0dWIiLCAiaW5kZXhPZiIsICJzcGxpY2UiLCAiX2FycmF5VW5pcXVlIiwgIml0ZW1zIiwgInNldCIsICJTZXQiLCAic2l6ZSIsICJBcnJheSIsICJmcm9tIiwgInJlcXVlc3RBbmltRnJhbWUiLCAid2luZG93IiwgImNhbGxiYWNrIiwgInJlcXVlc3RBbmltYXRpb25GcmFtZSIsICJ0aHJvdHRsZWQiLCAiZm4iLCAidGhpc0FyZyIsICJhcmdzVG9Vc2UiLCAidGlja2luZyIsICJhcmdzIiwgImNhbGwiLCAiYXBwbHkiLCAiZGVib3VuY2UiLCAiZGVsYXkiLCAidGltZW91dCIsICJjbGVhclRpbWVvdXQiLCAic2V0VGltZW91dCIsICJfdG9MZWZ0UmlnaHRDZW50ZXIiLCAiYWxpZ24iLCAiX2FsaWduU3RhcnRFbmQiLCAic3RhcnQiLCAiZW5kIiwgIl90ZXh0WCIsICJsZWZ0IiwgInJpZ2h0IiwgInJ0bCIsICJjaGVjayIsICJhdEVkZ2UiLCAidCIsICJlbGFzdGljSW4iLCAicyIsICJwIiwgIk1hdGgiLCAicG93IiwgInNpbiIsICJUQVUiLCAiZWxhc3RpY091dCIsICJlZmZlY3RzIiwgImxpbmVhciIsICJlYXNlSW5RdWFkIiwgImVhc2VPdXRRdWFkIiwgImVhc2VJbk91dFF1YWQiLCAiZWFzZUluQ3ViaWMiLCAiZWFzZU91dEN1YmljIiwgImVhc2VJbk91dEN1YmljIiwgImVhc2VJblF1YXJ0IiwgImVhc2VPdXRRdWFydCIsICJlYXNlSW5PdXRRdWFydCIsICJlYXNlSW5RdWludCIsICJlYXNlT3V0UXVpbnQiLCAiZWFzZUluT3V0UXVpbnQiLCAiZWFzZUluU2luZSIsICJjb3MiLCAiSEFMRl9QSSIsICJlYXNlT3V0U2luZSIsICJlYXNlSW5PdXRTaW5lIiwgIlBJIiwgImVhc2VJbkV4cG8iLCAiZWFzZU91dEV4cG8iLCAiZWFzZUluT3V0RXhwbyIsICJlYXNlSW5DaXJjIiwgInNxcnQiLCAiZWFzZU91dENpcmMiLCAiZWFzZUluT3V0Q2lyYyIsICJlYXNlSW5FbGFzdGljIiwgImVhc2VPdXRFbGFzdGljIiwgImVhc2VJbk91dEVsYXN0aWMiLCAiZWFzZUluQmFjayIsICJlYXNlT3V0QmFjayIsICJlYXNlSW5PdXRCYWNrIiwgImVhc2VJbkJvdW5jZSIsICJlYXNlT3V0Qm91bmNlIiwgIm0iLCAiZCIsICJlYXNlSW5PdXRCb3VuY2UiLCAiaXNQYXR0ZXJuT3JHcmFkaWVudCIsICJ2YWx1ZSIsICJ0eXBlIiwgInRvU3RyaW5nIiwgImNvbG9yIiwgIkNvbG9yIiwgImdldEhvdmVyQ29sb3IiLCAic2F0dXJhdGUiLCAiZGFya2VuIiwgImhleFN0cmluZyIsICJudW1iZXJzIiwgImNvbG9ycyIsICJhcHBseUFuaW1hdGlvbnNEZWZhdWx0cyIsICJkZWZhdWx0cyIsICJzZXQiLCAiZGVsYXkiLCAidW5kZWZpbmVkIiwgImR1cmF0aW9uIiwgImVhc2luZyIsICJmbiIsICJmcm9tIiwgImxvb3AiLCAidG8iLCAiZGVzY3JpYmUiLCAiX2ZhbGxiYWNrIiwgIl9pbmRleGFibGUiLCAiX3NjcmlwdGFibGUiLCAibmFtZSIsICJwcm9wZXJ0aWVzIiwgImFjdGl2ZSIsICJhbmltYXRpb24iLCAicmVzaXplIiwgInNob3ciLCAiYW5pbWF0aW9ucyIsICJ2aXNpYmxlIiwgImhpZGUiLCAidiIsICJhcHBseUxheW91dHNEZWZhdWx0cyIsICJhdXRvUGFkZGluZyIsICJwYWRkaW5nIiwgInRvcCIsICJyaWdodCIsICJib3R0b20iLCAibGVmdCIsICJpbnRsQ2FjaGUiLCAiTWFwIiwgImdldE51bWJlckZvcm1hdCIsICJsb2NhbGUiLCAib3B0aW9ucyIsICJjYWNoZUtleSIsICJKU09OIiwgInN0cmluZ2lmeSIsICJmb3JtYXR0ZXIiLCAiZ2V0IiwgIkludGwiLCAiTnVtYmVyRm9ybWF0IiwgImZvcm1hdE51bWJlciIsICJudW0iLCAiZm9ybWF0IiwgImZvcm1hdHRlcnMiLCAidmFsdWVzIiwgImlzQXJyYXkiLCAibnVtZXJpYyIsICJ0aWNrVmFsdWUiLCAiaW5kZXgiLCAidGlja3MiLCAiY2hhcnQiLCAibm90YXRpb24iLCAiZGVsdGEiLCAibGVuZ3RoIiwgIm1heFRpY2siLCAibWF4IiwgImFicyIsICJjYWxjdWxhdGVEZWx0YSIsICJsb2dEZWx0YSIsICJsb2cxMCIsICJudW1EZWNpbWFsIiwgImlzTmFOIiwgIm1pbiIsICJmbG9vciIsICJtaW5pbXVtRnJhY3Rpb25EaWdpdHMiLCAibWF4aW11bUZyYWN0aW9uRGlnaXRzIiwgIk9iamVjdCIsICJhc3NpZ24iLCAibG9nYXJpdGhtaWMiLCAicmVtYWluIiwgInNpZ25pZmljYW5kIiwgImluY2x1ZGVzIiwgImNhbGwiLCAiYXBwbHlTY2FsZURlZmF1bHRzIiwgImRpc3BsYXkiLCAib2Zmc2V0IiwgInJldmVyc2UiLCAiYmVnaW5BdFplcm8iLCAiYm91bmRzIiwgImNsaXAiLCAiZ3JhY2UiLCAiZ3JpZCIsICJsaW5lV2lkdGgiLCAiZHJhd09uQ2hhcnRBcmVhIiwgImRyYXdUaWNrcyIsICJ0aWNrTGVuZ3RoIiwgInRpY2tXaWR0aCIsICJfY3R4IiwgInRpY2tDb2xvciIsICJib3JkZXIiLCAiZGFzaCIsICJkYXNoT2Zmc2V0IiwgIndpZHRoIiwgInRpdGxlIiwgInRleHQiLCAibWluUm90YXRpb24iLCAibWF4Um90YXRpb24iLCAibWlycm9yIiwgInRleHRTdHJva2VXaWR0aCIsICJ0ZXh0U3Ryb2tlQ29sb3IiLCAiYXV0b1NraXAiLCAiYXV0b1NraXBQYWRkaW5nIiwgImxhYmVsT2Zmc2V0IiwgImNhbGxiYWNrIiwgIlRpY2tzIiwgIm1pbm9yIiwgIm1ham9yIiwgImFsaWduIiwgImNyb3NzQWxpZ24iLCAic2hvd0xhYmVsQmFja2Ryb3AiLCAiYmFja2Ryb3BDb2xvciIsICJiYWNrZHJvcFBhZGRpbmciLCAicm91dGUiLCAic3RhcnRzV2l0aCIsICJvdmVycmlkZXMiLCAiY3JlYXRlIiwgImRlc2NyaXB0b3JzIiwgImdldFNjb3BlIiwgIm5vZGUiLCAia2V5IiwgImtleXMiLCAic3BsaXQiLCAiaSIsICJuIiwgImsiLCAicm9vdCIsICJzY29wZSIsICJtZXJnZSIsICJEZWZhdWx0cyIsICJjb25zdHJ1Y3RvciIsICJfZGVzY3JpcHRvcnMiLCAiX2FwcGxpZXJzIiwgImJhY2tncm91bmRDb2xvciIsICJib3JkZXJDb2xvciIsICJkYXRhc2V0cyIsICJkZXZpY2VQaXhlbFJhdGlvIiwgImNvbnRleHQiLCAicGxhdGZvcm0iLCAiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsICJlbGVtZW50cyIsICJldmVudHMiLCAiZm9udCIsICJmYW1pbHkiLCAic2l6ZSIsICJzdHlsZSIsICJsaW5lSGVpZ2h0IiwgIndlaWdodCIsICJob3ZlciIsICJob3ZlckJhY2tncm91bmRDb2xvciIsICJjdHgiLCAiaG92ZXJCb3JkZXJDb2xvciIsICJob3ZlckNvbG9yIiwgImluZGV4QXhpcyIsICJpbnRlcmFjdGlvbiIsICJtb2RlIiwgImludGVyc2VjdCIsICJpbmNsdWRlSW52aXNpYmxlIiwgIm1haW50YWluQXNwZWN0UmF0aW8iLCAib25Ib3ZlciIsICJvbkNsaWNrIiwgInBhcnNpbmciLCAicGx1Z2lucyIsICJyZXNwb25zaXZlIiwgInNjYWxlIiwgInNjYWxlcyIsICJzaG93TGluZSIsICJkcmF3QWN0aXZlRWxlbWVudHNPblRvcCIsICJhcHBseSIsICJvdmVycmlkZSIsICJ0YXJnZXRTY29wZSIsICJ0YXJnZXROYW1lIiwgInNjb3BlT2JqZWN0IiwgInRhcmdldFNjb3BlT2JqZWN0IiwgInByaXZhdGVOYW1lIiwgImRlZmluZVByb3BlcnRpZXMiLCAid3JpdGFibGUiLCAiZW51bWVyYWJsZSIsICJsb2NhbCIsICJ0YXJnZXQiLCAiaXNPYmplY3QiLCAidmFsdWVPckRlZmF1bHQiLCAiYXBwbGllcnMiLCAiZm9yRWFjaCIsICJ0b0ZvbnRTdHJpbmciLCAiaXNOdWxsT3JVbmRlZiIsICJfbWVhc3VyZVRleHQiLCAiZGF0YSIsICJnYyIsICJsb25nZXN0IiwgInN0cmluZyIsICJ0ZXh0V2lkdGgiLCAibWVhc3VyZVRleHQiLCAicHVzaCIsICJfbG9uZ2VzdFRleHQiLCAiYXJyYXlPZlRoaW5ncyIsICJjYWNoZSIsICJnYXJiYWdlQ29sbGVjdCIsICJzYXZlIiwgImlsZW4iLCAiaiIsICJqbGVuIiwgInRoaW5nIiwgIm5lc3RlZFRoaW5nIiwgInJlc3RvcmUiLCAiZ2NMZW4iLCAic3BsaWNlIiwgIl9hbGlnblBpeGVsIiwgInBpeGVsIiwgImN1cnJlbnREZXZpY2VQaXhlbFJhdGlvIiwgImhhbGZXaWR0aCIsICJyb3VuZCIsICJjbGVhckNhbnZhcyIsICJjYW52YXMiLCAiZ2V0Q29udGV4dCIsICJyZXNldFRyYW5zZm9ybSIsICJjbGVhclJlY3QiLCAiaGVpZ2h0IiwgImRyYXdQb2ludCIsICJ4IiwgInkiLCAiZHJhd1BvaW50TGVnZW5kIiwgInciLCAieE9mZnNldCIsICJ5T2Zmc2V0IiwgImNvcm5lclJhZGl1cyIsICJ4T2Zmc2V0VyIsICJ5T2Zmc2V0VyIsICJwb2ludFN0eWxlIiwgInJvdGF0aW9uIiwgInJhZGl1cyIsICJyYWQiLCAiUkFEX1BFUl9ERUciLCAidHJhbnNsYXRlIiwgInJvdGF0ZSIsICJkcmF3SW1hZ2UiLCAiYmVnaW5QYXRoIiwgImVsbGlwc2UiLCAiYXJjIiwgImNsb3NlUGF0aCIsICJtb3ZlVG8iLCAiVFdPX1RISVJEU19QSSIsICJsaW5lVG8iLCAiUVVBUlRFUl9QSSIsICJTUVJUMV8yIiwgInJlY3QiLCAiZmlsbCIsICJib3JkZXJXaWR0aCIsICJzdHJva2UiLCAiX2lzUG9pbnRJbkFyZWEiLCAicG9pbnQiLCAiYXJlYSIsICJtYXJnaW4iLCAiY2xpcEFyZWEiLCAidW5jbGlwQXJlYSIsICJzZXRSZW5kZXJPcHRzIiwgImN0eCIsICJvcHRzIiwgInRyYW5zbGF0aW9uIiwgInRyYW5zbGF0ZSIsICJpc051bGxPclVuZGVmIiwgInJvdGF0aW9uIiwgInJvdGF0ZSIsICJjb2xvciIsICJmaWxsU3R5bGUiLCAidGV4dEFsaWduIiwgInRleHRCYXNlbGluZSIsICJkZWNvcmF0ZVRleHQiLCAieCIsICJ5IiwgImxpbmUiLCAic3RyaWtldGhyb3VnaCIsICJ1bmRlcmxpbmUiLCAibWV0cmljcyIsICJtZWFzdXJlVGV4dCIsICJsZWZ0IiwgImFjdHVhbEJvdW5kaW5nQm94TGVmdCIsICJyaWdodCIsICJhY3R1YWxCb3VuZGluZ0JveFJpZ2h0IiwgInRvcCIsICJhY3R1YWxCb3VuZGluZ0JveEFzY2VudCIsICJib3R0b20iLCAiYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50IiwgInlEZWNvcmF0aW9uIiwgInN0cm9rZVN0eWxlIiwgImJlZ2luUGF0aCIsICJsaW5lV2lkdGgiLCAiZGVjb3JhdGlvbldpZHRoIiwgIm1vdmVUbyIsICJsaW5lVG8iLCAic3Ryb2tlIiwgImRyYXdCYWNrZHJvcCIsICJvbGRDb2xvciIsICJmaWxsUmVjdCIsICJ3aWR0aCIsICJoZWlnaHQiLCAicmVuZGVyVGV4dCIsICJ0ZXh0IiwgImZvbnQiLCAibGluZXMiLCAiaXNBcnJheSIsICJzdHJva2VXaWR0aCIsICJzdHJva2VDb2xvciIsICJpIiwgInNhdmUiLCAic3RyaW5nIiwgImxlbmd0aCIsICJiYWNrZHJvcCIsICJzdHJva2VUZXh0IiwgIm1heFdpZHRoIiwgImZpbGxUZXh0IiwgIk51bWJlciIsICJsaW5lSGVpZ2h0IiwgInJlc3RvcmUiLCAiYWRkUm91bmRlZFJlY3RQYXRoIiwgInJlY3QiLCAidyIsICJoIiwgInJhZGl1cyIsICJhcmMiLCAidG9wTGVmdCIsICJQSSIsICJib3R0b21MZWZ0IiwgIkhBTEZfUEkiLCAiYm90dG9tUmlnaHQiLCAidG9wUmlnaHQiLCAiTElORV9IRUlHSFQiLCAiRk9OVF9TVFlMRSIsICJ0b0xpbmVIZWlnaHQiLCAidmFsdWUiLCAic2l6ZSIsICJtYXRjaGVzIiwgIm1hdGNoIiwgIm51bWJlck9yWmVybyIsICJ2IiwgIl9yZWFkVmFsdWVUb1Byb3BzIiwgInByb3BzIiwgInJldCIsICJvYmpQcm9wcyIsICJpc09iamVjdCIsICJrZXlzIiwgIk9iamVjdCIsICJyZWFkIiwgInByb3AiLCAidmFsdWVPckRlZmF1bHQiLCAidG9UUkJMIiwgInRvVFJCTENvcm5lcnMiLCAidG9QYWRkaW5nIiwgIm9iaiIsICJ0b0ZvbnQiLCAib3B0aW9ucyIsICJmYWxsYmFjayIsICJkZWZhdWx0cyIsICJwYXJzZUludCIsICJzdHlsZSIsICJjb25zb2xlIiwgIndhcm4iLCAidW5kZWZpbmVkIiwgImZhbWlseSIsICJ3ZWlnaHQiLCAidG9Gb250U3RyaW5nIiwgInJlc29sdmUiLCAiaW5wdXRzIiwgImNvbnRleHQiLCAiaW5kZXgiLCAiaW5mbyIsICJjYWNoZWFibGUiLCAiaWxlbiIsICJfYWRkR3JhY2UiLCAibWlubWF4IiwgImdyYWNlIiwgImJlZ2luQXRaZXJvIiwgIm1pbiIsICJtYXgiLCAiY2hhbmdlIiwgInRvRGltZW5zaW9uIiwgImtlZXBaZXJvIiwgImFkZCIsICJNYXRoIiwgImFicyIsICJjcmVhdGVDb250ZXh0IiwgInBhcmVudENvbnRleHQiLCAiYXNzaWduIiwgImNyZWF0ZSIsICJfY3JlYXRlUmVzb2x2ZXIiLCAic2NvcGVzIiwgInByZWZpeGVzIiwgInJvb3RTY29wZXMiLCAiZ2V0VGFyZ2V0IiwgImZpbmFsUm9vdFNjb3BlcyIsICJfcmVzb2x2ZSIsICJjYWNoZSIsICJTeW1ib2wiLCAidG9TdHJpbmdUYWciLCAiX2NhY2hlYWJsZSIsICJfc2NvcGVzIiwgIl9yb290U2NvcGVzIiwgIl9mYWxsYmFjayIsICJfZ2V0VGFyZ2V0IiwgIm92ZXJyaWRlIiwgInNjb3BlIiwgIlByb3h5IiwgImRlbGV0ZVByb3BlcnR5IiwgInRhcmdldCIsICJfa2V5cyIsICJnZXQiLCAiX2NhY2hlZCIsICJfcmVzb2x2ZVdpdGhQcmVmaXhlcyIsICJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCAiUmVmbGVjdCIsICJnZXRQcm90b3R5cGVPZiIsICJoYXMiLCAiZ2V0S2V5c0Zyb21BbGxTY29wZXMiLCAiaW5jbHVkZXMiLCAib3duS2V5cyIsICJzZXQiLCAic3RvcmFnZSIsICJfc3RvcmFnZSIsICJfYXR0YWNoQ29udGV4dCIsICJwcm94eSIsICJzdWJQcm94eSIsICJkZXNjcmlwdG9yRGVmYXVsdHMiLCAiX3Byb3h5IiwgIl9jb250ZXh0IiwgIl9zdWJQcm94eSIsICJfc3RhY2siLCAiU2V0IiwgIl9kZXNjcmlwdG9ycyIsICJzZXRDb250ZXh0IiwgInJlY2VpdmVyIiwgIl9yZXNvbHZlV2l0aENvbnRleHQiLCAiYWxsS2V5cyIsICJlbnVtZXJhYmxlIiwgImNvbmZpZ3VyYWJsZSIsICJzY3JpcHRhYmxlIiwgImluZGV4YWJsZSIsICJfc2NyaXB0YWJsZSIsICJfaW5kZXhhYmxlIiwgIl9hbGxLZXlzIiwgImlzU2NyaXB0YWJsZSIsICJpc0Z1bmN0aW9uIiwgImlzSW5kZXhhYmxlIiwgInJlYWRLZXkiLCAicHJlZml4IiwgIm5hbWUiLCAiX2NhcGl0YWxpemUiLCAibmVlZHNTdWJSZXNvbHZlciIsICJjb25zdHJ1Y3RvciIsICJwcm90b3R5cGUiLCAiaGFzT3duUHJvcGVydHkiLCAiY2FsbCIsICJkZXNjcmlwdG9ycyIsICJfcmVzb2x2ZVNjcmlwdGFibGUiLCAiX3Jlc29sdmVBcnJheSIsICJnZXRWYWx1ZSIsICJFcnJvciIsICJBcnJheSIsICJmcm9tIiwgImpvaW4iLCAiZGVsZXRlIiwgImNyZWF0ZVN1YlJlc29sdmVyIiwgImFyciIsICJmaWx0ZXIiLCAicyIsICJpdGVtIiwgInJlc29sdmVyIiwgInB1c2giLCAicmVzb2x2ZUZhbGxiYWNrIiwgImdldFNjb3BlIiwgImtleSIsICJwYXJlbnQiLCAicmVzb2x2ZU9iamVjdEtleSIsICJhZGRTY29wZXMiLCAicGFyZW50U2NvcGVzIiwgInBhcmVudEZhbGxiYWNrIiwgImFsbFNjb3BlcyIsICJhZGRTY29wZXNGcm9tS2V5IiwgInN1YkdldFRhcmdldCIsICJyZXNvbHZlS2V5c0Zyb21BbGxTY29wZXMiLCAiayIsICJzdGFydHNXaXRoIiwgIkVQU0lMT04iLCAiTnVtYmVyIiwgIl9pc0RvbVN1cHBvcnRlZCIsICJ3aW5kb3ciLCAiZG9jdW1lbnQiLCAiX2dldFBhcmVudE5vZGUiLCAiZG9tTm9kZSIsICJwYXJlbnQiLCAicGFyZW50Tm9kZSIsICJ0b1N0cmluZyIsICJob3N0IiwgInBhcnNlTWF4U3R5bGUiLCAic3R5bGVWYWx1ZSIsICJub2RlIiwgInBhcmVudFByb3BlcnR5IiwgInZhbHVlSW5QaXhlbHMiLCAicGFyc2VJbnQiLCAiaW5kZXhPZiIsICJnZXRDb21wdXRlZFN0eWxlIiwgImVsZW1lbnQiLCAib3duZXJEb2N1bWVudCIsICJkZWZhdWx0VmlldyIsICJnZXRTdHlsZSIsICJlbCIsICJwcm9wZXJ0eSIsICJnZXRQcm9wZXJ0eVZhbHVlIiwgInBvc2l0aW9ucyIsICJnZXRQb3NpdGlvbmVkU3R5bGUiLCAic3R5bGVzIiwgInN0eWxlIiwgInN1ZmZpeCIsICJyZXN1bHQiLCAiaSIsICJwb3MiLCAicGFyc2VGbG9hdCIsICJ3aWR0aCIsICJsZWZ0IiwgInJpZ2h0IiwgImhlaWdodCIsICJ0b3AiLCAiYm90dG9tIiwgInVzZU9mZnNldFBvcyIsICJ4IiwgInkiLCAidGFyZ2V0IiwgInNoYWRvd1Jvb3QiLCAiZ2V0Q2FudmFzUG9zaXRpb24iLCAiZSIsICJjYW52YXMiLCAidG91Y2hlcyIsICJzb3VyY2UiLCAibGVuZ3RoIiwgIm9mZnNldFgiLCAib2Zmc2V0WSIsICJib3giLCAicmVjdCIsICJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCAiY2xpZW50WCIsICJjbGllbnRZIiwgImdldFJlbGF0aXZlUG9zaXRpb24iLCAiZXZlbnQiLCAiY2hhcnQiLCAiY3VycmVudERldmljZVBpeGVsUmF0aW8iLCAiYm9yZGVyQm94IiwgImJveFNpemluZyIsICJwYWRkaW5ncyIsICJib3JkZXJzIiwgInhPZmZzZXQiLCAieU9mZnNldCIsICJNYXRoIiwgInJvdW5kIiwgImdldENvbnRhaW5lclNpemUiLCAibWF4V2lkdGgiLCAibWF4SGVpZ2h0IiwgInVuZGVmaW5lZCIsICJjb250YWluZXIiLCAiY2xpZW50V2lkdGgiLCAiY2xpZW50SGVpZ2h0IiwgImNvbnRhaW5lclN0eWxlIiwgImNvbnRhaW5lckJvcmRlciIsICJjb250YWluZXJQYWRkaW5nIiwgIklORklOSVRZIiwgInJvdW5kMSIsICJ2IiwgImdldE1heGltdW1TaXplIiwgImJiV2lkdGgiLCAiYmJIZWlnaHQiLCAiYXNwZWN0UmF0aW8iLCAibWFyZ2lucyIsICJjb250YWluZXJTaXplIiwgIm1heCIsICJtaW4iLCAibWFpbnRhaW5IZWlnaHQiLCAiZmxvb3IiLCAicmV0aW5hU2NhbGUiLCAiZm9yY2VSYXRpbyIsICJmb3JjZVN0eWxlIiwgInBpeGVsUmF0aW8iLCAiZGV2aWNlSGVpZ2h0IiwgImRldmljZVdpZHRoIiwgImN0eCIsICJzZXRUcmFuc2Zvcm0iLCAic3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyIsICJwYXNzaXZlU3VwcG9ydGVkIiwgIm9wdGlvbnMiLCAicGFzc2l2ZSIsICJhZGRFdmVudExpc3RlbmVyIiwgInJlbW92ZUV2ZW50TGlzdGVuZXIiLCAicmVhZFVzZWRTaXplIiwgInZhbHVlIiwgIm1hdGNoZXMiLCAibWF0Y2giLCAiZ2V0UmlnaHRUb0xlZnRBZGFwdGVyIiwgInJlY3RYIiwgIndpZHRoIiwgIngiLCAic2V0V2lkdGgiLCAidyIsICJ0ZXh0QWxpZ24iLCAiYWxpZ24iLCAieFBsdXMiLCAidmFsdWUiLCAibGVmdEZvckx0ciIsICJpdGVtV2lkdGgiLCAiZ2V0TGVmdFRvUmlnaHRBZGFwdGVyIiwgIl9pdGVtV2lkdGgiLCAiZ2V0UnRsQWRhcHRlciIsICJydGwiLCAib3ZlcnJpZGVUZXh0RGlyZWN0aW9uIiwgImN0eCIsICJkaXJlY3Rpb24iLCAic3R5bGUiLCAib3JpZ2luYWwiLCAiY2FudmFzIiwgImdldFByb3BlcnR5VmFsdWUiLCAiZ2V0UHJvcGVydHlQcmlvcml0eSIsICJzZXRQcm9wZXJ0eSIsICJwcmV2VGV4dERpcmVjdGlvbiIsICJyZXN0b3JlVGV4dERpcmVjdGlvbiIsICJ1bmRlZmluZWQiLCAiQW5pbWF0b3IiLCAiY29uc3RydWN0b3IiLCAiX3JlcXVlc3QiLCAiX2NoYXJ0cyIsICJNYXAiLCAiX3J1bm5pbmciLCAiX2xhc3REYXRlIiwgInVuZGVmaW5lZCIsICJfbm90aWZ5IiwgImNoYXJ0IiwgImFuaW1zIiwgImRhdGUiLCAidHlwZSIsICJjYWxsYmFja3MiLCAibGlzdGVuZXJzIiwgIm51bVN0ZXBzIiwgImR1cmF0aW9uIiwgImZvckVhY2giLCAiZm4iLCAiaW5pdGlhbCIsICJjdXJyZW50U3RlcCIsICJNYXRoIiwgIm1pbiIsICJzdGFydCIsICJfcmVmcmVzaCIsICJyZXF1ZXN0QW5pbUZyYW1lIiwgImNhbGwiLCAid2luZG93IiwgIl91cGRhdGUiLCAiRGF0ZSIsICJub3ciLCAicmVtYWluaW5nIiwgInJ1bm5pbmciLCAiaXRlbXMiLCAibGVuZ3RoIiwgImkiLCAiZHJhdyIsICJpdGVtIiwgIl9hY3RpdmUiLCAiX3RvdGFsIiwgInRpY2siLCAicG9wIiwgIl9nZXRBbmltcyIsICJjaGFydHMiLCAiZ2V0IiwgImNvbXBsZXRlIiwgInByb2dyZXNzIiwgInNldCIsICJsaXN0ZW4iLCAiZXZlbnQiLCAiY2IiLCAicHVzaCIsICJhZGQiLCAiaGFzIiwgInJlZHVjZSIsICJhY2MiLCAiY3VyIiwgIm1heCIsICJfZHVyYXRpb24iLCAic3RvcCIsICJjYW5jZWwiLCAicmVtb3ZlIiwgImRlbGV0ZSIsICJ0cmFuc3BhcmVudCIsICJpbnRlcnBvbGF0b3JzIiwgImJvb2xlYW4iLCAiZnJvbSIsICJ0byIsICJmYWN0b3IiLCAiY29sb3IiLCAiYzAiLCAiaGVscGVyc0NvbG9yIiwgImMxIiwgInZhbGlkIiwgIm1peCIsICJoZXhTdHJpbmciLCAibnVtYmVyIiwgIkFuaW1hdGlvbiIsICJjZmciLCAidGFyZ2V0IiwgInByb3AiLCAiY3VycmVudFZhbHVlIiwgInJlc29sdmUiLCAiX2ZuIiwgIl9lYXNpbmciLCAiZWZmZWN0cyIsICJlYXNpbmciLCAibGluZWFyIiwgIl9zdGFydCIsICJmbG9vciIsICJkZWxheSIsICJfbG9vcCIsICJsb29wIiwgIl90YXJnZXQiLCAiX3Byb3AiLCAiX2Zyb20iLCAiX3RvIiwgIl9wcm9taXNlcyIsICJhY3RpdmUiLCAidXBkYXRlIiwgImVsYXBzZWQiLCAicmVtYWluIiwgIndhaXQiLCAicHJvbWlzZXMiLCAiUHJvbWlzZSIsICJyZXMiLCAicmVqIiwgInJlc29sdmVkIiwgIm1ldGhvZCIsICJBbmltYXRpb25zIiwgImNvbmZpZyIsICJfY2hhcnQiLCAiX3Byb3BlcnRpZXMiLCAiY29uZmlndXJlIiwgImlzT2JqZWN0IiwgImFuaW1hdGlvbk9wdGlvbnMiLCAiT2JqZWN0IiwgImtleXMiLCAiZGVmYXVsdHMiLCAiYW5pbWF0aW9uIiwgImFuaW1hdGVkUHJvcHMiLCAiZ2V0T3duUHJvcGVydHlOYW1lcyIsICJrZXkiLCAib3B0aW9uIiwgImlzQXJyYXkiLCAicHJvcGVydGllcyIsICJfYW5pbWF0ZU9wdGlvbnMiLCAidmFsdWVzIiwgIm5ld09wdGlvbnMiLCAib3B0aW9ucyIsICJyZXNvbHZlVGFyZ2V0T3B0aW9ucyIsICJhbmltYXRpb25zIiwgIl9jcmVhdGVBbmltYXRpb25zIiwgIiRzaGFyZWQiLCAiYXdhaXRBbGwiLCAiJGFuaW1hdGlvbnMiLCAidGhlbiIsICJwcm9wcyIsICJjaGFyQXQiLCAidmFsdWUiLCAic2l6ZSIsICJhc3NpZ24iLCAiYW5pbWF0b3IiLCAiYW5pbSIsICJhbGwiLCAic2NhbGVDbGlwIiwgInNjYWxlIiwgImFsbG93ZWRPdmVyZmxvdyIsICJvcHRzIiwgInJldmVyc2UiLCAiZW5kIiwgImRlZmF1bHRDbGlwIiwgInhTY2FsZSIsICJ5U2NhbGUiLCAieCIsICJ5IiwgInRvcCIsICJyaWdodCIsICJib3R0b20iLCAibGVmdCIsICJ0b0NsaXAiLCAidCIsICJyIiwgImIiLCAibCIsICJkaXNhYmxlZCIsICJnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyIsICJmaWx0ZXJWaXNpYmxlIiwgIm1ldGFzZXRzIiwgIl9nZXRTb3J0ZWREYXRhc2V0TWV0YXMiLCAiaWxlbiIsICJpbmRleCIsICJhcHBseVN0YWNrIiwgInN0YWNrIiwgImRzSW5kZXgiLCAic2luZ2xlTW9kZSIsICJtb2RlIiwgImRhdGFzZXRJbmRleCIsICJvdGhlclZhbHVlIiwgImZvdW5kIiwgImlzRmluaXRlIiwgInNpZ24iLCAiY29udmVydE9iamVjdERhdGFUb0FycmF5IiwgImRhdGEiLCAibWV0YSIsICJpU2NhbGUiLCAidlNjYWxlIiwgImlBeGlzS2V5IiwgImF4aXMiLCAidkF4aXNLZXkiLCAiYWRhdGEiLCAiQXJyYXkiLCAiaXNTdGFja2VkIiwgInN0YWNrZWQiLCAiZ2V0U3RhY2tLZXkiLCAiaW5kZXhTY2FsZSIsICJ2YWx1ZVNjYWxlIiwgImlkIiwgImdldFVzZXJCb3VuZHMiLCAibWluRGVmaW5lZCIsICJtYXhEZWZpbmVkIiwgIk51bWJlciIsICJORUdBVElWRV9JTkZJTklUWSIsICJQT1NJVElWRV9JTkZJTklUWSIsICJnZXRPckNyZWF0ZVN0YWNrIiwgInN0YWNrcyIsICJzdGFja0tleSIsICJpbmRleFZhbHVlIiwgInN1YlN0YWNrIiwgImdldExhc3RJbmRleEluU3RhY2siLCAicG9zaXRpdmUiLCAiZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMiLCAidXBkYXRlU3RhY2tzIiwgImNvbnRyb2xsZXIiLCAicGFyc2VkIiwgIl9jYWNoZWRNZXRhIiwgIl9zdGFja3MiLCAiaUF4aXMiLCAidkF4aXMiLCAiaXRlbVN0YWNrcyIsICJfdG9wIiwgIl9ib3R0b20iLCAidmlzdWFsVmFsdWVzIiwgIl92aXN1YWxWYWx1ZXMiLCAiZ2V0Rmlyc3RTY2FsZUlkIiwgInNjYWxlcyIsICJmaWx0ZXIiLCAic2hpZnQiLCAiY3JlYXRlRGF0YXNldENvbnRleHQiLCAicGFyZW50IiwgImNyZWF0ZUNvbnRleHQiLCAiZGF0YXNldCIsICJjcmVhdGVEYXRhQ29udGV4dCIsICJlbGVtZW50IiwgImRhdGFJbmRleCIsICJyYXciLCAiY2xlYXJTdGFja3MiLCAiX3BhcnNlZCIsICJpc0RpcmVjdFVwZGF0ZU1vZGUiLCAiY2xvbmVJZk5vdFNoYXJlZCIsICJjYWNoZWQiLCAic2hhcmVkIiwgImNyZWF0ZVN0YWNrIiwgImNhblN0YWNrIiwgImhpZGRlbiIsICJfc3RhY2tlZCIsICJEYXRhc2V0Q29udHJvbGxlciIsICJfY3R4IiwgImN0eCIsICJfY2FjaGVkRGF0YU9wdHMiLCAiZ2V0TWV0YSIsICJfdHlwZSIsICJfcGFyc2luZyIsICJfZGF0YSIsICJfb2JqZWN0RGF0YSIsICJfc2hhcmVkT3B0aW9ucyIsICJfZHJhd1N0YXJ0IiwgIl9kcmF3Q291bnQiLCAiZW5hYmxlT3B0aW9uU2hhcmluZyIsICJzdXBwb3J0c0RlY2ltYXRpb24iLCAiJGNvbnRleHQiLCAiX3N5bmNMaXN0IiwgImRhdGFzZXRFbGVtZW50VHlwZSIsICJkYXRhRWxlbWVudFR5cGUiLCAiaW5pdGlhbGl6ZSIsICJsaW5rU2NhbGVzIiwgImFkZEVsZW1lbnRzIiwgImZpbGwiLCAiaXNQbHVnaW5FbmFibGVkIiwgImNvbnNvbGUiLCAid2FybiIsICJ1cGRhdGVJbmRleCIsICJnZXREYXRhc2V0IiwgImNob29zZUlkIiwgInhpZCIsICJ4QXhpc0lEIiwgInZhbHVlT3JEZWZhdWx0IiwgInlpZCIsICJ5QXhpc0lEIiwgInJpZCIsICJyQXhpc0lEIiwgImluZGV4QXhpcyIsICJpaWQiLCAiaUF4aXNJRCIsICJ2aWQiLCAidkF4aXNJRCIsICJnZXRTY2FsZUZvcklkIiwgInJTY2FsZSIsICJkYXRhc2V0cyIsICJnZXREYXRhc2V0TWV0YSIsICJzY2FsZUlEIiwgIl9nZXRPdGhlclNjYWxlIiwgInJlc2V0IiwgIl9kZXN0cm95IiwgInVubGlzdGVuQXJyYXlFdmVudHMiLCAiX2RhdGFDaGVjayIsICJpc0V4dGVuc2libGUiLCAibGlzdGVuQXJyYXlFdmVudHMiLCAiYnVpbGRPclVwZGF0ZUVsZW1lbnRzIiwgInJlc2V0TmV3RWxlbWVudHMiLCAic3RhY2tDaGFuZ2VkIiwgIm9sZFN0YWNrZWQiLCAiX3Jlc3luY0VsZW1lbnRzIiwgInNjb3BlS2V5cyIsICJkYXRhc2V0U2NvcGVLZXlzIiwgInNjb3BlcyIsICJnZXRPcHRpb25TY29wZXMiLCAiY3JlYXRlUmVzb2x2ZXIiLCAiZ2V0Q29udGV4dCIsICJwYXJzaW5nIiwgInBhcnNlIiwgImNvdW50IiwgInNvcnRlZCIsICJfc29ydGVkIiwgInByZXYiLCAicGFyc2VBcnJheURhdGEiLCAicGFyc2VPYmplY3REYXRhIiwgInBhcnNlUHJpbWl0aXZlRGF0YSIsICJpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldiIsICJsYWJlbHMiLCAiZ2V0TGFiZWxzIiwgInNpbmdsZVNjYWxlIiwgInhBeGlzS2V5IiwgInlBeGlzS2V5IiwgInJlc29sdmVPYmplY3RLZXkiLCAiZ2V0UGFyc2VkIiwgImdldERhdGFFbGVtZW50IiwgInVwZGF0ZVJhbmdlRnJvbVBhcnNlZCIsICJyYW5nZSIsICJwYXJzZWRWYWx1ZSIsICJOYU4iLCAiZ2V0TWluTWF4IiwgIm90aGVyU2NhbGUiLCAib3RoZXJNaW4iLCAib3RoZXJNYXgiLCAiX3NraXAiLCAiZ2V0QWxsUGFyc2VkVmFsdWVzIiwgImdldE1heE92ZXJmbG93IiwgImdldExhYmVsQW5kVmFsdWUiLCAibGFiZWwiLCAiZ2V0TGFiZWxGb3JWYWx1ZSIsICJfY2xpcCIsICJjbGlwIiwgImVsZW1lbnRzIiwgImFyZWEiLCAiY2hhcnRBcmVhIiwgImRyYXdBY3RpdmVFbGVtZW50c09uVG9wIiwgImdldFN0eWxlIiwgInJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMiLCAicmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyIsICJjb250ZXh0IiwgIl9yZXNvbHZlRWxlbWVudE9wdGlvbnMiLCAiZWxlbWVudFR5cGUiLCAiY2FjaGUiLCAiY2FjaGVLZXkiLCAic2hhcmluZyIsICJkZWZpbmVkIiwgImRhdGFzZXRFbGVtZW50U2NvcGVLZXlzIiwgInByZWZpeGVzIiwgIm5hbWVzIiwgInJlc29sdmVOYW1lZE9wdGlvbnMiLCAiZnJlZXplIiwgIl9yZXNvbHZlQW5pbWF0aW9ucyIsICJ0cmFuc2l0aW9uIiwgImRhdGFzZXRBbmltYXRpb25TY29wZUtleXMiLCAiX2NhY2hlYWJsZSIsICJnZXRTaGFyZWRPcHRpb25zIiwgImluY2x1ZGVPcHRpb25zIiwgInNoYXJlZE9wdGlvbnMiLCAiX2FuaW1hdGlvbnNEaXNhYmxlZCIsICJfZ2V0U2hhcmVkT3B0aW9ucyIsICJmaXJzdE9wdHMiLCAicHJldmlvdXNseVNoYXJlZE9wdGlvbnMiLCAidXBkYXRlU2hhcmVkT3B0aW9ucyIsICJ1cGRhdGVFbGVtZW50IiwgIl9zZXRTdHlsZSIsICJyZW1vdmVIb3ZlclN0eWxlIiwgInNldEhvdmVyU3R5bGUiLCAiX3JlbW92ZURhdGFzZXRIb3ZlclN0eWxlIiwgIl9zZXREYXRhc2V0SG92ZXJTdHlsZSIsICJhcmcxIiwgImFyZzIiLCAibnVtTWV0YSIsICJudW1EYXRhIiwgIl9pbnNlcnRFbGVtZW50cyIsICJfcmVtb3ZlRWxlbWVudHMiLCAibW92ZSIsICJhcnIiLCAidXBkYXRlRWxlbWVudHMiLCAicmVtb3ZlZCIsICJzcGxpY2UiLCAiX3N5bmMiLCAiYXJncyIsICJfZGF0YUNoYW5nZXMiLCAiX29uRGF0YVB1c2giLCAiYXJndW1lbnRzIiwgIl9vbkRhdGFQb3AiLCAiX29uRGF0YVNoaWZ0IiwgIl9vbkRhdGFTcGxpY2UiLCAibmV3Q291bnQiLCAiX29uRGF0YVVuc2hpZnQiLCAiZ2V0QWxsU2NhbGVWYWx1ZXMiLCAiX2NhY2hlIiwgIiRiYXIiLCAidmlzaWJsZU1ldGFzIiwgImNvbmNhdCIsICJfYXJyYXlVbmlxdWUiLCAic29ydCIsICJhIiwgImNvbXB1dGVNaW5TYW1wbGVTaXplIiwgIl9sZW5ndGgiLCAiY3VyciIsICJ1cGRhdGVNaW5BbmRQcmV2IiwgImFicyIsICJnZXRQaXhlbEZvclZhbHVlIiwgInRpY2tzIiwgImdldFBpeGVsRm9yVGljayIsICJjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMiLCAicnVsZXIiLCAic3RhY2tDb3VudCIsICJ0aGlja25lc3MiLCAiYmFyVGhpY2tuZXNzIiwgInJhdGlvIiwgImlzTnVsbE9yVW5kZWYiLCAiY2F0ZWdvcnlQZXJjZW50YWdlIiwgImJhclBlcmNlbnRhZ2UiLCAiY2h1bmsiLCAicGl4ZWxzIiwgImNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMiLCAibmV4dCIsICJwZXJjZW50IiwgInBhcnNlRmxvYXRCYXIiLCAiZW50cnkiLCAic3RhcnRWYWx1ZSIsICJlbmRWYWx1ZSIsICJiYXJTdGFydCIsICJiYXJFbmQiLCAiX2N1c3RvbSIsICJwYXJzZVZhbHVlIiwgInBhcnNlQXJyYXlPclByaW1pdGl2ZSIsICJpc0Zsb2F0QmFyIiwgImN1c3RvbSIsICJiYXJTaWduIiwgImFjdHVhbEJhc2UiLCAiaXNIb3Jpem9udGFsIiwgImJvcmRlclByb3BzIiwgImhvcml6b250YWwiLCAiYmFzZSIsICJzZXRCb3JkZXJTa2lwcGVkIiwgImVkZ2UiLCAiYm9yZGVyU2tpcHBlZCIsICJlbmFibGVCb3JkZXJSYWRpdXMiLCAicGFyc2VFZGdlIiwgInN3YXAiLCAic3RhcnRFbmQiLCAib3JpZyIsICJ2MSIsICJ2MiIsICJ2IiwgInNldEluZmxhdGVBbW91bnQiLCAiaW5mbGF0ZUFtb3VudCIsICJCYXJDb250cm9sbGVyIiwgIm9iaiIsICJiYXJzIiwgImdldEJhc2VQaXhlbCIsICJfZ2V0UnVsZXIiLCAidnBpeGVscyIsICJoZWFkIiwgIl9jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyIsICJpcGl4ZWxzIiwgIl9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyIsICJjZW50ZXIiLCAiaGVpZ2h0IiwgIndpZHRoIiwgIl9nZXRTdGFja3MiLCAibGFzdCIsICJncm91cGVkIiwgImN1cnJlbnRQYXJzZWQiLCAiaVNjYWxlVmFsdWUiLCAic2tpcE51bGwiLCAiZmluZCIsICJ2YWwiLCAiaXNOYU4iLCAiaW5kZXhPZiIsICJfZ2V0U3RhY2tDb3VudCIsICJfZ2V0U3RhY2tJbmRleCIsICJuYW1lIiwgIl9zdGFydFBpeGVsIiwgIl9lbmRQaXhlbCIsICJiYXNlVmFsdWUiLCAibWluQmFyTGVuZ3RoIiwgImZsb2F0aW5nIiwgImdldERhdGFWaXNpYmlsaXR5IiwgInN0YXJ0UGl4ZWwiLCAiZ2V0UGl4ZWxGb3JEZWNpbWFsIiwgImVuZFBpeGVsIiwgImdldFZhbHVlRm9yUGl4ZWwiLCAiaGFsZkdyaWQiLCAiZ2V0TGluZVdpZHRoRm9yVmFsdWUiLCAibWF4QmFyVGhpY2tuZXNzIiwgIkluZmluaXR5IiwgInN0YWNrSW5kZXgiLCAicmVjdHMiLCAibnVtYmVycyIsICJvdmVycmlkZXMiLCAiX2luZGV4XyIsICJvZmZzZXQiLCAiZ3JpZCIsICJfdmFsdWVfIiwgImJlZ2luQXRaZXJvIiwgImdldFJhdGlvQW5kT2Zmc2V0IiwgInJvdGF0aW9uIiwgImNpcmN1bWZlcmVuY2UiLCAiY3V0b3V0IiwgInJhdGlvWCIsICJyYXRpb1kiLCAib2Zmc2V0WCIsICJvZmZzZXRZIiwgIlRBVSIsICJzdGFydEFuZ2xlIiwgImVuZEFuZ2xlIiwgInN0YXJ0WCIsICJNYXRoIiwgImNvcyIsICJzdGFydFkiLCAic2luIiwgImVuZFgiLCAiZW5kWSIsICJjYWxjTWF4IiwgImFuZ2xlIiwgImEiLCAiYiIsICJfYW5nbGVCZXR3ZWVuIiwgIm1heCIsICJjYWxjTWluIiwgIm1pbiIsICJtYXhYIiwgIm1heFkiLCAiSEFMRl9QSSIsICJtaW5YIiwgIlBJIiwgIm1pblkiLCAiRG91Z2hudXRDb250cm9sbGVyIiwgIkRhdGFzZXRDb250cm9sbGVyIiwgImNvbnN0cnVjdG9yIiwgImNoYXJ0IiwgImRhdGFzZXRJbmRleCIsICJlbmFibGVPcHRpb25TaGFyaW5nIiwgImlubmVyUmFkaXVzIiwgInVuZGVmaW5lZCIsICJvdXRlclJhZGl1cyIsICJsaW5rU2NhbGVzIiwgInBhcnNlIiwgInN0YXJ0IiwgImNvdW50IiwgImRhdGEiLCAiZ2V0RGF0YXNldCIsICJtZXRhIiwgIl9jYWNoZWRNZXRhIiwgIl9wYXJzaW5nIiwgIl9wYXJzZWQiLCAiZ2V0dGVyIiwgImkiLCAiaXNPYmplY3QiLCAia2V5IiwgInJlc29sdmVPYmplY3RLZXkiLCAiaWxlbiIsICJfZ2V0Um90YXRpb24iLCAidG9SYWRpYW5zIiwgIm9wdGlvbnMiLCAiX2dldENpcmN1bWZlcmVuY2UiLCAiX2dldFJvdGF0aW9uRXh0ZW50cyIsICJkYXRhc2V0cyIsICJsZW5ndGgiLCAiaXNEYXRhc2V0VmlzaWJsZSIsICJnZXREYXRhc2V0TWV0YSIsICJ0eXBlIiwgIl90eXBlIiwgImNvbnRyb2xsZXIiLCAidXBkYXRlIiwgIm1vZGUiLCAiY2hhcnRBcmVhIiwgImFyY3MiLCAic3BhY2luZyIsICJnZXRNYXhCb3JkZXJXaWR0aCIsICJnZXRNYXhPZmZzZXQiLCAibWF4U2l6ZSIsICJ3aWR0aCIsICJoZWlnaHQiLCAidG9QZXJjZW50YWdlIiwgImNoYXJ0V2VpZ2h0IiwgIl9nZXRSaW5nV2VpZ2h0IiwgImluZGV4IiwgIm1heFdpZHRoIiwgIm1heEhlaWdodCIsICJtYXhSYWRpdXMiLCAidG9EaW1lbnNpb24iLCAicmFkaXVzIiwgInJhZGl1c0xlbmd0aCIsICJfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCIsICJ0b3RhbCIsICJjYWxjdWxhdGVUb3RhbCIsICJfZ2V0UmluZ1dlaWdodE9mZnNldCIsICJ1cGRhdGVFbGVtZW50cyIsICJfY2lyY3VtZmVyZW5jZSIsICJyZXNldCIsICJvcHRzIiwgImFuaW1hdGlvbiIsICJhbmltYXRlUm90YXRlIiwgImdldERhdGFWaXNpYmlsaXR5IiwgImhpZGRlbiIsICJjYWxjdWxhdGVDaXJjdW1mZXJlbmNlIiwgImFuaW1hdGlvbk9wdHMiLCAiY2VudGVyWCIsICJsZWZ0IiwgInJpZ2h0IiwgImNlbnRlclkiLCAidG9wIiwgImJvdHRvbSIsICJhbmltYXRlU2NhbGUiLCAic2hhcmVkT3B0aW9ucyIsICJpbmNsdWRlT3B0aW9ucyIsICJfZ2V0U2hhcmVkT3B0aW9ucyIsICJhcmMiLCAicHJvcGVydGllcyIsICJ4IiwgInkiLCAicmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyIsICJhY3RpdmUiLCAidXBkYXRlRWxlbWVudCIsICJtZXRhRGF0YSIsICJ2YWx1ZSIsICJpc05hTiIsICJhYnMiLCAiZ2V0TGFiZWxBbmRWYWx1ZSIsICJsYWJlbHMiLCAiZm9ybWF0TnVtYmVyIiwgImxvY2FsZSIsICJsYWJlbCIsICJib3JkZXJBbGlnbiIsICJib3JkZXJXaWR0aCIsICJob3ZlckJvcmRlcldpZHRoIiwgIm9mZnNldCIsICJob3Zlck9mZnNldCIsICJyaW5nV2VpZ2h0T2Zmc2V0IiwgInZhbHVlT3JEZWZhdWx0IiwgIndlaWdodCIsICJpZCIsICJkZWZhdWx0cyIsICJkYXRhc2V0RWxlbWVudFR5cGUiLCAiZGF0YUVsZW1lbnRUeXBlIiwgImFuaW1hdGlvbnMiLCAibnVtYmVycyIsICJpbmRleEF4aXMiLCAiZGVzY3JpcHRvcnMiLCAiX3NjcmlwdGFibGUiLCAibmFtZSIsICJfaW5kZXhhYmxlIiwgInN0YXJ0c1dpdGgiLCAib3ZlcnJpZGVzIiwgImFzcGVjdFJhdGlvIiwgInBsdWdpbnMiLCAibGVnZW5kIiwgImdlbmVyYXRlTGFiZWxzIiwgInBvaW50U3R5bGUiLCAiY29sb3IiLCAibWFwIiwgInN0eWxlIiwgImdldFN0eWxlIiwgInRleHQiLCAiZmlsbFN0eWxlIiwgImJhY2tncm91bmRDb2xvciIsICJzdHJva2VTdHlsZSIsICJib3JkZXJDb2xvciIsICJmb250Q29sb3IiLCAibGluZVdpZHRoIiwgIm9uQ2xpY2siLCAiZSIsICJsZWdlbmRJdGVtIiwgInRvZ2dsZURhdGFWaXNpYmlsaXR5IiwgIlBpZUNvbnRyb2xsZXIiLCAiRG91Z2hudXRDb250cm9sbGVyIiwgImlkIiwgImRlZmF1bHRzIiwgImN1dG91dCIsICJyb3RhdGlvbiIsICJjaXJjdW1mZXJlbmNlIiwgInJhZGl1cyIsICJhYnN0cmFjdCIsICJFcnJvciIsICJEYXRlQWRhcHRlckJhc2UiLCAiY29uc3RydWN0b3IiLCAib3B0aW9ucyIsICJvdmVycmlkZSIsICJtZW1iZXJzIiwgIk9iamVjdCIsICJhc3NpZ24iLCAicHJvdG90eXBlIiwgImluaXQiLCAiZm9ybWF0cyIsICJwYXJzZSIsICJmb3JtYXQiLCAiYWRkIiwgImRpZmYiLCAic3RhcnRPZiIsICJlbmRPZiIsICJfZGF0ZSIsICJiaW5hcnlTZWFyY2giLCAibWV0YXNldCIsICJheGlzIiwgInZhbHVlIiwgImludGVyc2VjdCIsICJjb250cm9sbGVyIiwgImRhdGEiLCAiX3NvcnRlZCIsICJpU2NhbGUiLCAiX2NhY2hlZE1ldGEiLCAic3BhbkdhcHMiLCAiZGF0YXNldCIsICJsZW5ndGgiLCAibG9va3VwTWV0aG9kIiwgIl9yZXZlcnNlUGl4ZWxzIiwgIl9ybG9va3VwQnlLZXkiLCAiX2xvb2t1cEJ5S2V5IiwgInJlc3VsdCIsICJ2U2NhbGUiLCAiX3BhcnNlZCIsICJkaXN0YW5jZVRvRGVmaW5lZExvIiwgInNsaWNlIiwgImxvIiwgInJldmVyc2UiLCAiZmluZEluZGV4IiwgInBvaW50IiwgImlzTnVsbE9yVW5kZWYiLCAiTWF0aCIsICJtYXgiLCAiZGlzdGFuY2VUb0RlZmluZWRIaSIsICJoaSIsICJfc2hhcmVkT3B0aW9ucyIsICJlbCIsICJyYW5nZSIsICJnZXRSYW5nZSIsICJzdGFydCIsICJlbmQiLCAiZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zIiwgImNoYXJ0IiwgInBvc2l0aW9uIiwgImhhbmRsZXIiLCAibWV0YXNldHMiLCAiZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcyIsICJpIiwgImlsZW4iLCAiaW5kZXgiLCAiaiIsICJlbGVtZW50IiwgInNraXAiLCAiZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzIiwgInVzZVgiLCAiaW5kZXhPZiIsICJ1c2VZIiwgInB0MSIsICJwdDIiLCAiZGVsdGFYIiwgImFicyIsICJ4IiwgImRlbHRhWSIsICJ5IiwgInNxcnQiLCAicG93IiwgImdldEludGVyc2VjdEl0ZW1zIiwgInVzZUZpbmFsUG9zaXRpb24iLCAiaW5jbHVkZUludmlzaWJsZSIsICJpdGVtcyIsICJpc1BvaW50SW5BcmVhIiwgImV2YWx1YXRpb25GdW5jIiwgImRhdGFzZXRJbmRleCIsICJfaXNQb2ludEluQXJlYSIsICJjaGFydEFyZWEiLCAiaW5SYW5nZSIsICJwdXNoIiwgImdldE5lYXJlc3RSYWRpYWxJdGVtcyIsICJzdGFydEFuZ2xlIiwgImVuZEFuZ2xlIiwgImdldFByb3BzIiwgImFuZ2xlIiwgImdldEFuZ2xlRnJvbVBvaW50IiwgIl9hbmdsZUJldHdlZW4iLCAiZ2V0TmVhcmVzdENhcnRlc2lhbkl0ZW1zIiwgImRpc3RhbmNlTWV0cmljIiwgIm1pbkRpc3RhbmNlIiwgIk51bWJlciIsICJQT1NJVElWRV9JTkZJTklUWSIsICJjZW50ZXIiLCAiZ2V0Q2VudGVyUG9pbnQiLCAicG9pbnRJbkFyZWEiLCAiZGlzdGFuY2UiLCAiZ2V0TmVhcmVzdEl0ZW1zIiwgImdldEF4aXNJdGVtcyIsICJyYW5nZU1ldGhvZCIsICJpbnRlcnNlY3RzSXRlbSIsICJtb2RlcyIsICJlIiwgImdldFJlbGF0aXZlUG9zaXRpb24iLCAiZWxlbWVudHMiLCAiZm9yRWFjaCIsICJtZXRhIiwgImdldERhdGFzZXRNZXRhIiwgIm5lYXJlc3QiLCAiU1RBVElDX1BPU0lUSU9OUyIsICJmaWx0ZXJCeVBvc2l0aW9uIiwgImFycmF5IiwgImZpbHRlciIsICJ2IiwgInBvcyIsICJmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMiLCAiYm94IiwgInNvcnRCeVdlaWdodCIsICJzb3J0IiwgImEiLCAiYiIsICJ2MCIsICJ2MSIsICJ3ZWlnaHQiLCAid3JhcEJveGVzIiwgImJveGVzIiwgImxheW91dEJveGVzIiwgInN0YWNrIiwgInN0YWNrV2VpZ2h0IiwgImhvcml6b250YWwiLCAiaXNIb3Jpem9udGFsIiwgImJ1aWxkU3RhY2tzIiwgImxheW91dHMiLCAic3RhY2tzIiwgIndyYXAiLCAiaW5jbHVkZXMiLCAiX3N0YWNrIiwgImNvdW50IiwgInBsYWNlZCIsICJzaXplIiwgInNldExheW91dERpbXMiLCAicGFyYW1zIiwgInZCb3hNYXhXaWR0aCIsICJoQm94TWF4SGVpZ2h0IiwgImxheW91dCIsICJmdWxsU2l6ZSIsICJmYWN0b3IiLCAid2lkdGgiLCAiYXZhaWxhYmxlV2lkdGgiLCAiaGVpZ2h0IiwgImF2YWlsYWJsZUhlaWdodCIsICJidWlsZExheW91dEJveGVzIiwgImxlZnQiLCAicmlnaHQiLCAidG9wIiwgImJvdHRvbSIsICJjZW50ZXJIb3Jpem9udGFsIiwgImNlbnRlclZlcnRpY2FsIiwgImxlZnRBbmRUb3AiLCAiY29uY2F0IiwgInJpZ2h0QW5kQm90dG9tIiwgInZlcnRpY2FsIiwgImdldENvbWJpbmVkTWF4IiwgIm1heFBhZGRpbmciLCAidXBkYXRlTWF4UGFkZGluZyIsICJib3hQYWRkaW5nIiwgInVwZGF0ZURpbXMiLCAiaXNPYmplY3QiLCAiZ2V0UGFkZGluZyIsICJuZXdXaWR0aCIsICJvdXRlcldpZHRoIiwgIm5ld0hlaWdodCIsICJvdXRlckhlaWdodCIsICJ3aWR0aENoYW5nZWQiLCAidyIsICJoZWlnaHRDaGFuZ2VkIiwgImgiLCAic2FtZSIsICJvdGhlciIsICJoYW5kbGVNYXhQYWRkaW5nIiwgInVwZGF0ZVBvcyIsICJjaGFuZ2UiLCAiZ2V0TWFyZ2lucyIsICJtYXJnaW5Gb3JQb3NpdGlvbnMiLCAicG9zaXRpb25zIiwgIm1hcmdpbiIsICJmaXRCb3hlcyIsICJyZWZpdEJveGVzIiwgInJlZml0IiwgImNoYW5nZWQiLCAidXBkYXRlIiwgInNldEJveERpbXMiLCAicGxhY2VCb3hlcyIsICJ1c2VyUGFkZGluZyIsICJwYWRkaW5nIiwgImRlZmluZWQiLCAiYWRkQm94IiwgIml0ZW0iLCAiX2xheWVycyIsICJ6IiwgImRyYXciLCAicmVtb3ZlQm94IiwgImxheW91dEl0ZW0iLCAic3BsaWNlIiwgImNvbmZpZ3VyZSIsICJtaW5QYWRkaW5nIiwgInRvUGFkZGluZyIsICJ2ZXJ0aWNhbEJveGVzIiwgImhvcml6b250YWxCb3hlcyIsICJlYWNoIiwgImJlZm9yZUxheW91dCIsICJ2aXNpYmxlVmVydGljYWxCb3hDb3VudCIsICJyZWR1Y2UiLCAidG90YWwiLCAiZGlzcGxheSIsICJmcmVlemUiLCAiQmFzZVBsYXRmb3JtIiwgImFjcXVpcmVDb250ZXh0IiwgImNhbnZhcyIsICJhc3BlY3RSYXRpbyIsICJyZWxlYXNlQ29udGV4dCIsICJjb250ZXh0IiwgImFkZEV2ZW50TGlzdGVuZXIiLCAidHlwZSIsICJsaXN0ZW5lciIsICJyZW1vdmVFdmVudExpc3RlbmVyIiwgImdldERldmljZVBpeGVsUmF0aW8iLCAiZ2V0TWF4aW11bVNpemUiLCAiZmxvb3IiLCAiaXNBdHRhY2hlZCIsICJ1cGRhdGVDb25maWciLCAiY29uZmlnIiwgIkJhc2ljUGxhdGZvcm0iLCAiZ2V0Q29udGV4dCIsICJhbmltYXRpb24iLCAiRVhQQU5ET19LRVkiLCAiRVZFTlRfVFlQRVMiLCAidG91Y2hzdGFydCIsICJ0b3VjaG1vdmUiLCAidG91Y2hlbmQiLCAicG9pbnRlcmVudGVyIiwgInBvaW50ZXJkb3duIiwgInBvaW50ZXJtb3ZlIiwgInBvaW50ZXJ1cCIsICJwb2ludGVybGVhdmUiLCAicG9pbnRlcm91dCIsICJpc051bGxPckVtcHR5IiwgImluaXRDYW52YXMiLCAic3R5bGUiLCAicmVuZGVySGVpZ2h0IiwgImdldEF0dHJpYnV0ZSIsICJyZW5kZXJXaWR0aCIsICJpbml0aWFsIiwgImJveFNpemluZyIsICJkaXNwbGF5V2lkdGgiLCAicmVhZFVzZWRTaXplIiwgInVuZGVmaW5lZCIsICJkaXNwbGF5SGVpZ2h0IiwgImV2ZW50TGlzdGVuZXJPcHRpb25zIiwgInN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMiLCAicGFzc2l2ZSIsICJhZGRMaXN0ZW5lciIsICJub2RlIiwgInJlbW92ZUxpc3RlbmVyIiwgImZyb21OYXRpdmVFdmVudCIsICJldmVudCIsICJuYXRpdmUiLCAibm9kZUxpc3RDb250YWlucyIsICJub2RlTGlzdCIsICJjb250YWlucyIsICJjcmVhdGVBdHRhY2hPYnNlcnZlciIsICJvYnNlcnZlciIsICJNdXRhdGlvbk9ic2VydmVyIiwgImVudHJpZXMiLCAidHJpZ2dlciIsICJlbnRyeSIsICJhZGRlZE5vZGVzIiwgInJlbW92ZWROb2RlcyIsICJvYnNlcnZlIiwgImRvY3VtZW50IiwgImNoaWxkTGlzdCIsICJzdWJ0cmVlIiwgImNyZWF0ZURldGFjaE9ic2VydmVyIiwgImRycExpc3RlbmluZ0NoYXJ0cyIsICJNYXAiLCAib2xkRGV2aWNlUGl4ZWxSYXRpbyIsICJvbldpbmRvd1Jlc2l6ZSIsICJkcHIiLCAid2luZG93IiwgImRldmljZVBpeGVsUmF0aW8iLCAicmVzaXplIiwgImN1cnJlbnREZXZpY2VQaXhlbFJhdGlvIiwgImxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzIiwgInNldCIsICJ1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzIiwgImRlbGV0ZSIsICJjcmVhdGVSZXNpemVPYnNlcnZlciIsICJjb250YWluZXIiLCAiX2dldFBhcmVudE5vZGUiLCAidGhyb3R0bGVkIiwgImNsaWVudFdpZHRoIiwgIlJlc2l6ZU9ic2VydmVyIiwgImNvbnRlbnRSZWN0IiwgInJlbGVhc2VPYnNlcnZlciIsICJkaXNjb25uZWN0IiwgImNyZWF0ZVByb3h5QW5kTGlzdGVuIiwgInByb3h5IiwgImN0eCIsICJEb21QbGF0Zm9ybSIsICJwcm9wIiwgInJlbW92ZUF0dHJpYnV0ZSIsICJzZXRBdHRyaWJ1dGUiLCAia2V5cyIsICJrZXkiLCAicHJveGllcyIsICIkcHJveGllcyIsICJoYW5kbGVycyIsICJhdHRhY2giLCAiZGV0YWNoIiwgImlzQ29ubmVjdGVkIiwgIl9kZXRlY3RQbGF0Zm9ybSIsICJfaXNEb21TdXBwb3J0ZWQiLCAiT2Zmc2NyZWVuQ2FudmFzIiwgIkVsZW1lbnQiLCAiYWN0aXZlIiwgIiRhbmltYXRpb25zIiwgInRvb2x0aXBQb3NpdGlvbiIsICJoYXNWYWx1ZSIsICJpc051bWJlciIsICJwcm9wcyIsICJmaW5hbCIsICJhbmltcyIsICJyZXQiLCAiX3RvIiwgImRlZmF1bHRzIiwgImRlZmF1bHRSb3V0ZXMiLCAiYXV0b1NraXAiLCAic2NhbGUiLCAidGlja3MiLCAidGlja09wdHMiLCAiZGV0ZXJtaW5lZE1heFRpY2tzIiwgImRldGVybWluZU1heFRpY2tzIiwgInRpY2tzTGltaXQiLCAibWluIiwgIm1heFRpY2tzTGltaXQiLCAibWFqb3JJbmRpY2VzIiwgIm1ham9yIiwgImVuYWJsZWQiLCAiZ2V0TWFqb3JJbmRpY2VzIiwgIm51bU1ham9ySW5kaWNlcyIsICJmaXJzdCIsICJsYXN0IiwgIm5ld1RpY2tzIiwgInNraXBNYWpvcnMiLCAic3BhY2luZyIsICJjYWxjdWxhdGVTcGFjaW5nIiwgImF2Z01ham9yU3BhY2luZyIsICJyb3VuZCIsICJvZmZzZXQiLCAidGlja0xlbmd0aCIsICJfdGlja1NpemUiLCAibWF4U2NhbGUiLCAiX2xlbmd0aCIsICJtYXhDaGFydCIsICJfbWF4TGVuZ3RoIiwgImV2ZW5NYWpvclNwYWNpbmciLCAiZ2V0RXZlblNwYWNpbmciLCAiZmFjdG9ycyIsICJfZmFjdG9yaXplIiwgIm5leHQiLCAiY2VpbCIsICJtYWpvclN0YXJ0IiwgIm1ham9yRW5kIiwgInZhbHVlT3JEZWZhdWx0IiwgImFyciIsICJsZW4iLCAicmV2ZXJzZUFsaWduIiwgImFsaWduIiwgIm9mZnNldEZyb21FZGdlIiwgImVkZ2UiLCAiZ2V0VGlja3NMaW1pdCIsICJ0aWNrc0xlbmd0aCIsICJzYW1wbGUiLCAibnVtSXRlbXMiLCAiaW5jcmVtZW50IiwgImdldFBpeGVsRm9yR3JpZExpbmUiLCAib2Zmc2V0R3JpZExpbmVzIiwgInZhbGlkSW5kZXgiLCAiX3N0YXJ0UGl4ZWwiLCAiX2VuZFBpeGVsIiwgImVwc2lsb24iLCAibGluZVZhbHVlIiwgImdldFBpeGVsRm9yVGljayIsICJnYXJiYWdlQ29sbGVjdCIsICJjYWNoZXMiLCAiY2FjaGUiLCAiZ2MiLCAiZ2NMZW4iLCAiZ2V0VGlja01hcmtMZW5ndGgiLCAiZHJhd1RpY2tzIiwgImdldFRpdGxlSGVpZ2h0IiwgImZhbGxiYWNrIiwgImZvbnQiLCAidG9Gb250IiwgImxpbmVzIiwgImlzQXJyYXkiLCAidGV4dCIsICJsaW5lSGVpZ2h0IiwgImNyZWF0ZVNjYWxlQ29udGV4dCIsICJwYXJlbnQiLCAiY3JlYXRlQ29udGV4dCIsICJjcmVhdGVUaWNrQ29udGV4dCIsICJ0aWNrIiwgInRpdGxlQWxpZ24iLCAiX3RvTGVmdFJpZ2h0Q2VudGVyIiwgInRpdGxlQXJncyIsICJzY2FsZXMiLCAicm90YXRpb24iLCAibWF4V2lkdGgiLCAidGl0bGVYIiwgInRpdGxlWSIsICJfYWxpZ25TdGFydEVuZCIsICJwb3NpdGlvbkF4aXNJRCIsICJnZXRQaXhlbEZvclZhbHVlIiwgIkhBTEZfUEkiLCAiU2NhbGUiLCAiY2ZnIiwgImlkIiwgIl9tYXJnaW5zIiwgIm1heEhlaWdodCIsICJwYWRkaW5nVG9wIiwgInBhZGRpbmdCb3R0b20iLCAicGFkZGluZ0xlZnQiLCAicGFkZGluZ1JpZ2h0IiwgImxhYmVsUm90YXRpb24iLCAiX3JhbmdlIiwgIl9ncmlkTGluZUl0ZW1zIiwgIl9sYWJlbEl0ZW1zIiwgIl9sYWJlbFNpemVzIiwgIl9sb25nZXN0VGV4dENhY2hlIiwgIl91c2VyTWF4IiwgIl91c2VyTWluIiwgIl9zdWdnZXN0ZWRNYXgiLCAiX3N1Z2dlc3RlZE1pbiIsICJfdGlja3NMZW5ndGgiLCAiX2JvcmRlclZhbHVlIiwgIl9jYWNoZSIsICJfZGF0YUxpbWl0c0NhY2hlZCIsICIkY29udGV4dCIsICJzZXRDb250ZXh0IiwgInN1Z2dlc3RlZE1pbiIsICJzdWdnZXN0ZWRNYXgiLCAicmF3IiwgImdldFVzZXJCb3VuZHMiLCAiZmluaXRlT3JEZWZhdWx0IiwgIk5FR0FUSVZFX0lORklOSVRZIiwgIm1pbkRlZmluZWQiLCAiaXNGaW5pdGUiLCAibWF4RGVmaW5lZCIsICJnZXRNaW5NYXgiLCAiY2FuU3RhY2siLCAibWV0YXMiLCAiZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMiLCAiZ2V0VGlja3MiLCAiZ2V0TGFiZWxzIiwgImxhYmVscyIsICJ4TGFiZWxzIiwgInlMYWJlbHMiLCAiZ2V0TGFiZWxJdGVtcyIsICJfY29tcHV0ZUxhYmVsSXRlbXMiLCAiYmVmb3JlVXBkYXRlIiwgImNhbGwiLCAibWFyZ2lucyIsICJiZWdpbkF0WmVybyIsICJncmFjZSIsICJzYW1wbGVTaXplIiwgImJlZm9yZVNldERpbWVuc2lvbnMiLCAic2V0RGltZW5zaW9ucyIsICJhZnRlclNldERpbWVuc2lvbnMiLCAiYmVmb3JlRGF0YUxpbWl0cyIsICJkZXRlcm1pbmVEYXRhTGltaXRzIiwgImFmdGVyRGF0YUxpbWl0cyIsICJfYWRkR3JhY2UiLCAiYmVmb3JlQnVpbGRUaWNrcyIsICJidWlsZFRpY2tzIiwgImFmdGVyQnVpbGRUaWNrcyIsICJzYW1wbGluZ0VuYWJsZWQiLCAiX2NvbnZlcnRUaWNrc1RvTGFiZWxzIiwgImJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24iLCAiY2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsICJhZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24iLCAic291cmNlIiwgImFmdGVyQXV0b1NraXAiLCAiYmVmb3JlRml0IiwgImZpdCIsICJhZnRlckZpdCIsICJhZnRlclVwZGF0ZSIsICJyZXZlcnNlUGl4ZWxzIiwgInN0YXJ0UGl4ZWwiLCAiZW5kUGl4ZWwiLCAiX2FsaWduVG9QaXhlbHMiLCAiYWxpZ25Ub1BpeGVscyIsICJfY2FsbEhvb2tzIiwgIm5hbWUiLCAibm90aWZ5UGx1Z2lucyIsICJiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24iLCAiZ2VuZXJhdGVUaWNrTGFiZWxzIiwgImxhYmVsIiwgImNhbGxiYWNrIiwgImFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uIiwgIm51bVRpY2tzIiwgIm1pblJvdGF0aW9uIiwgIm1heFJvdGF0aW9uIiwgInRpY2tXaWR0aCIsICJtYXhMYWJlbERpYWdvbmFsIiwgIl9pc1Zpc2libGUiLCAibGFiZWxTaXplcyIsICJfZ2V0TGFiZWxTaXplcyIsICJtYXhMYWJlbFdpZHRoIiwgIndpZGVzdCIsICJtYXhMYWJlbEhlaWdodCIsICJoaWdoZXN0IiwgIl9saW1pdFZhbHVlIiwgImdyaWQiLCAidGl0bGUiLCAidG9EZWdyZWVzIiwgImFzaW4iLCAibWluU2l6ZSIsICJ0aXRsZU9wdHMiLCAiZ3JpZE9wdHMiLCAidGl0bGVIZWlnaHQiLCAidGlja1BhZGRpbmciLCAiYW5nbGVSYWRpYW5zIiwgInRvUmFkaWFucyIsICJjb3MiLCAic2luIiwgImxhYmVsSGVpZ2h0IiwgIm1pcnJvciIsICJsYWJlbFdpZHRoIiwgIl9jYWxjdWxhdGVQYWRkaW5nIiwgIl9oYW5kbGVNYXJnaW5zIiwgImlzUm90YXRlZCIsICJsYWJlbHNCZWxvd1RpY2tzIiwgIm9mZnNldExlZnQiLCAib2Zmc2V0UmlnaHQiLCAiaXNGdWxsU2l6ZSIsICJfY29tcHV0ZUxhYmVsU2l6ZXMiLCAid2lkdGhzIiwgImhlaWdodHMiLCAid2lkZXN0TGFiZWxTaXplIiwgImhpZ2hlc3RMYWJlbFNpemUiLCAiamxlbiIsICJ0aWNrRm9udCIsICJmb250U3RyaW5nIiwgIm5lc3RlZExhYmVsIiwgIl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zIiwgInN0cmluZyIsICJfbWVhc3VyZVRleHQiLCAidmFsdWVBdCIsICJpZHgiLCAiZ2V0TGFiZWxGb3JWYWx1ZSIsICJOYU4iLCAiZ2V0VmFsdWVGb3JQaXhlbCIsICJwaXhlbCIsICJnZXRQaXhlbEZvckRlY2ltYWwiLCAiZGVjaW1hbCIsICJfaW50MTZSYW5nZSIsICJfYWxpZ25QaXhlbCIsICJnZXREZWNpbWFsRm9yUGl4ZWwiLCAiZ2V0QmFzZVBpeGVsIiwgImdldEJhc2VWYWx1ZSIsICJvcHRpb25UaWNrcyIsICJyb3QiLCAiYXV0b1NraXBQYWRkaW5nIiwgIl9jb21wdXRlR3JpZExpbmVJdGVtcyIsICJib3JkZXIiLCAidGwiLCAiYm9yZGVyT3B0cyIsICJheGlzV2lkdGgiLCAiYXhpc0hhbGZXaWR0aCIsICJhbGlnbkJvcmRlclZhbHVlIiwgImJvcmRlclZhbHVlIiwgImFsaWduZWRMaW5lVmFsdWUiLCAidHgxIiwgInR5MSIsICJ0eDIiLCAidHkyIiwgIngxIiwgInkxIiwgIngyIiwgInkyIiwgImxpbWl0IiwgInN0ZXAiLCAib3B0c0F0SW5kZXgiLCAib3B0c0F0SW5kZXhCb3JkZXIiLCAibGluZVdpZHRoIiwgImxpbmVDb2xvciIsICJjb2xvciIsICJib3JkZXJEYXNoIiwgImRhc2giLCAiYm9yZGVyRGFzaE9mZnNldCIsICJkYXNoT2Zmc2V0IiwgInRpY2tDb2xvciIsICJ0aWNrQm9yZGVyRGFzaCIsICJ0aWNrQm9yZGVyRGFzaE9mZnNldCIsICJjcm9zc0FsaWduIiwgInRpY2tBbmRQYWRkaW5nIiwgImhUaWNrQW5kUGFkZGluZyIsICJ0ZXh0QWxpZ24iLCAibGluZUNvdW50IiwgInRleHRPZmZzZXQiLCAidGV4dEJhc2VsaW5lIiwgIl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50IiwgIl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50IiwgImxhYmVsT2Zmc2V0IiwgImhhbGZDb3VudCIsICJzdHJva2VDb2xvciIsICJ0ZXh0U3Ryb2tlQ29sb3IiLCAic3Ryb2tlV2lkdGgiLCAidGV4dFN0cm9rZVdpZHRoIiwgInRpY2tUZXh0QWxpZ24iLCAic2hvd0xhYmVsQmFja2Ryb3AiLCAiYmFja2Ryb3AiLCAibGFiZWxQYWRkaW5nIiwgImJhY2tkcm9wUGFkZGluZyIsICJiYWNrZHJvcENvbG9yIiwgInRyYW5zbGF0aW9uIiwgIl9jb21wdXRlTGFiZWxBcmVhIiwgImRyYXdCYWNrZ3JvdW5kIiwgImJhY2tncm91bmRDb2xvciIsICJzYXZlIiwgImZpbGxTdHlsZSIsICJmaWxsUmVjdCIsICJyZXN0b3JlIiwgImdldExpbmVXaWR0aEZvclZhbHVlIiwgInQiLCAib3B0cyIsICJkcmF3R3JpZCIsICJkcmF3TGluZSIsICJwMSIsICJwMiIsICJzdHJva2VTdHlsZSIsICJzZXRMaW5lRGFzaCIsICJsaW5lRGFzaE9mZnNldCIsICJiZWdpblBhdGgiLCAibW92ZVRvIiwgImxpbmVUbyIsICJzdHJva2UiLCAiZHJhd09uQ2hhcnRBcmVhIiwgImRyYXdCb3JkZXIiLCAibGFzdExpbmVXaWR0aCIsICJkcmF3TGFiZWxzIiwgImFyZWEiLCAiY2xpcEFyZWEiLCAicmVuZGVyVGV4dE9wdGlvbnMiLCAicmVuZGVyVGV4dCIsICJ1bmNsaXBBcmVhIiwgImRyYXdUaXRsZSIsICJ0eiIsICJneiIsICJieiIsICJheGlzSUQiLCAiX21heERpZ2l0cyIsICJmb250U2l6ZSIsICJUeXBlZFJlZ2lzdHJ5IiwgInNjb3BlIiwgImNyZWF0ZSIsICJpc0ZvclR5cGUiLCAiaXNQcm90b3R5cGVPZiIsICJyZWdpc3RlciIsICJwcm90byIsICJnZXRQcm90b3R5cGVPZiIsICJwYXJlbnRTY29wZSIsICJpc0lDaGFydENvbXBvbmVudCIsICJyZWdpc3RlckRlZmF1bHRzIiwgIm92ZXJyaWRlcyIsICJnZXQiLCAidW5yZWdpc3RlciIsICJpdGVtRGVmYXVsdHMiLCAibWVyZ2UiLCAicm91dGVEZWZhdWx0cyIsICJkZXNjcmlwdG9ycyIsICJkZXNjcmliZSIsICJyb3V0ZXMiLCAicHJvcGVydHkiLCAicHJvcGVydHlQYXJ0cyIsICJzcGxpdCIsICJzb3VyY2VOYW1lIiwgInBvcCIsICJzb3VyY2VTY29wZSIsICJqb2luIiwgInBhcnRzIiwgInRhcmdldE5hbWUiLCAidGFyZ2V0U2NvcGUiLCAicm91dGUiLCAiUmVnaXN0cnkiLCAiY29udHJvbGxlcnMiLCAiRGF0YXNldENvbnRyb2xsZXIiLCAicGx1Z2lucyIsICJfdHlwZWRSZWdpc3RyaWVzIiwgImFyZ3MiLCAiX2VhY2giLCAicmVtb3ZlIiwgImFkZENvbnRyb2xsZXJzIiwgImFkZEVsZW1lbnRzIiwgImFkZFBsdWdpbnMiLCAiYWRkU2NhbGVzIiwgImdldENvbnRyb2xsZXIiLCAiX2dldCIsICJnZXRFbGVtZW50IiwgImdldFBsdWdpbiIsICJnZXRTY2FsZSIsICJyZW1vdmVDb250cm9sbGVycyIsICJyZW1vdmVFbGVtZW50cyIsICJyZW1vdmVQbHVnaW5zIiwgInJlbW92ZVNjYWxlcyIsICJtZXRob2QiLCAidHlwZWRSZWdpc3RyeSIsICJhcmciLCAicmVnIiwgIl9nZXRSZWdpc3RyeUZvclR5cGUiLCAiX2V4ZWMiLCAiaXRlbVJlZyIsICJyZWdpc3RyeSIsICJjb21wb25lbnQiLCAiY2FtZWxNZXRob2QiLCAiX2NhcGl0YWxpemUiLCAiUGx1Z2luU2VydmljZSIsICJfaW5pdCIsICJub3RpZnkiLCAiaG9vayIsICJfY3JlYXRlRGVzY3JpcHRvcnMiLCAiX25vdGlmeSIsICJfZGVzY3JpcHRvcnMiLCAiZGVzY3JpcHRvciIsICJwbHVnaW4iLCAiY2FsbENhbGxiYWNrIiwgImNhbmNlbGFibGUiLCAiaW52YWxpZGF0ZSIsICJfb2xkQ2FjaGUiLCAiX25vdGlmeVN0YXRlQ2hhbmdlcyIsICJhbGwiLCAiYWxsUGx1Z2lucyIsICJjcmVhdGVEZXNjcmlwdG9ycyIsICJwcmV2aW91c0Rlc2NyaXB0b3JzIiwgInNvbWUiLCAibG9jYWxJZHMiLCAibG9jYWwiLCAiZ2V0T3B0cyIsICJwbHVnaW5PcHRzIiwgInBsdWdpblNjb3BlS2V5cyIsICJzY29wZXMiLCAiZ2V0T3B0aW9uU2NvcGVzIiwgImNyZWF0ZVJlc29sdmVyIiwgInNjcmlwdGFibGUiLCAiaW5kZXhhYmxlIiwgImFsbEtleXMiLCAiZ2V0SW5kZXhBeGlzIiwgImRhdGFzZXREZWZhdWx0cyIsICJkYXRhc2V0cyIsICJkYXRhc2V0T3B0aW9ucyIsICJpbmRleEF4aXMiLCAiZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRCIsICJnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzIiwgImlkTWF0Y2hlc0F4aXMiLCAiYXhpc0Zyb21Qb3NpdGlvbiIsICJkZXRlcm1pbmVBeGlzIiwgInNjYWxlT3B0aW9ucyIsICJ0b0xvd2VyQ2FzZSIsICJnZXRBeGlzRnJvbURhdGFzZXQiLCAicmV0cmlldmVBeGlzRnJvbURhdGFzZXRzIiwgImJvdW5kRHMiLCAiZCIsICJ4QXhpc0lEIiwgInlBeGlzSUQiLCAibWVyZ2VTY2FsZUNvbmZpZyIsICJjaGFydERlZmF1bHRzIiwgImNvbmZpZ1NjYWxlcyIsICJjaGFydEluZGV4QXhpcyIsICJzY2FsZUNvbmYiLCAiY29uc29sZSIsICJlcnJvciIsICJfcHJveHkiLCAid2FybiIsICJkZWZhdWx0SWQiLCAiZGVmYXVsdFNjYWxlT3B0aW9ucyIsICJtZXJnZUlmIiwgImRlZmF1bHRJRCIsICJpbml0T3B0aW9ucyIsICJpbml0RGF0YSIsICJpbml0Q29uZmlnIiwgImtleUNhY2hlIiwgImtleXNDYWNoZWQiLCAiU2V0IiwgImNhY2hlZEtleXMiLCAiY2FjaGVLZXkiLCAiZ2VuZXJhdGUiLCAiYWRkSWZGb3VuZCIsICJvYmoiLCAicmVzb2x2ZU9iamVjdEtleSIsICJDb25maWciLCAiX2NvbmZpZyIsICJfc2NvcGVDYWNoZSIsICJfcmVzb2x2ZXJDYWNoZSIsICJwbGF0Zm9ybSIsICJjbGVhckNhY2hlIiwgImNsZWFyIiwgImRhdGFzZXRTY29wZUtleXMiLCAiZGF0YXNldFR5cGUiLCAiZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyIsICJ0cmFuc2l0aW9uIiwgImRhdGFzZXRFbGVtZW50U2NvcGVLZXlzIiwgImVsZW1lbnRUeXBlIiwgImFkZGl0aW9uYWxPcHRpb25TY29wZXMiLCAiX2NhY2hlZFNjb3BlcyIsICJtYWluU2NvcGUiLCAicmVzZXRDYWNoZSIsICJrZXlMaXN0cyIsICJjYWNoZWQiLCAiQXJyYXkiLCAiZnJvbSIsICJoYXMiLCAiY2hhcnRPcHRpb25TY29wZXMiLCAicmVzb2x2ZU5hbWVkT3B0aW9ucyIsICJuYW1lcyIsICJwcmVmaXhlcyIsICIkc2hhcmVkIiwgInJlc29sdmVyIiwgInN1YlByZWZpeGVzIiwgImdldFJlc29sdmVyIiwgIm5lZWRDb250ZXh0IiwgImlzRnVuY3Rpb24iLCAic3ViUmVzb2x2ZXIiLCAiX2F0dGFjaENvbnRleHQiLCAiZGVzY3JpcHRvckRlZmF1bHRzIiwgInJlc29sdmVyQ2FjaGUiLCAiX2NyZWF0ZVJlc29sdmVyIiwgInAiLCAiaGFzRnVuY3Rpb24iLCAiZ2V0T3duUHJvcGVydHlOYW1lcyIsICJpc1NjcmlwdGFibGUiLCAiaXNJbmRleGFibGUiLCAiS05PV05fUE9TSVRJT05TIiwgInBvc2l0aW9uSXNIb3Jpem9udGFsIiwgImNvbXBhcmUyTGV2ZWwiLCAibDEiLCAibDIiLCAib25BbmltYXRpb25zQ29tcGxldGUiLCAiYW5pbWF0aW9uT3B0aW9ucyIsICJvbkNvbXBsZXRlIiwgIm9uQW5pbWF0aW9uUHJvZ3Jlc3MiLCAib25Qcm9ncmVzcyIsICJnZXRDYW52YXMiLCAiZ2V0RWxlbWVudEJ5SWQiLCAiaW5zdGFuY2VzIiwgImdldENoYXJ0IiwgInZhbHVlcyIsICJjIiwgIm1vdmVOdW1lcmljS2V5cyIsICJtb3ZlIiwgImludEtleSIsICJkZXRlcm1pbmVMYXN0RXZlbnQiLCAibGFzdEV2ZW50IiwgImluQ2hhcnRBcmVhIiwgImlzQ2xpY2siLCAiZ2V0U2l6ZUZvckFyZWEiLCAiZmllbGQiLCAiY2xpcCIsICJnZXREYXRhc2V0QXJlYSIsICJ4U2NhbGUiLCAieVNjYWxlIiwgIkNoYXJ0IiwgImludmFsaWRhdGVQbHVnaW5zIiwgInVzZXJDb25maWciLCAiaW5pdGlhbENhbnZhcyIsICJleGlzdGluZ0NoYXJ0IiwgInVpZCIsICJfb3B0aW9ucyIsICJfYXNwZWN0UmF0aW8iLCAiX21ldGFzZXRzIiwgIl9zdGFja3MiLCAiX2FjdGl2ZSIsICJfbGFzdEV2ZW50IiwgIl9saXN0ZW5lcnMiLCAiX3Jlc3BvbnNpdmVMaXN0ZW5lcnMiLCAiX3NvcnRlZE1ldGFzZXRzIiwgIl9wbHVnaW5zIiwgIl9oaWRkZW5JbmRpY2VzIiwgImF0dGFjaGVkIiwgIl9hbmltYXRpb25zRGlzYWJsZWQiLCAiX2RvUmVzaXplIiwgImRlYm91bmNlIiwgIm1vZGUiLCAicmVzaXplRGVsYXkiLCAiX2RhdGFDaGFuZ2VzIiwgImFuaW1hdG9yIiwgImxpc3RlbiIsICJfaW5pdGlhbGl6ZSIsICJtYWludGFpbkFzcGVjdFJhdGlvIiwgInJlc3BvbnNpdmUiLCAicmV0aW5hU2NhbGUiLCAiYmluZEV2ZW50cyIsICJjbGVhckNhbnZhcyIsICJzdG9wIiwgInJ1bm5pbmciLCAiX3Jlc2l6ZSIsICJfcmVzaXplQmVmb3JlRHJhdyIsICJuZXdTaXplIiwgIm5ld1JhdGlvIiwgIm9uUmVzaXplIiwgInJlbmRlciIsICJlbnN1cmVTY2FsZXNIYXZlSURzIiwgInNjYWxlc09wdGlvbnMiLCAiYXhpc09wdGlvbnMiLCAiYnVpbGRPclVwZGF0ZVNjYWxlcyIsICJzY2FsZU9wdHMiLCAidXBkYXRlZCIsICJtYXAiLCAiaXNSYWRpYWwiLCAiZHBvc2l0aW9uIiwgImR0eXBlIiwgInNjYWxlVHlwZSIsICJzY2FsZUNsYXNzIiwgImhhc1VwZGF0ZWQiLCAiX3VwZGF0ZU1ldGFzZXRzIiwgIm51bURhdGEiLCAibnVtTWV0YSIsICJfZGVzdHJveURhdGFzZXRNZXRhIiwgIl9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cyIsICJfZGF0YXNldCIsICJidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMiLCAibmV3Q29udHJvbGxlcnMiLCAib3JkZXIiLCAidmlzaWJsZSIsICJpc0RhdGFzZXRWaXNpYmxlIiwgInVwZGF0ZUluZGV4IiwgImxpbmtTY2FsZXMiLCAiQ29udHJvbGxlckNsYXNzIiwgImRhdGFzZXRFbGVtZW50VHlwZSIsICJkYXRhRWxlbWVudFR5cGUiLCAiX3Jlc2V0RWxlbWVudHMiLCAicmVzZXQiLCAiYW5pbXNEaXNhYmxlZCIsICJfdXBkYXRlU2NhbGVzIiwgIl9jaGVja0V2ZW50QmluZGluZ3MiLCAiX3VwZGF0ZUhpZGRlbkluZGljZXMiLCAiYnVpbGRPclVwZGF0ZUVsZW1lbnRzIiwgImdldE1heE92ZXJmbG93IiwgIl9taW5QYWRkaW5nIiwgImF1dG9QYWRkaW5nIiwgIl91cGRhdGVMYXlvdXQiLCAiX3VwZGF0ZURhdGFzZXRzIiwgIl9ldmVudEhhbmRsZXIiLCAiX3VwZGF0ZUhvdmVyU3R5bGVzIiwgImV4aXN0aW5nRXZlbnRzIiwgIm5ld0V2ZW50cyIsICJldmVudHMiLCAic2V0c0VxdWFsIiwgInVuYmluZEV2ZW50cyIsICJjaGFuZ2VzIiwgIl9nZXRVbmlmb3JtRGF0YUNoYW5nZXMiLCAiZGF0YXNldENvdW50IiwgIm1ha2VTZXQiLCAiY2hhbmdlU2V0IiwgIm5vQXJlYSIsICJfaWR4IiwgIl91cGRhdGVEYXRhc2V0IiwgIl91cGRhdGUiLCAibGF5ZXJzIiwgIl9kcmF3RGF0YXNldHMiLCAiX2dldFNvcnRlZERhdGFzZXRNZXRhcyIsICJmaWx0ZXJWaXNpYmxlIiwgIl9kcmF3RGF0YXNldCIsICJfY2xpcCIsICJ1c2VDbGlwIiwgImRpc2FibGVkIiwgImdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUiLCAiSW50ZXJhY3Rpb24iLCAiaGlkZGVuIiwgImdldFZpc2libGVEYXRhc2V0Q291bnQiLCAic2V0RGF0YXNldFZpc2liaWxpdHkiLCAidG9nZ2xlRGF0YVZpc2liaWxpdHkiLCAiZ2V0RGF0YVZpc2liaWxpdHkiLCAiX3VwZGF0ZVZpc2liaWxpdHkiLCAiZGF0YUluZGV4IiwgIl9yZXNvbHZlQW5pbWF0aW9ucyIsICJoaWRlIiwgInNob3ciLCAiX2Rlc3Ryb3kiLCAiX3N0b3AiLCAiZGVzdHJveSIsICJ0b0Jhc2U2NEltYWdlIiwgInRvRGF0YVVSTCIsICJiaW5kVXNlckV2ZW50cyIsICJiaW5kUmVzcG9uc2l2ZUV2ZW50cyIsICJsaXN0ZW5lcnMiLCAiX2FkZCIsICJvZmZzZXRYIiwgIm9mZnNldFkiLCAiX3JlbW92ZSIsICJkZXRhY2hlZCIsICJ1cGRhdGVIb3ZlclN0eWxlIiwgInByZWZpeCIsICJnZXRBY3RpdmVFbGVtZW50cyIsICJzZXRBY3RpdmVFbGVtZW50cyIsICJhY3RpdmVFbGVtZW50cyIsICJsYXN0QWN0aXZlIiwgIl9lbGVtZW50c0VxdWFsIiwgImlzUGx1Z2luRW5hYmxlZCIsICJwbHVnaW5JZCIsICJyZXBsYXkiLCAiaG92ZXJPcHRpb25zIiwgImhvdmVyIiwgImRlYWN0aXZhdGVkIiwgImFjdGl2YXRlZCIsICJldmVudEZpbHRlciIsICJfaGFuZGxlRXZlbnQiLCAiX2dldEFjdGl2ZUVsZW1lbnRzIiwgIl9pc0NsaWNrRXZlbnQiLCAib25Ib3ZlciIsICJvbkNsaWNrIiwgInZlcnNpb24iLCAiY2xpcEFyYyIsICJwaXhlbE1hcmdpbiIsICJvdXRlclJhZGl1cyIsICJpbm5lclJhZGl1cyIsICJhbmdsZU1hcmdpbiIsICJhcmMiLCAiY2xvc2VQYXRoIiwgInRvUmFkaXVzQ29ybmVycyIsICJfcmVhZFZhbHVlVG9Qcm9wcyIsICJwYXJzZUJvcmRlclJhZGl1cyIsICJhbmdsZURlbHRhIiwgIm8iLCAiYm9yZGVyUmFkaXVzIiwgImhhbGZUaGlja25lc3MiLCAiaW5uZXJMaW1pdCIsICJjb21wdXRlT3V0ZXJMaW1pdCIsICJ2YWwiLCAib3V0ZXJBcmNMaW1pdCIsICJvdXRlclN0YXJ0IiwgIm91dGVyRW5kIiwgImlubmVyU3RhcnQiLCAiaW5uZXJFbmQiLCAiclRoZXRhVG9YWSIsICJyIiwgInRoZXRhIiwgInBhdGhBcmMiLCAiY2lyY3VsYXIiLCAiaW5uZXJSIiwgInNwYWNpbmdPZmZzZXQiLCAiYWxwaGEiLCAibm9TcGFjaW5nSW5uZXJSYWRpdXMiLCAibm9TcGFjaW5nT3V0ZXJSYWRpdXMiLCAiYXZOb2dTcGFjaW5nUmFkaXVzIiwgImFkanVzdGVkQW5nbGUiLCAiYmV0YSIsICJQSSIsICJhbmdsZU9mZnNldCIsICJvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMiLCAib3V0ZXJFbmRBZGp1c3RlZFJhZGl1cyIsICJvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSIsICJvdXRlckVuZEFkanVzdGVkQW5nbGUiLCAiaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzIiwgImlubmVyRW5kQWRqdXN0ZWRSYWRpdXMiLCAiaW5uZXJTdGFydEFkanVzdGVkQW5nbGUiLCAiaW5uZXJFbmRBZGp1c3RlZEFuZ2xlIiwgIm91dGVyTWlkQWRqdXN0ZWRBbmdsZSIsICJwQ2VudGVyIiwgInA0IiwgImlubmVyTWlkQWRqdXN0ZWRBbmdsZSIsICJwOCIsICJvdXRlclN0YXJ0WCIsICJvdXRlclN0YXJ0WSIsICJvdXRlckVuZFgiLCAib3V0ZXJFbmRZIiwgImRyYXdBcmMiLCAiZnVsbENpcmNsZXMiLCAiY2lyY3VtZmVyZW5jZSIsICJmaWxsIiwgImlzTmFOIiwgIlRBVSIsICJib3JkZXJXaWR0aCIsICJib3JkZXJKb2luU3R5bGUiLCAiaW5uZXIiLCAiYm9yZGVyQWxpZ24iLCAibGluZUpvaW4iLCAiQXJjRWxlbWVudCIsICJjaGFydFgiLCAiY2hhcnRZIiwgInJBZGp1c3QiLCAiX2NpcmN1bWZlcmVuY2UiLCAibm9uWmVyb0JldHdlZW4iLCAiYmV0d2VlbkFuZ2xlcyIsICJ3aXRoaW5SYWRpdXMiLCAiX2lzQmV0d2VlbiIsICJoYWxmQW5nbGUiLCAiaGFsZlJhZGl1cyIsICJ0cmFuc2xhdGUiLCAiZml4IiwgInJhZGl1c09mZnNldCIsICJib3JkZXJDb2xvciIsICJfc2NyaXB0YWJsZSIsICJfaW5kZXhhYmxlIiwgImdldEJhckJvdW5kcyIsICJiYXIiLCAidXNlRmluYWxQb3NpdGlvbiIsICJ4IiwgInkiLCAiYmFzZSIsICJ3aWR0aCIsICJoZWlnaHQiLCAiZ2V0UHJvcHMiLCAibGVmdCIsICJyaWdodCIsICJ0b3AiLCAiYm90dG9tIiwgImhhbGYiLCAiaG9yaXpvbnRhbCIsICJNYXRoIiwgIm1pbiIsICJtYXgiLCAic2tpcE9yTGltaXQiLCAic2tpcCIsICJ2YWx1ZSIsICJfbGltaXRWYWx1ZSIsICJwYXJzZUJvcmRlcldpZHRoIiwgIm1heFciLCAibWF4SCIsICJvcHRpb25zIiwgImJvcmRlcldpZHRoIiwgImJvcmRlclNraXBwZWQiLCAibyIsICJ0b1RSQkwiLCAidCIsICJyIiwgImIiLCAibCIsICJwYXJzZUJvcmRlclJhZGl1cyIsICJlbmFibGVCb3JkZXJSYWRpdXMiLCAiYm9yZGVyUmFkaXVzIiwgInRvVFJCTENvcm5lcnMiLCAibWF4UiIsICJlbmFibGVCb3JkZXIiLCAiaXNPYmplY3QiLCAidG9wTGVmdCIsICJ0b3BSaWdodCIsICJib3R0b21MZWZ0IiwgImJvdHRvbVJpZ2h0IiwgImJvdW5kaW5nUmVjdHMiLCAiYm91bmRzIiwgImJvcmRlciIsICJyYWRpdXMiLCAib3V0ZXIiLCAidyIsICJoIiwgImlubmVyIiwgImluUmFuZ2UiLCAic2tpcFgiLCAic2tpcFkiLCAic2tpcEJvdGgiLCAiX2lzQmV0d2VlbiIsICJoYXNSYWRpdXMiLCAiYWRkTm9ybWFsUmVjdFBhdGgiLCAiY3R4IiwgInJlY3QiLCAiaW5mbGF0ZVJlY3QiLCAiYW1vdW50IiwgInJlZlJlY3QiLCAiQmFyRWxlbWVudCIsICJFbGVtZW50IiwgImNvbnN0cnVjdG9yIiwgImNmZyIsICJ1bmRlZmluZWQiLCAiaW5mbGF0ZUFtb3VudCIsICJPYmplY3QiLCAiYXNzaWduIiwgImRyYXciLCAiYm9yZGVyQ29sb3IiLCAiYmFja2dyb3VuZENvbG9yIiwgImFkZFJlY3RQYXRoIiwgImFkZFJvdW5kZWRSZWN0UGF0aCIsICJzYXZlIiwgImJlZ2luUGF0aCIsICJjbGlwIiwgImZpbGxTdHlsZSIsICJmaWxsIiwgInJlc3RvcmUiLCAibW91c2VYIiwgIm1vdXNlWSIsICJpblhSYW5nZSIsICJpbllSYW5nZSIsICJnZXRDZW50ZXJQb2ludCIsICJnZXRSYW5nZSIsICJheGlzIiwgImlkIiwgImRlZmF1bHRzIiwgInBvaW50U3R5bGUiLCAiZGVmYXVsdFJvdXRlcyIsICJnZXRCb3hTaXplIiwgImxhYmVsT3B0cyIsICJmb250U2l6ZSIsICJib3hIZWlnaHQiLCAiYm94V2lkdGgiLCAidXNlUG9pbnRTdHlsZSIsICJNYXRoIiwgIm1pbiIsICJwb2ludFN0eWxlV2lkdGgiLCAiaXRlbUhlaWdodCIsICJtYXgiLCAiaXRlbXNFcXVhbCIsICJhIiwgImIiLCAiZGF0YXNldEluZGV4IiwgImluZGV4IiwgIkxlZ2VuZCIsICJFbGVtZW50IiwgImNvbnN0cnVjdG9yIiwgImNvbmZpZyIsICJfYWRkZWQiLCAibGVnZW5kSGl0Qm94ZXMiLCAiX2hvdmVyZWRJdGVtIiwgImRvdWdobnV0TW9kZSIsICJjaGFydCIsICJvcHRpb25zIiwgImN0eCIsICJsZWdlbmRJdGVtcyIsICJ1bmRlZmluZWQiLCAiY29sdW1uU2l6ZXMiLCAibGluZVdpZHRocyIsICJtYXhIZWlnaHQiLCAibWF4V2lkdGgiLCAidG9wIiwgImJvdHRvbSIsICJsZWZ0IiwgInJpZ2h0IiwgImhlaWdodCIsICJ3aWR0aCIsICJfbWFyZ2lucyIsICJwb3NpdGlvbiIsICJ3ZWlnaHQiLCAiZnVsbFNpemUiLCAidXBkYXRlIiwgIm1hcmdpbnMiLCAic2V0RGltZW5zaW9ucyIsICJidWlsZExhYmVscyIsICJmaXQiLCAiaXNIb3Jpem9udGFsIiwgImxhYmVscyIsICJjYWxsIiwgImdlbmVyYXRlTGFiZWxzIiwgImZpbHRlciIsICJpdGVtIiwgImRhdGEiLCAic29ydCIsICJyZXZlcnNlIiwgImRpc3BsYXkiLCAibGFiZWxGb250IiwgInRvRm9udCIsICJmb250IiwgInNpemUiLCAidGl0bGVIZWlnaHQiLCAiX2NvbXB1dGVUaXRsZUhlaWdodCIsICJzdHJpbmciLCAiX2ZpdFJvd3MiLCAiX2ZpdENvbHMiLCAicGFkZGluZyIsICJoaXRib3hlcyIsICJsaW5lSGVpZ2h0IiwgInRvdGFsSGVpZ2h0IiwgInRleHRBbGlnbiIsICJ0ZXh0QmFzZWxpbmUiLCAicm93IiwgImZvckVhY2giLCAibGVnZW5kSXRlbSIsICJpIiwgIml0ZW1XaWR0aCIsICJtZWFzdXJlVGV4dCIsICJ0ZXh0IiwgImxlbmd0aCIsICJfaXRlbUhlaWdodCIsICJoZWlnaHRMaW1pdCIsICJ0b3RhbFdpZHRoIiwgImN1cnJlbnRDb2xXaWR0aCIsICJjdXJyZW50Q29sSGVpZ2h0IiwgImNvbCIsICJjYWxjdWxhdGVJdGVtU2l6ZSIsICJwdXNoIiwgImFkanVzdEhpdEJveGVzIiwgImFsaWduIiwgInJ0bCIsICJydGxIZWxwZXIiLCAiZ2V0UnRsQWRhcHRlciIsICJfYWxpZ25TdGFydEVuZCIsICJoaXRib3giLCAibGVmdEZvckx0ciIsICJ4IiwgImRyYXciLCAiY2xpcEFyZWEiLCAiX2RyYXciLCAidW5jbGlwQXJlYSIsICJvcHRzIiwgImRlZmF1bHRDb2xvciIsICJkZWZhdWx0cyIsICJjb2xvciIsICJoYWxmRm9udFNpemUiLCAiY3Vyc29yIiwgImRyYXdUaXRsZSIsICJsaW5lV2lkdGgiLCAiZHJhd0xlZ2VuZEJveCIsICJ5IiwgImlzTmFOIiwgInNhdmUiLCAidmFsdWVPckRlZmF1bHQiLCAiZmlsbFN0eWxlIiwgImxpbmVDYXAiLCAibGluZURhc2hPZmZzZXQiLCAibGluZUpvaW4iLCAic3Ryb2tlU3R5bGUiLCAic2V0TGluZURhc2giLCAibGluZURhc2giLCAiZHJhd09wdGlvbnMiLCAicmFkaXVzIiwgIlNRUlQyIiwgInBvaW50U3R5bGUiLCAicm90YXRpb24iLCAiYm9yZGVyV2lkdGgiLCAiY2VudGVyWCIsICJ4UGx1cyIsICJjZW50ZXJZIiwgImRyYXdQb2ludExlZ2VuZCIsICJ5Qm94VG9wIiwgInhCb3hMZWZ0IiwgImJvcmRlclJhZGl1cyIsICJ0b1RSQkxDb3JuZXJzIiwgImJlZ2luUGF0aCIsICJPYmplY3QiLCAidmFsdWVzIiwgInNvbWUiLCAidiIsICJhZGRSb3VuZGVkUmVjdFBhdGgiLCAidyIsICJoIiwgInJlY3QiLCAiZmlsbCIsICJzdHJva2UiLCAicmVzdG9yZSIsICJmaWxsVGV4dCIsICJyZW5kZXJUZXh0IiwgInN0cmlrZXRocm91Z2giLCAiaGlkZGVuIiwgImxpbmUiLCAib3ZlcnJpZGVUZXh0RGlyZWN0aW9uIiwgInRleHREaXJlY3Rpb24iLCAiZm9udENvbG9yIiwgInRleHRXaWR0aCIsICJzZXRXaWR0aCIsICJyZWFsWCIsICJfdGV4dFgiLCAiZm9udExpbmVIZWlnaHQiLCAiY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodCIsICJyZXN0b3JlVGV4dERpcmVjdGlvbiIsICJ0aXRsZU9wdHMiLCAidGl0bGUiLCAidGl0bGVGb250IiwgInRpdGxlUGFkZGluZyIsICJ0b1BhZGRpbmciLCAidG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUiLCAicmVkdWNlIiwgImFjYyIsICJfdG9MZWZ0UmlnaHRDZW50ZXIiLCAiX2dldExlZ2VuZEl0ZW1BdCIsICJoaXRCb3giLCAibGgiLCAiX2lzQmV0d2VlbiIsICJoYW5kbGVFdmVudCIsICJlIiwgImlzTGlzdGVuZWQiLCAidHlwZSIsICJob3ZlcmVkSXRlbSIsICJwcmV2aW91cyIsICJzYW1lSXRlbSIsICJvbkxlYXZlIiwgIm9uSG92ZXIiLCAib25DbGljayIsICJjYWxjdWxhdGVJdGVtV2lkdGgiLCAiY2FsY3VsYXRlSXRlbUhlaWdodCIsICJsZWdlbmRJdGVtVGV4dCIsICJsYWJlbEhlaWdodCIsICJpZCIsICJfZWxlbWVudCIsICJzdGFydCIsICJfYXJncyIsICJsZWdlbmQiLCAibGF5b3V0cyIsICJjb25maWd1cmUiLCAiYWRkQm94IiwgInN0b3AiLCAicmVtb3ZlQm94IiwgImJlZm9yZVVwZGF0ZSIsICJhZnRlclVwZGF0ZSIsICJhZnRlckV2ZW50IiwgImFyZ3MiLCAicmVwbGF5IiwgImV2ZW50IiwgImNpIiwgImlzRGF0YXNldFZpc2libGUiLCAiaGlkZSIsICJzaG93IiwgImRhdGFzZXRzIiwgInVzZUJvcmRlclJhZGl1cyIsICJfZ2V0U29ydGVkRGF0YXNldE1ldGFzIiwgIm1hcCIsICJtZXRhIiwgInN0eWxlIiwgImNvbnRyb2xsZXIiLCAiZ2V0U3R5bGUiLCAibGFiZWwiLCAiYmFja2dyb3VuZENvbG9yIiwgInZpc2libGUiLCAiYm9yZGVyQ2FwU3R5bGUiLCAiYm9yZGVyRGFzaCIsICJib3JkZXJEYXNoT2Zmc2V0IiwgImJvcmRlckpvaW5TdHlsZSIsICJib3JkZXJDb2xvciIsICJkZXNjcmlwdG9ycyIsICJfc2NyaXB0YWJsZSIsICJuYW1lIiwgInN0YXJ0c1dpdGgiLCAiaW5jbHVkZXMiLCAiVGl0bGUiLCAiX3BhZGRpbmciLCAibGluZUNvdW50IiwgImlzQXJyYXkiLCAidGV4dFNpemUiLCAicG9zIiwgIl9kcmF3QXJncyIsICJvZmZzZXQiLCAidGl0bGVYIiwgInRpdGxlWSIsICJQSSIsICJmb250T3B0cyIsICJ0cmFuc2xhdGlvbiIsICJjcmVhdGVUaXRsZSIsICJ0aXRsZUJsb2NrIiwgImRlZmF1bHRSb3V0ZXMiLCAiX2luZGV4YWJsZSIsICJXZWFrTWFwIiwgInNldCIsICJnZXQiLCAiZGVsZXRlIiwgInBvc2l0aW9uZXJzIiwgImF2ZXJhZ2UiLCAiaXRlbXMiLCAibGVuIiwgInhTZXQiLCAiU2V0IiwgImNvdW50IiwgImVsIiwgImVsZW1lbnQiLCAiaGFzVmFsdWUiLCAidG9vbHRpcFBvc2l0aW9uIiwgImFkZCIsICJ4QXZlcmFnZSIsICJuZWFyZXN0IiwgImV2ZW50UG9zaXRpb24iLCAibWluRGlzdGFuY2UiLCAiTnVtYmVyIiwgIlBPU0lUSVZFX0lORklOSVRZIiwgIm5lYXJlc3RFbGVtZW50IiwgImNlbnRlciIsICJnZXRDZW50ZXJQb2ludCIsICJkIiwgImRpc3RhbmNlQmV0d2VlblBvaW50cyIsICJ0cCIsICJwdXNoT3JDb25jYXQiLCAiYmFzZSIsICJ0b1B1c2giLCAiQXJyYXkiLCAicHJvdG90eXBlIiwgImFwcGx5IiwgInNwbGl0TmV3bGluZXMiLCAic3RyIiwgIlN0cmluZyIsICJpbmRleE9mIiwgInNwbGl0IiwgImNyZWF0ZVRvb2x0aXBJdGVtIiwgImdldERhdGFzZXRNZXRhIiwgInZhbHVlIiwgImdldExhYmVsQW5kVmFsdWUiLCAicGFyc2VkIiwgImdldFBhcnNlZCIsICJyYXciLCAiZm9ybWF0dGVkVmFsdWUiLCAiZGF0YXNldCIsICJnZXREYXRhc2V0IiwgImRhdGFJbmRleCIsICJnZXRUb29sdGlwU2l6ZSIsICJ0b29sdGlwIiwgImJvZHkiLCAiZm9vdGVyIiwgImJvZHlGb250IiwgImZvb3RlckZvbnQiLCAidGl0bGVMaW5lQ291bnQiLCAiZm9vdGVyTGluZUNvdW50IiwgImJvZHlMaW5lSXRlbUNvdW50IiwgImNvbWJpbmVkQm9keUxlbmd0aCIsICJib2R5SXRlbSIsICJiZWZvcmUiLCAibGluZXMiLCAiYWZ0ZXIiLCAiYmVmb3JlQm9keSIsICJhZnRlckJvZHkiLCAidGl0bGVTcGFjaW5nIiwgInRpdGxlTWFyZ2luQm90dG9tIiwgImJvZHlMaW5lSGVpZ2h0IiwgImRpc3BsYXlDb2xvcnMiLCAiYm9keVNwYWNpbmciLCAiZm9vdGVyTWFyZ2luVG9wIiwgImZvb3RlclNwYWNpbmciLCAid2lkdGhQYWRkaW5nIiwgIm1heExpbmVXaWR0aCIsICJlYWNoIiwgImNvbmNhdCIsICJib3hQYWRkaW5nIiwgImRldGVybWluZVlBbGlnbiIsICJkb2VzTm90Rml0V2l0aEFsaWduIiwgInhBbGlnbiIsICJjYXJldCIsICJjYXJldFNpemUiLCAiY2FyZXRQYWRkaW5nIiwgImRldGVybWluZVhBbGlnbiIsICJ5QWxpZ24iLCAiY2hhcnRXaWR0aCIsICJjaGFydEFyZWEiLCAiZGV0ZXJtaW5lQWxpZ25tZW50IiwgImFsaWduWCIsICJhbGlnblkiLCAicGFkZGluZ0FuZFNpemUiLCAiZ2V0QmFja2dyb3VuZFBvaW50IiwgImFsaWdubWVudCIsICJjb3JuZXJSYWRpdXMiLCAidG9wTGVmdCIsICJ0b3BSaWdodCIsICJib3R0b21MZWZ0IiwgImJvdHRvbVJpZ2h0IiwgIl9saW1pdFZhbHVlIiwgImdldEFsaWduZWRYIiwgImdldEJlZm9yZUFmdGVyQm9keUxpbmVzIiwgImNhbGxiYWNrIiwgImNyZWF0ZVRvb2x0aXBDb250ZXh0IiwgInBhcmVudCIsICJ0b29sdGlwSXRlbXMiLCAiY3JlYXRlQ29udGV4dCIsICJvdmVycmlkZUNhbGxiYWNrcyIsICJjYWxsYmFja3MiLCAiY29udGV4dCIsICJvdmVycmlkZSIsICJkZWZhdWx0Q2FsbGJhY2tzIiwgImJlZm9yZVRpdGxlIiwgIm5vb3AiLCAibGFiZWxDb3VudCIsICJtb2RlIiwgImFmdGVyVGl0bGUiLCAiYmVmb3JlTGFiZWwiLCAidG9vbHRpcEl0ZW0iLCAiaXNOdWxsT3JVbmRlZiIsICJsYWJlbENvbG9yIiwgImxhYmVsVGV4dENvbG9yIiwgImJvZHlDb2xvciIsICJsYWJlbFBvaW50U3R5bGUiLCAiYWZ0ZXJMYWJlbCIsICJiZWZvcmVGb290ZXIiLCAiYWZ0ZXJGb290ZXIiLCAiaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2siLCAiYXJnIiwgInJlc3VsdCIsICJUb29sdGlwIiwgIm9wYWNpdHkiLCAiX2FjdGl2ZSIsICJfZXZlbnRQb3NpdGlvbiIsICJfc2l6ZSIsICJfY2FjaGVkQW5pbWF0aW9ucyIsICJfdG9vbHRpcEl0ZW1zIiwgIiRhbmltYXRpb25zIiwgIiRjb250ZXh0IiwgImRhdGFQb2ludHMiLCAiY2FyZXRYIiwgImNhcmV0WSIsICJsYWJlbENvbG9ycyIsICJsYWJlbFBvaW50U3R5bGVzIiwgImxhYmVsVGV4dENvbG9ycyIsICJpbml0aWFsaXplIiwgIl9yZXNvbHZlQW5pbWF0aW9ucyIsICJjYWNoZWQiLCAic2V0Q29udGV4dCIsICJnZXRDb250ZXh0IiwgImVuYWJsZWQiLCAiYW5pbWF0aW9uIiwgImFuaW1hdGlvbnMiLCAiQW5pbWF0aW9ucyIsICJfY2FjaGVhYmxlIiwgImZyZWV6ZSIsICJnZXRUaXRsZSIsICJnZXRCZWZvcmVCb2R5IiwgImdldEJvZHkiLCAiYm9keUl0ZW1zIiwgInNjb3BlZCIsICJnZXRBZnRlckJvZHkiLCAiZ2V0Rm9vdGVyIiwgIl9jcmVhdGVJdGVtcyIsICJhY3RpdmUiLCAiYXJyYXkiLCAiaXRlbVNvcnQiLCAiY2hhbmdlZCIsICJwcm9wZXJ0aWVzIiwgInBvc2l0aW9uQW5kU2l6ZSIsICJhc3NpZ24iLCAiYmFja2dyb3VuZFBvaW50IiwgImV4dGVybmFsIiwgImRyYXdDYXJldCIsICJ0b29sdGlwUG9pbnQiLCAiY2FyZXRQb3NpdGlvbiIsICJnZXRDYXJldFBvc2l0aW9uIiwgImxpbmVUbyIsICJ4MSIsICJ5MSIsICJ4MiIsICJ5MiIsICJ4MyIsICJ5MyIsICJwdFgiLCAicHRZIiwgInB0IiwgInRpdGxlQWxpZ24iLCAidGl0bGVDb2xvciIsICJfZHJhd0NvbG9yQm94IiwgImNvbG9yWCIsICJydGxDb2xvclgiLCAieU9mZlNldCIsICJjb2xvclkiLCAibXVsdGlLZXlCYWNrZ3JvdW5kIiwgImRyYXdQb2ludCIsICJpc09iamVjdCIsICJvdXRlclgiLCAiaW5uZXJYIiwgImZpbGxSZWN0IiwgInN0cm9rZVJlY3QiLCAiZHJhd0JvZHkiLCAiYm9keUFsaWduIiwgInhMaW5lUGFkZGluZyIsICJmaWxsTGluZU9mVGV4dCIsICJib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiIsICJ0ZXh0Q29sb3IiLCAiaiIsICJpbGVuIiwgImpsZW4iLCAiZHJhd0Zvb3RlciIsICJmb290ZXJBbGlnbiIsICJmb290ZXJDb2xvciIsICJkcmF3QmFja2dyb3VuZCIsICJ0b29sdGlwU2l6ZSIsICJtb3ZlVG8iLCAicXVhZHJhdGljQ3VydmVUbyIsICJjbG9zZVBhdGgiLCAiX3VwZGF0ZUFuaW1hdGlvblRhcmdldCIsICJhbmltcyIsICJhbmltWCIsICJhbmltWSIsICJwb2ludCIsICJfdG8iLCAiX3dpbGxSZW5kZXIiLCAiYWJzIiwgImhhc1Rvb2x0aXBDb250ZW50IiwgImdsb2JhbEFscGhhIiwgImdldEFjdGl2ZUVsZW1lbnRzIiwgInNldEFjdGl2ZUVsZW1lbnRzIiwgImFjdGl2ZUVsZW1lbnRzIiwgImxhc3RBY3RpdmUiLCAiRXJyb3IiLCAiX2VsZW1lbnRzRXF1YWwiLCAicG9zaXRpb25DaGFuZ2VkIiwgIl9wb3NpdGlvbkNoYW5nZWQiLCAiX2lnbm9yZVJlcGxheUV2ZW50cyIsICJpbkNoYXJ0QXJlYSIsICJfZ2V0QWN0aXZlRWxlbWVudHMiLCAiZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZSIsICJhZnRlckluaXQiLCAicmVzZXQiLCAiYWZ0ZXJEcmF3IiwgIm5vdGlmeVBsdWdpbnMiLCAiY2FuY2VsYWJsZSIsICJ1c2VGaW5hbFBvc2l0aW9uIiwgImR1cmF0aW9uIiwgImVhc2luZyIsICJudW1iZXJzIiwgIl9mYWxsYmFjayIsICJhZGRpdGlvbmFsT3B0aW9uU2NvcGVzIiwgImFkZElmU3RyaW5nIiwgImxhYmVscyIsICJyYXciLCAiaW5kZXgiLCAiYWRkZWRMYWJlbHMiLCAicHVzaCIsICJ1bnNoaWZ0IiwgImxhYmVsIiwgImlzTmFOIiwgImZpbmRPckFkZExhYmVsIiwgImZpcnN0IiwgImluZGV4T2YiLCAibGFzdCIsICJsYXN0SW5kZXhPZiIsICJ2YWxpZEluZGV4IiwgIm1heCIsICJfbGltaXRWYWx1ZSIsICJNYXRoIiwgInJvdW5kIiwgIl9nZXRMYWJlbEZvclZhbHVlIiwgInZhbHVlIiwgImdldExhYmVscyIsICJsZW5ndGgiLCAiQ2F0ZWdvcnlTY2FsZSIsICJTY2FsZSIsICJjb25zdHJ1Y3RvciIsICJjZmciLCAiX3N0YXJ0VmFsdWUiLCAidW5kZWZpbmVkIiwgIl92YWx1ZVJhbmdlIiwgIl9hZGRlZExhYmVscyIsICJpbml0IiwgInNjYWxlT3B0aW9ucyIsICJhZGRlZCIsICJzcGxpY2UiLCAicGFyc2UiLCAiaXNOdWxsT3JVbmRlZiIsICJpc0Zpbml0ZSIsICJ2YWx1ZU9yRGVmYXVsdCIsICJkZXRlcm1pbmVEYXRhTGltaXRzIiwgIm1pbkRlZmluZWQiLCAibWF4RGVmaW5lZCIsICJnZXRVc2VyQm91bmRzIiwgIm1pbiIsICJnZXRNaW5NYXgiLCAib3B0aW9ucyIsICJib3VuZHMiLCAiYnVpbGRUaWNrcyIsICJvZmZzZXQiLCAidGlja3MiLCAic2xpY2UiLCAiZ2V0TGFiZWxGb3JWYWx1ZSIsICJjYWxsIiwgImNvbmZpZ3VyZSIsICJpc0hvcml6b250YWwiLCAiX3JldmVyc2VQaXhlbHMiLCAiZ2V0UGl4ZWxGb3JWYWx1ZSIsICJOYU4iLCAiZ2V0UGl4ZWxGb3JEZWNpbWFsIiwgImdldFBpeGVsRm9yVGljayIsICJnZXRWYWx1ZUZvclBpeGVsIiwgInBpeGVsIiwgImdldERlY2ltYWxGb3JQaXhlbCIsICJnZXRCYXNlUGl4ZWwiLCAiYm90dG9tIiwgImlkIiwgImRlZmF1bHRzIiwgImNhbGxiYWNrIiwgImdlbmVyYXRlVGlja3MiLCAiZ2VuZXJhdGlvbk9wdGlvbnMiLCAiZGF0YVJhbmdlIiwgIk1JTl9TUEFDSU5HIiwgInN0ZXAiLCAicHJlY2lzaW9uIiwgImNvdW50IiwgIm1heFRpY2tzIiwgIm1heERpZ2l0cyIsICJpbmNsdWRlQm91bmRzIiwgInVuaXQiLCAibWF4U3BhY2VzIiwgInJtaW4iLCAicm1heCIsICJjb3VudERlZmluZWQiLCAibWluU3BhY2luZyIsICJzcGFjaW5nIiwgIm5pY2VOdW0iLCAiZmFjdG9yIiwgIm5pY2VNaW4iLCAibmljZU1heCIsICJudW1TcGFjZXMiLCAiY2VpbCIsICJmbG9vciIsICJwb3ciLCAiYWxtb3N0V2hvbGUiLCAiYWxtb3N0RXF1YWxzIiwgImRlY2ltYWxQbGFjZXMiLCAiX2RlY2ltYWxQbGFjZXMiLCAiaiIsICJyZWxhdGl2ZUxhYmVsU2l6ZSIsICJ0aWNrVmFsdWUiLCAiaG9yaXpvbnRhbCIsICJtaW5Sb3RhdGlvbiIsICJyYWQiLCAidG9SYWRpYW5zIiwgInJhdGlvIiwgInNpbiIsICJjb3MiLCAiTGluZWFyU2NhbGVCYXNlIiwgInN0YXJ0IiwgImVuZCIsICJfZW5kVmFsdWUiLCAiTnVtYmVyIiwgImhhbmRsZVRpY2tSYW5nZU9wdGlvbnMiLCAiYmVnaW5BdFplcm8iLCAic2V0TWluIiwgInYiLCAic2V0TWF4IiwgIm1pblNpZ24iLCAic2lnbiIsICJtYXhTaWduIiwgImFicyIsICJnZXRUaWNrTGltaXQiLCAidGlja09wdHMiLCAibWF4VGlja3NMaW1pdCIsICJzdGVwU2l6ZSIsICJjb25zb2xlIiwgIndhcm4iLCAiY29tcHV0ZVRpY2tMaW1pdCIsICJQT1NJVElWRV9JTkZJTklUWSIsICJvcHRzIiwgIm51bWVyaWNHZW5lcmF0b3JPcHRpb25zIiwgIl9tYXhEaWdpdHMiLCAiX3JhbmdlIiwgIl9zZXRNaW5BbmRNYXhCeUtleSIsICJyZXZlcnNlIiwgImZvcm1hdE51bWJlciIsICJjaGFydCIsICJsb2NhbGUiLCAiZm9ybWF0IiwgIkxpbmVhclNjYWxlIiwgIndpZHRoIiwgImhlaWdodCIsICJ0aWNrRm9udCIsICJfcmVzb2x2ZVRpY2tGb250T3B0aW9ucyIsICJsaW5lSGVpZ2h0IiwgIlRpY2tzIiwgImZvcm1hdHRlcnMiLCAibnVtZXJpYyIsICJsb2cxMEZsb29yIiwgImxvZzEwIiwgImNoYW5nZUV4cG9uZW50IiwgIm0iLCAiaXNNYWpvciIsICJ0aWNrVmFsIiwgInJlbWFpbiIsICJzdGVwcyIsICJyYW5nZUV4cCIsICJyYW5nZVN0ZXAiLCAic3RhcnRFeHAiLCAicmFuZ2UiLCAiZmluaXRlT3JEZWZhdWx0IiwgIm1pbkV4cCIsICJleHAiLCAiYmFzZSIsICJzaWduaWZpY2FuZCIsICJtYWpvciIsICJsYXN0VGljayIsICJMb2dhcml0aG1pY1NjYWxlIiwgInByb3RvdHlwZSIsICJhcHBseSIsICJfemVybyIsICJfc3VnZ2VzdGVkTWluIiwgIl91c2VyTWluIiwgIl91c2VyTWF4IiwgImRlY2ltYWwiLCAibG9nYXJpdGhtaWMiLCAiZW5hYmxlZCIsICJnZXRUaWNrQmFja2Ryb3BIZWlnaHQiLCAiZGlzcGxheSIsICJwYWRkaW5nIiwgInRvUGFkZGluZyIsICJiYWNrZHJvcFBhZGRpbmciLCAiZm9udCIsICJzaXplIiwgIm1lYXN1cmVMYWJlbFNpemUiLCAiY3R4IiwgImlzQXJyYXkiLCAidyIsICJfbG9uZ2VzdFRleHQiLCAic3RyaW5nIiwgImgiLCAiZGV0ZXJtaW5lTGltaXRzIiwgImFuZ2xlIiwgInBvcyIsICJmaXRXaXRoUG9pbnRMYWJlbHMiLCAic2NhbGUiLCAib3JpZyIsICJsIiwgImxlZnQiLCAiX3BhZGRpbmciLCAiciIsICJyaWdodCIsICJ0IiwgInRvcCIsICJiIiwgImxpbWl0cyIsICJPYmplY3QiLCAiYXNzaWduIiwgImxhYmVsU2l6ZXMiLCAidmFsdWVDb3VudCIsICJfcG9pbnRMYWJlbHMiLCAicG9pbnRMYWJlbE9wdHMiLCAicG9pbnRMYWJlbHMiLCAiYWRkaXRpb25hbEFuZ2xlIiwgImNlbnRlclBvaW50TGFiZWxzIiwgIlBJIiwgImkiLCAic2V0Q29udGV4dCIsICJnZXRQb2ludExhYmVsQ29udGV4dCIsICJwb2ludFBvc2l0aW9uIiwgImdldFBvaW50UG9zaXRpb24iLCAiZHJhd2luZ0FyZWEiLCAicGxGb250IiwgInRvRm9udCIsICJ0ZXh0U2l6ZSIsICJhbmdsZVJhZGlhbnMiLCAiX25vcm1hbGl6ZUFuZ2xlIiwgImdldEluZGV4QW5nbGUiLCAidG9EZWdyZWVzIiwgImhMaW1pdHMiLCAieCIsICJ2TGltaXRzIiwgInkiLCAidXBkYXRlTGltaXRzIiwgInNldENlbnRlclBvaW50IiwgIl9wb2ludExhYmVsSXRlbXMiLCAiYnVpbGRQb2ludExhYmVsSXRlbXMiLCAiY3JlYXRlUG9pbnRMYWJlbEl0ZW0iLCAiaXRlbU9wdHMiLCAib3V0ZXJEaXN0YW5jZSIsICJleHRyYSIsICJwb2ludExhYmVsUG9zaXRpb24iLCAiSEFMRl9QSSIsICJ5Rm9yQW5nbGUiLCAidGV4dEFsaWduIiwgImdldFRleHRBbGlnbkZvckFuZ2xlIiwgImxlZnRGb3JUZXh0QWxpZ24iLCAidmlzaWJsZSIsICJpc05vdE92ZXJsYXBwZWQiLCAiaXRlbSIsICJhcmVhIiwgImFwZXhlc0luQXJlYSIsICJfaXNQb2ludEluQXJlYSIsICJpdGVtcyIsICJhbGlnbiIsICJkcmF3UG9pbnRMYWJlbEJveCIsICJiYWNrZHJvcENvbG9yIiwgImJvcmRlclJhZGl1cyIsICJ0b1RSQkxDb3JuZXJzIiwgImZpbGxTdHlsZSIsICJiYWNrZHJvcExlZnQiLCAiYmFja2Ryb3BUb3AiLCAiYmFja2Ryb3BXaWR0aCIsICJiYWNrZHJvcEhlaWdodCIsICJ2YWx1ZXMiLCAic29tZSIsICJiZWdpblBhdGgiLCAiYWRkUm91bmRlZFJlY3RQYXRoIiwgInJhZGl1cyIsICJmaWxsIiwgImZpbGxSZWN0IiwgImRyYXdQb2ludExhYmVscyIsICJsYWJlbENvdW50IiwgIm9wdHNBdEluZGV4IiwgInJlbmRlclRleHQiLCAiY29sb3IiLCAidGV4dEJhc2VsaW5lIiwgInBhdGhSYWRpdXNMaW5lIiwgImNpcmN1bGFyIiwgImFyYyIsICJ4Q2VudGVyIiwgInlDZW50ZXIiLCAiVEFVIiwgIm1vdmVUbyIsICJsaW5lVG8iLCAiZHJhd1JhZGl1c0xpbmUiLCAiZ3JpZExpbmVPcHRzIiwgImJvcmRlck9wdHMiLCAibGluZVdpZHRoIiwgInNhdmUiLCAic3Ryb2tlU3R5bGUiLCAic2V0TGluZURhc2giLCAiZGFzaCIsICJsaW5lRGFzaE9mZnNldCIsICJkYXNoT2Zmc2V0IiwgImNsb3NlUGF0aCIsICJzdHJva2UiLCAicmVzdG9yZSIsICJjcmVhdGVQb2ludExhYmVsQ29udGV4dCIsICJwYXJlbnQiLCAiY3JlYXRlQ29udGV4dCIsICJ0eXBlIiwgIlJhZGlhbExpbmVhclNjYWxlIiwgInNldERpbWVuc2lvbnMiLCAibWF4V2lkdGgiLCAibWF4SGVpZ2h0IiwgImdlbmVyYXRlVGlja0xhYmVscyIsICJtYXAiLCAiY2FsbENhbGxiYWNrIiwgImZpbHRlciIsICJnZXREYXRhVmlzaWJpbGl0eSIsICJmaXQiLCAibGVmdE1vdmVtZW50IiwgInJpZ2h0TW92ZW1lbnQiLCAidG9wTW92ZW1lbnQiLCAiYm90dG9tTW92ZW1lbnQiLCAiYW5nbGVNdWx0aXBsaWVyIiwgInN0YXJ0QW5nbGUiLCAiZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUiLCAic2NhbGluZ0ZhY3RvciIsICJnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlciIsICJkaXN0YW5jZSIsICJzY2FsZWREaXN0YW5jZSIsICJwb2ludExhYmVsIiwgImdldENvbnRleHQiLCAiZGlzdGFuY2VGcm9tQ2VudGVyIiwgImdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSIsICJnZXRCYXNlUG9zaXRpb24iLCAiZ2V0QmFzZVZhbHVlIiwgImdldFBvaW50TGFiZWxQb3NpdGlvbiIsICJkcmF3QmFja2dyb3VuZCIsICJiYWNrZ3JvdW5kQ29sb3IiLCAiZ3JpZCIsICJkcmF3R3JpZCIsICJhbmdsZUxpbmVzIiwgImJvcmRlciIsICJwb3NpdGlvbiIsICJmb3JFYWNoIiwgInRpY2siLCAiY29udGV4dCIsICJvcHRzQXRJbmRleEJvcmRlciIsICJib3JkZXJEYXNoIiwgImJvcmRlckRhc2hPZmZzZXQiLCAiZHJhd0JvcmRlciIsICJkcmF3TGFiZWxzIiwgInRyYW5zbGF0ZSIsICJyb3RhdGUiLCAic2hvd0xhYmVsQmFja2Ryb3AiLCAibWVhc3VyZVRleHQiLCAic3Ryb2tlQ29sb3IiLCAidGV4dFN0cm9rZUNvbG9yIiwgInN0cm9rZVdpZHRoIiwgInRleHRTdHJva2VXaWR0aCIsICJkcmF3VGl0bGUiLCAiYW5pbWF0ZSIsICJkZWZhdWx0Um91dGVzIiwgImRlc2NyaXB0b3JzIiwgIl9mYWxsYmFjayIsICJJTlRFUlZBTFMiLCAibWlsbGlzZWNvbmQiLCAiY29tbW9uIiwgInNlY29uZCIsICJtaW51dGUiLCAiaG91ciIsICJkYXkiLCAid2VlayIsICJtb250aCIsICJxdWFydGVyIiwgInllYXIiLCAiVU5JVFMiLCAia2V5cyIsICJzb3J0ZXIiLCAiYSIsICJpbnB1dCIsICJhZGFwdGVyIiwgIl9hZGFwdGVyIiwgInBhcnNlciIsICJpc29XZWVrZGF5IiwgIl9wYXJzZU9wdHMiLCAiaXNOdW1iZXIiLCAic3RhcnRPZiIsICJkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzIiwgIm1pblVuaXQiLCAiY2FwYWNpdHkiLCAiaWxlbiIsICJpbnRlcnZhbCIsICJNQVhfU0FGRV9JTlRFR0VSIiwgImRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nIiwgIm51bVRpY2tzIiwgImRpZmYiLCAiZGV0ZXJtaW5lTWFqb3JVbml0IiwgImFkZFRpY2siLCAidGltZSIsICJ0aW1lc3RhbXBzIiwgImxvIiwgImhpIiwgIl9sb29rdXAiLCAidGltZXN0YW1wIiwgInNldE1ham9yVGlja3MiLCAibWFqb3JVbml0IiwgImFkZCIsICJ0aWNrc0Zyb21UaW1lc3RhbXBzIiwgIlRpbWVTY2FsZSIsICJwcm9wcyIsICJfY2FjaGUiLCAiZGF0YSIsICJhbGwiLCAiX3VuaXQiLCAiX21ham9yVW5pdCIsICJfb2Zmc2V0cyIsICJfbm9ybWFsaXplZCIsICJzY2FsZU9wdHMiLCAiYWRhcHRlcnMiLCAiX2RhdGUiLCAiZGF0ZSIsICJtZXJnZUlmIiwgImRpc3BsYXlGb3JtYXRzIiwgImZvcm1hdHMiLCAibm9ybWFsaXplZCIsICJiZWZvcmVMYXlvdXQiLCAiX2FwcGx5Qm91bmRzIiwgIl9nZXRMYWJlbEJvdW5kcyIsICJzb3VyY2UiLCAiRGF0ZSIsICJub3ciLCAiZW5kT2YiLCAiYXJyIiwgImdldExhYmVsVGltZXN0YW1wcyIsICJORUdBVElWRV9JTkZJTklUWSIsICJ0aW1lT3B0cyIsICJfZ2VuZXJhdGUiLCAiX2ZpbHRlckJldHdlZW4iLCAiYXV0b1NraXAiLCAiX2dldExhYmVsQ2FwYWNpdHkiLCAiaW5pdE9mZnNldHMiLCAiYWZ0ZXJBdXRvU2tpcCIsICJvZmZzZXRBZnRlckF1dG9za2lwIiwgImdldERlY2ltYWxGb3JWYWx1ZSIsICJsaW1pdCIsICJtaW5vciIsICJ3ZWVrZGF5IiwgImhhc1dlZWtkYXkiLCAiRXJyb3IiLCAiZ2V0RGF0YVRpbWVzdGFtcHMiLCAic29ydCIsICJ0b29sdGlwRm9ybWF0IiwgImRhdGV0aW1lIiwgImZtdCIsICJfdGlja0Zvcm1hdEZ1bmN0aW9uIiwgImZvcm1hdHRlciIsICJtaW5vckZvcm1hdCIsICJtYWpvckZvcm1hdCIsICJvZmZzZXRzIiwgIl9nZXRMYWJlbFNpemUiLCAidGlja3NPcHRzIiwgInRpY2tMYWJlbFdpZHRoIiwgIm1heFJvdGF0aW9uIiwgImNvc1JvdGF0aW9uIiwgInNpblJvdGF0aW9uIiwgInRpY2tGb250U2l6ZSIsICJleGFtcGxlVGltZSIsICJleGFtcGxlTGFiZWwiLCAibWV0YXMiLCAiZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMiLCAiY29udHJvbGxlciIsICJnZXRBbGxQYXJzZWRWYWx1ZXMiLCAiY29uY2F0IiwgIm5vcm1hbGl6ZSIsICJfYXJyYXlVbmlxdWUiLCAiaW50ZXJwb2xhdGUiLCAidGFibGUiLCAidmFsIiwgInByZXZTb3VyY2UiLCAibmV4dFNvdXJjZSIsICJwcmV2VGFyZ2V0IiwgIm5leHRUYXJnZXQiLCAiX2xvb2t1cEJ5S2V5IiwgInNwYW4iLCAiVGltZVNlcmllc1NjYWxlIiwgIl90YWJsZSIsICJfbWluUG9zIiwgIl90YWJsZVJhbmdlIiwgIl9nZXRUaW1lc3RhbXBzRm9yVGFibGUiLCAiYnVpbGRMb29rdXBUYWJsZSIsICJwcmV2IiwgImN1cnIiLCAibmV4dCIsICJpbmNsdWRlcyIsICJTdGF0dXMiLCAibiIsICJsIiwgInUiLCAiaSIsICJ0IiwgIm8iLCAiciIsICJmIiwgImUiLCAiYyIsICJzIiwgImEiLCAicGFyZW50Tm9kZSIsICJyZW1vdmVDaGlsZCIsICJoIiwgImFyZ3VtZW50cyIsICJsZW5ndGgiLCAiY2hpbGRyZW4iLCAiY2FsbCIsICJkZWZhdWx0UHJvcHMiLCAidiIsICJ0eXBlIiwgInByb3BzIiwgImtleSIsICJyZWYiLCAiX19rIiwgIl9fIiwgIl9fYiIsICJfX2UiLCAiX19kIiwgIl9fYyIsICJfX2giLCAiY29uc3RydWN0b3IiLCAiX192IiwgInZub2RlIiwgInAiLCAibiIsICJjaGlsZHJlbiIsICJkIiwgImwiLCAidGhpcyIsICJwcm9wcyIsICJjb250ZXh0IiwgIl8iLCAiX18iLCAiX19rIiwgImluZGV4T2YiLCAidSIsICJsZW5ndGgiLCAiX19lIiwgInR5cGUiLCAiayIsICJfX2MiLCAiYmFzZSIsICJiIiwgIl9fZCIsICJ0IiwgInB1c2giLCAiZyIsICJfX3IiLCAibyIsICJkZWJvdW5jZVJlbmRlcmluZyIsICJzZXRUaW1lb3V0IiwgInNvcnQiLCAiX192IiwgIl9fYiIsICJzb21lIiwgImkiLCAiciIsICJfX1AiLCAicyIsICJqIiwgIl9fbiIsICJvd25lclNWR0VsZW1lbnQiLCAiX19oIiwgInoiLCAidyIsICJjIiwgImEiLCAiaCIsICJ5IiwgIngiLCAiZSIsICJDIiwgInYiLCAiQXJyYXkiLCAiaXNBcnJheSIsICJrZXkiLCAicmVmIiwgImYiLCAibSIsICJBIiwgInBhcmVudE5vZGUiLCAiTiIsICJNIiwgImFwcGVuZENoaWxkIiwgIm5leHRTaWJsaW5nIiwgImluc2VydEJlZm9yZSIsICIkIiwgInNldFByb3BlcnR5IiwgInRlc3QiLCAiSCIsICJzdHlsZSIsICJjc3NUZXh0IiwgInJlcGxhY2UiLCAidG9Mb3dlckNhc2UiLCAic2xpY2UiLCAiYWRkRXZlbnRMaXN0ZW5lciIsICJUIiwgIkkiLCAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsICJyZW1vdmVBdHRyaWJ1dGUiLCAic2V0QXR0cmlidXRlIiwgImV2ZW50IiwgImNvbnN0cnVjdG9yIiwgImNvbnRleHRUeXBlIiwgInZhbHVlIiwgIl9fRSIsICJwcm90b3R5cGUiLCAicmVuZGVyIiwgIk8iLCAic3ViIiwgInN0YXRlIiwgIl9zYiIsICJfX3MiLCAiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwgImNvbXBvbmVudFdpbGxNb3VudCIsICJjb21wb25lbnREaWRNb3VudCIsICJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwgInNob3VsZENvbXBvbmVudFVwZGF0ZSIsICJmb3JFYWNoIiwgImNvbXBvbmVudFdpbGxVcGRhdGUiLCAiY29tcG9uZW50RGlkVXBkYXRlIiwgImdldENoaWxkQ29udGV4dCIsICJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsICJMIiwgImRpZmZlZCIsICJjYWxsIiwgImxvY2FsTmFtZSIsICJub2RlVHlwZSIsICJkb2N1bWVudCIsICJjcmVhdGVUZXh0Tm9kZSIsICJjcmVhdGVFbGVtZW50TlMiLCAiY3JlYXRlRWxlbWVudCIsICJpcyIsICJkYXRhIiwgImNoaWxkTm9kZXMiLCAiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCAiYXR0cmlidXRlcyIsICJuYW1lIiwgIl9faHRtbCIsICJpbm5lckhUTUwiLCAiY2hlY2tlZCIsICJjdXJyZW50IiwgInVubW91bnQiLCAiY29tcG9uZW50V2lsbFVubW91bnQiLCAiUCIsICJmaXJzdENoaWxkIiwgIk1hdGgiLCAicmFuZG9tIiwgInRvU3RyaW5nIiwgImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsICJzZXRTdGF0ZSIsICJjb21wb25lbnREaWRDYXRjaCIsICJmb3JjZVVwZGF0ZSIsICJCYXNlIiwgImlkIiwgIl9pZCIsICJnZW5lcmF0ZVVVSUQiLCAiX2NyZWF0ZUNsYXNzIiwgIkhUTUxFbGVtZW50IiwgInBhcmVudEVsZW1lbnQiLCAiY29udGVudCIsICJodG1sIiwgIkNlbGwiLCAiUHJvY2Vzc29yVHlwZSIsICJfQmFzZSIsICJfdGhpcyIsICJ1cGRhdGUiLCAiX2luaGVyaXRzTG9vc2UiLCAiX3Byb3RvIiwgImNhc3QiLCAib3V0ZXJIVE1MIiwgIlJvdyIsICJjZWxscyIsICJfY2VsbHMiLCAiY2VsbCIsICJpbmRleCIsICJ0b0FycmF5IiwgIm1hcCIsICJmcm9tQ2VsbHMiLCAiZ2V0IiwgInNldCIsICJUYWJ1bGFyIiwgInJvd3MiLCAiX3Jvd3MiLCAiX2xlbmd0aCIsICJyb3ciLCAiZnJvbVJvd3MiLCAiZnJvbUFycmF5IiwgImxlbiIsICJFdmVudEVtaXR0ZXIiLCAiY2FsbGJhY2tzIiwgImluaXQiLCAibGlzdGVuZXJzIiwgIm9uIiwgImxpc3RlbmVyIiwgIm9mZiIsICJldmVudE5hbWUiLCAiZmlsdGVyIiwgImVtaXQiLCAiX2FyZ3VtZW50cyIsICJhcmd1bWVudHMiLCAiYXBwbHkiLCAiZGVlcEVxdWFsIiwgIm9iajEiLCAib2JqMiIsICJoYXNPd25Qcm9wZXJ0eSIsICJrZXlzMSIsICJPYmplY3QiLCAia2V5cyIsICJrZXlzMiIsICJfaSIsICJfa2V5cyIsICJQaXBlbGluZVByb2Nlc3NvciIsICJfRXZlbnRFbWl0dGVyIiwgIl9wcm9wcyIsICJzZXRQcm9wcyIsICJwcm9jZXNzIiwgImFyZ3MiLCAidmFsaWRhdGVQcm9wcyIsICJfcHJvY2VzcyIsICJjb25jYXQiLCAidXBkYXRlZFByb3BzIiwgIl9leHRlbmRzIiwgIkdsb2JhbFNlYXJjaEZpbHRlciIsICJrZXl3b3JkIiwgIlN0cmluZyIsICJ0cmltIiwgImNvbHVtbnMiLCAiaWdub3JlSGlkZGVuQ29sdW1ucyIsICJ0YWJ1bGFyIiwgInNlbGVjdG9yIiwgInJvd0luZGV4IiwgImNlbGxJbmRleCIsICJoaWRkZW4iLCAiZWxlbWVudCIsICJGaWx0ZXIiLCAiY2xhc3NOYW1lIiwgInByZWZpeCIsICJyZWR1Y2UiLCAicHJldiIsICJjdXIiLCAiU2VydmVyR2xvYmFsU2VhcmNoRmlsdGVyIiwgIm9wdGlvbnMiLCAidXBkYXRlcyIsICJ1cmwiLCAiYm9keSIsICJTZXJ2ZXJGaWx0ZXIiLCAiX19IIiwgIl9fViIsICJCIiwgIl9fTiIsICJldmVyeSIsICJGIiwgInNoaWZ0IiwgInJlcXVlc3RBbmltYXRpb25GcmFtZSIsICJjbGVhclRpbWVvdXQiLCAiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCAiQ29uZmlnQ29udGV4dCIsICJlblVTIiwgInNlYXJjaCIsICJwbGFjZWhvbGRlciIsICJzb3J0QXNjIiwgInNvcnREZXNjIiwgInBhZ2luYXRpb24iLCAicHJldmlvdXMiLCAibmV4dCIsICJuYXZpZ2F0ZSIsICJwYWdlIiwgInBhZ2VzIiwgInNob3dpbmciLCAib2YiLCAidG8iLCAicmVzdWx0cyIsICJsb2FkaW5nIiwgIm5vUmVjb3Jkc0ZvdW5kIiwgImVycm9yIiwgIlRyYW5zbGF0b3IiLCAibGFuZ3VhZ2UiLCAiX2xhbmd1YWdlIiwgIl9kZWZhdWx0TGFuZ3VhZ2UiLCAiZ2V0U3RyaW5nIiwgIm1lc3NhZ2UiLCAibGFuZyIsICJzcGxpdHRlZCIsICJzcGxpdCIsICJ2YWwiLCAiam9pbiIsICJ0cmFuc2xhdGUiLCAibWVzc2FnZUZvcm1hdCIsICJ0cmFuc2xhdGVkIiwgInVzZVRyYW5zbGF0b3IiLCAiY29uZmlnIiwgInVzZUNvbmZpZyIsICJfY29uZmlnJHRyYW5zbGF0b3IiLCAidHJhbnNsYXRvciIsICJwYXlsb2FkIiwgInN0b3JlIiwgInVzZVNlbGVjdG9yIiwgInVzZVN0b3JlIiwgIl91c2VTdGF0ZSIsICJ1c2VTdGF0ZSIsICJnZXRTdGF0ZSIsICJzZXRDdXJyZW50IiwgInVzZUVmZmVjdCIsICJzdWJzY3JpYmUiLCAidXBkYXRlZCIsICJTZWFyY2giLCAiX2NvbmZpZyRjbGFzc05hbWUiLCAidW5kZWZpbmVkIiwgInByb2Nlc3NvciIsICJzZXRQcm9jZXNzb3IiLCAiZGlzcGF0Y2giLCAic2VydmVyIiwgImhlYWRlciIsICJhY3Rpb25zIiwgInBpcGVsaW5lIiwgInJlZ2lzdGVyIiwgInVucmVnaXN0ZXIiLCAiZnVuYyIsICJ3YWl0Rm9yIiwgInRpbWVvdXQiLCAiZGVib3VuY2VkT25JbnB1dCIsICJ0YXJnZXQiLCAiSFRNTElucHV0RWxlbWVudCIsICJkZWJvdW5jZVRpbWVvdXQiLCAicmVzb2x2ZSIsICJjbGFzc0pvaW4iLCAib25JbnB1dCIsICJkZWZhdWx0VmFsdWUiLCAiUGFnaW5hdGlvbkxpbWl0IiwgImlzTmFOIiwgIk51bWJlciIsICJsaW1pdCIsICJFcnJvciIsICJMaW1pdCIsICJTZXJ2ZXJQYWdpbmF0aW9uTGltaXQiLCAiU2VydmVyTGltaXQiLCAiUGFnaW5hdGlvbiIsICJfY29uZmlnJHBhZ2luYXRpb24iLCAic3VtbWFyeSIsICJfY29uZmlnJHBhZ2luYXRpb24kc3UiLCAiX2NvbmZpZyRwYWdpbmF0aW9uJG5lIiwgIm5leHRCdXR0b24iLCAiX2NvbmZpZyRwYWdpbmF0aW9uJHByIiwgInByZXZCdXR0b24iLCAiX2NvbmZpZyRwYWdpbmF0aW9uJGJ1IiwgImJ1dHRvbnNDb3VudCIsICJfY29uZmlnJHBhZ2luYXRpb24kbGkiLCAiX2NvbmZpZyRwYWdpbmF0aW9uJHBhIiwgIl9jb25maWckcGFnaW5hdGlvbiRyZSIsICJyZXNldFBhZ2VPblVwZGF0ZSIsICJ1c2VSZWYiLCAiY3VycmVudFBhZ2UiLCAic2V0Q3VycmVudFBhZ2UiLCAidG90YWwiLCAic2V0VG90YWwiLCAiX3VzZVN0YXRlMiIsICJvblVwZGF0ZSIsICJ1cGRhdGVkUHJvY2Vzc29yIiwgImNlaWwiLCAic2V0UGFnZSIsICJGcmFnbWVudCIsICJyb2xlIiwgInBhZ2luYXRpb25TdW1tYXJ5IiwgInRpdGxlIiwgIm1pbiIsICJ0YWJJbmRleCIsICJkaXNhYmxlZCIsICJvbkNsaWNrIiwgInBhZ2luYXRpb25CdXR0b24iLCAicGFnaW5hdGlvbkJ1dHRvblByZXYiLCAibWF4Q291bnQiLCAicGFnZVBpdm90IiwgImZsb29yIiwgImZyb20iLCAicGFnaW5hdGlvbkJ1dHRvbkN1cnJlbnQiLCAicmVuZGVyUGFnZXMiLCAicGFnaW5hdGlvbkJ1dHRvbk5leHQiLCAid2lkdGgiLCAiY29udGFpbmVyV2lkdGgiLCAicGFyc2VJbnQiLCAicHgiLCAiU2hhZG93VGFibGUiLCAic2hhZG93VGFibGUiLCAidGFibGVSZWYiLCAiY2xvbmVOb2RlIiwgInBvc2l0aW9uIiwgInpJbmRleCIsICJ2aXNpYmlsaXR5IiwgIm5vZGVFbGVtZW50IiwgImNhbWVsQ2FzZSIsICJzdHIiLCAid29yZHMiLCAid29yZCIsICJjaGFyQXQiLCAidG9VcHBlckNhc2UiLCAiUGx1Z2luUG9zaXRpb24iLCAibG9nIiwgIkxvZ2dlciIsICJmb3JtYXQiLCAidGhyb3dFeGNlcHRpb24iLCAibXNnIiwgImNvbnNvbGUiLCAid2FybiIsICJpbmZvIiwgIlBsdWdpbk1hbmFnZXIiLCAicGx1Z2lucyIsICJmaW5kIiwgImFkZCIsICJwbHVnaW4iLCAicmVtb3ZlIiwgInNwbGljZSIsICJsaXN0IiwgIm9yZGVyIiwgIlBsdWdpblJlbmRlcmVyIiwgInBsdWdpbklkIiwgImNvbXBvbmVudCIsICJIZWFkZXIiLCAiX2NvbHVtbnMiLCAiYWRqdXN0V2lkdGgiLCAidGVtcFJlZiIsICJjb250YWluZXIiLCAiYXV0b1dpZHRoIiwgImNsaWVudFdpZHRoIiwgIndpZHRocyIsICJnZXRTaGFkb3dUYWJsZVdpZHRocyIsICJxdWVyeVNlbGVjdG9yIiwgInRhYmxlRWxlbWVudCIsICJ0YWJsZUNsYXNzTmFtZSIsICJ0YWJsZVN0eWxlIiwgInRhYmxlTGF5b3V0IiwgInBhZGRpbmciLCAibWFyZ2luIiwgImJvcmRlciIsICJvdXRsaW5lIiwgInF1ZXJ5U2VsZWN0b3JBbGwiLCAiZ2V0QXR0cmlidXRlIiwgIm1pbldpZHRoIiwgIm9iaiIsICJfc3RlcCIsICJfaXRlcmF0b3IiLCAiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSIsICJ0YWJ1bGFyRm9ybWF0IiwgImRvbmUiLCAiY29sdW1uIiwgInNldFNvcnQiLCAic29ydENvbmZpZyIsICJjb2xzIiwgIl9zdGVwMiIsICJzZXRSZXNpemFibGUiLCAicmVzaXphYmxlIiwgIl9zdGVwMyIsICJfaXRlcmF0b3IzIiwgInNldElEIiwgIl9zdGVwNCIsICJfaXRlcmF0b3I0IiwgImxvZ2dlciIsICJwb3B1bGF0ZVBsdWdpbnMiLCAicGx1Z2luTWFuYWdlciIsICJfc3RlcDUiLCAiX2l0ZXJhdG9yNSIsICJmcm9tQ29sdW1ucyIsICJfc3RlcDYiLCAiX2l0ZXJhdG9yNiIsICJpc1ZhbGlkRWxlbWVudCIsICJ0eXBlZENvbHVtbiIsICJjcmVhdGVGcm9tQ29uZmlnIiwgImZyb21IVE1MVGFibGUiLCAiX3N0ZXA3IiwgIl9pdGVyYXRvcjciLCAidGgiLCAicmVzdWx0IiwgIl9zdGVwOCIsICJfaXRlcmF0b3I4IiwgImNvbCIsICJuZXh0Um93IiwgImxlYWZDb2x1bW5zIiwgIl9zdGVwOSIsICJfaXRlcmF0b3I5IiwgIm1heGltdW1EZXB0aCIsICJTdG9yYWdlIiwgIk1lbW9yeVN0b3JhZ2UiLCAiX1N0b3JhZ2UiLCAiUHJvbWlzZSIsICJyZWplY3QiLCAiU2VydmVyU3RvcmFnZSIsICJoYW5kbGVyIiwgInJlc3BvbnNlIiwgImhhbmRsZSIsICJvayIsICJqc29uIiwgInN0YXR1cyIsICJzdGF0dXNUZXh0IiwgIm9wdHMiLCAiZmV0Y2giLCAidGhlbiIsICJiaW5kIiwgInJlcyIsICJTdG9yYWdlVXRpbHMiLCAic3RvcmFnZSIsICJ0YWJsZUVsZW1lbnRUb0FycmF5IiwgImRpc3BsYXkiLCAiYXJyIiwgInBhcnNlZFJvdyIsICJfaXRlcmF0b3IyIiwgIk5vZGUiLCAiVEVYVF9OT0RFIiwgIkRPTVBhcnNlciIsICJwYXJzZUZyb21TdHJpbmciLCAiZG9jdW1lbnRFbGVtZW50IiwgInRleHRDb250ZW50IiwgInBhY3QiLCAiX3NldHRsZSIsICJvYnNlcnZlciIsICJfUGFjdCIsICJvbkZ1bGZpbGxlZCIsICJvblJlamVjdGVkIiwgImNhbGxiYWNrIiwgIl9pc1NldHRsZWRQYWN0IiwgInRoZW5hYmxlIiwgIlBpcGVsaW5lIiwgInN0ZXBzIiwgIl9zdGVwcyIsICJjYWNoZSIsICJNYXAiLCAibGFzdFByb2Nlc3NvckluZGV4VXBkYXRlZCIsICJzdGVwIiwgImNsZWFyQ2FjaGUiLCAicHJpb3JpdHkiLCAiZmluZFByb2Nlc3NvckluZGV4QnlJRCIsICJwcm9jZXNzb3JQcm9wc1VwZGF0ZWQiLCAiYWRkUHJvY2Vzc29yQnlQcmlvcml0eSIsICJhZnRlclJlZ2lzdGVyZWQiLCAidHJ5UmVnaXN0ZXIiLCAic3ViU3RlcHMiLCAicHJvYyIsICJuZXdTdWJTdGVwIiwgInNlY29uZCIsICJmaXJzdCIsICJnZXRTdGVwc0J5VHlwZSIsICJnZXRTb3J0ZWRQcm9jZXNzb3JUeXBlcyIsICJfdGVtcDMiLCAiX3Jlc3VsdCIsICJfdGhpczIiLCAiX3RlbXAyIiwgImFycmF5IiwgImNoZWNrIiwgIl9jeWNsZSIsICJwcm9jZXNzb3JJbmRleCIsICJfcHJvY2Vzc29yJHByb2Nlc3MiLCAicHJvY2Vzc29ySUQiLCAiZmluZEluZGV4IiwgInNldExhc3RQcm9jZXNzb3JJbmRleCIsICJTdG9yYWdlRXh0cmFjdG9yIiwgIkV4dHJhY3RvciIsICJhcnJheVJlc3BvbnNlIiwgIkFycmF5VG9UYWJ1bGFyVHJhbnNmb3JtZXIiLCAiVHJhbnNmb3JtZXIiLCAiU2VydmVySW5pdGlhdG9yIiwgIl9QaXBlbGluZVByb2Nlc3NvciIsICJlbnRyaWVzIiwgInNlcnZlclN0b3JhZ2VPcHRpb25zIiwgIl9yZWYiLCAiYWNjIiwgIl9leHRlbmRzMiIsICJJbml0aWF0b3IiLCAiU3RvcmFnZVJlc3BvbnNlVG9BcnJheVRyYW5zZm9ybWVyIiwgImNhc3REYXRhIiwgInBhZCIsICJzdG9yYWdlUmVzcG9uc2UiLCAiUGlwZWxpbmVVdGlscyIsICJpbml0aWFsU3RhdGUiLCAiaXNEaXNwYXRjaGluZyIsICJnZXRMaXN0ZW5lcnMiLCAicmVkdWNlciIsICJwcmV2U3RhdGUiLCAibGlzIiwgIkNvbnN1bWVyIiwgIlByb3ZpZGVyIiwgImNyZWF0ZUNvbnRleHQiLCAiQ29uZmlnIiwgImFzc2lnbiIsICJkZWZhdWx0Q29uZmlnIiwgInBhcnRpYWxDb25maWciLCAiZnJvbVBhcnRpYWxDb25maWciLCAiU3RvcmUiLCAiU3RhdHVzIiwgIkluaXQiLCAiaGVpZ2h0IiwgInByb2Nlc3NpbmdUaHJvdHRsZU1zIiwgIm11bHRpQ29sdW1uIiwgIkZvb3RlciIsICJURCIsICJjb2xTcGFuIiwgInRkIiwgIm1lc3NhZ2VDZWxsIiwgImV2ZW50RW1pdHRlciIsICJmb3JtYXR0ZXIiLCAiVFIiLCAidHIiLCAibWVzc2FnZVJvdyIsICJNZXNzYWdlUm93IiwgIlRCb2R5IiwgImhlYWRlckxlbmd0aCIsICJ2aXNpYmxlQ29sdW1ucyIsICJ0Ym9keSIsICJMb2FkaW5nIiwgIlJlbmRlcmVkIiwgIm5vdGZvdW5kIiwgIk5hdGl2ZVNvcnQiLCAiY29uZGl0aW9uIiwgImRpcmVjdGlvbiIsICJjb21wYXJlIiwgImNlbGxBIiwgImNlbGxCIiwgImNvbXBhcmVXcmFwcGVyIiwgImNtcCIsICJzb3J0ZWRSb3dzIiwgInNvcnRlZCIsICJTb3J0IiwgIm11bHRpIiwgIl9zdGF0ZSRzb3J0IiwgInJlc2V0IiwgImNvdW50IiwgIl9pbmRleDIiLCAiU29ydFRvZ2dsZSIsICJTb3J0Q29sdW1uIiwgIlNlcnZlclNvcnQiLCAic2V0RGlyZWN0aW9uIiwgInByb2Nlc3NvclR5cGUiLCAiZ2V0U29ydFByb2Nlc3NvciIsICJwcm9jZXNzb3JzIiwgImN1cnJlbnRDb2x1bW4iLCAiX3Byb3BzJGRpcmVjdGlvbiIsICJwcmV2ZW50RGVmYXVsdCIsICJzdG9wUHJvcGFnYXRpb24iLCAic2hpZnRLZXkiLCAidGhyb3R0bGUiLCAiZm4iLCAid2FpdCIsICJ0aW1lb3V0SWQiLCAibGFzdFRpbWUiLCAiRGF0ZSIsICJub3ciLCAiZXhlY3V0ZSIsICJjdXJyZW50VGltZSIsICJlbGFwc2VkIiwgIlJlc2l6ZSIsICJnZXRQYWdlWCIsICJNb3VzZUV2ZW50IiwgInBhZ2VYIiwgImNoYW5nZWRUb3VjaGVzIiwgInN0YXJ0IiwgIm9mZnNldFN0YXJ0IiwgInRoUmVmIiwgIm1vdmVGbiIsICJtb3ZlIiwgImVuZCIsICJ0aEVsZW1lbnQiLCAib25Nb3VzZURvd24iLCAib25Ub3VjaFN0YXJ0IiwgIlRIIiwgInNldFN0eWxlIiwgImZpeGVkSGVhZGVyIiwgIm9mZnNldFRvcCIsICJ0b3AiLCAiaXNTb3J0YWJsZSIsICJTb3J0QWN0aW9ucyIsICJvbktleURvd24iLCAid2hpY2giLCAicm93U3BhbiIsICJUSGVhZCIsICJ0aGVhZCIsICJyZW5kZXJSb3ciLCAidG90YWxSb3dzIiwgImNvbHVtbkluZGV4IiwgImNhbGN1bGF0ZVJvd0NvbFNwYW5zIiwgImRlcHRoIiwgInJlbWFpbmluZ1Jvd3MiLCAiX2NhbGN1bGF0ZVJvd0NvbFNwYW5zIiwgIlNldEhlYWRlciIsICJUYWJsZSIsICJ0YWJsZSIsICJIZWFkZXJDb250YWluZXIiLCAiaXNBY3RpdmUiLCAic2V0SXNBY3RpdmUiLCAiaGVhZGVyUmVmIiwgIkZvb3RlckNvbnRhaW5lciIsICJmb290ZXJSZWYiLCAiZm9vdGVyIiwgIkNvbnRhaW5lciIsICJwcm9jZXNzUGlwZWxpbmUiLCAiTG9hZGVkIiwgIl90ZW1wIiwgIkdyaWQiLCAiaW5zdGFuY2UiLCAiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsICJ1cGRhdGVDb25maWciLCAiZm9yY2VSZW5kZXIiLCAiZGVzdHJveSIsICJoIiwgInBhdGgiLCAiYSIsICJiIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfdmh0bWwiLCAidGFiSGVhZGVyIiwgImNvbnRhaW5lckVsZW1lbnQiLCAidGFiQ29udGVudCIsICJ0YWJCdXR0b24iLCAiYWN0aXZhdGVUYWJJZCIsICJoIiwgImNhbGxiYWNrIiwgInYiLCAiXyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X21vbWVudCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImVsIiwgImxpbmsiLCAiZSIsICJpbXBvcnRfdmh0bWwiLCAiaCIsICJlIiwgImltcG9ydF9vYnNpZGlhbiIsICJfIiwgInJlc29sdmUiLCAiY2FsbGJhY2siLCAiaW1wb3J0X29ic2lkaWFuIiwgImUiLCAiY2FsbGJhY2siLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiXyIsICJhIiwgImIiLCAibm93IiwgIkRlY2siLCAibm93IiwgInYiXQp9Cg==
